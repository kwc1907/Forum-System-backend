/*
Navicat MySQL Data Transfer

Source Server         : first
Source Server Version : 50736
Source Host           : localhost:3306
Source Database       : home

Target Server Type    : MYSQL
Target Server Version : 50736
File Encoding         : 65001

Date: 2022-04-19 09:47:05
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for bms_billboard
-- ----------------------------
DROP TABLE IF EXISTS `bms_billboard`;
CREATE TABLE `bms_billboard` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `content` varchar(255) NOT NULL COMMENT '公告',
  `create_time` datetime DEFAULT NULL COMMENT '公告时间',
  `show` tinyint(1) DEFAULT NULL COMMENT '1：展示中，0：过期',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC COMMENT='全站公告';

-- ----------------------------
-- Records of bms_billboard
-- ----------------------------
INSERT INTO `bms_billboard` VALUES ('2', '版本1.0 已添加夜间护眼模式', '2021-12-16 17:16:19', '1');
INSERT INTO `bms_billboard` VALUES ('4', '系统已更新至最新版1.0.1', '2021-12-17 09:00:29', '0');
INSERT INTO `bms_billboard` VALUES ('8', '本系统将于2021年12月31号停止更新，感谢大家这段时间以来的参与', '2021-12-29 21:50:48', '1');

-- ----------------------------
-- Table structure for bms_comment
-- ----------------------------
DROP TABLE IF EXISTS `bms_comment`;
CREATE TABLE `bms_comment` (
  `id` varchar(20) NOT NULL COMMENT '主键',
  `content` varchar(1000) NOT NULL DEFAULT '' COMMENT '内容',
  `user_id` varchar(20) NOT NULL COMMENT '作者ID',
  `topic_id` varchar(20) NOT NULL COMMENT 'topic_id',
  `create_time` datetime NOT NULL COMMENT '发布时间',
  `modify_time` datetime DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='评论表';

-- ----------------------------
-- Records of bms_comment
-- ----------------------------
INSERT INTO `bms_comment` VALUES ('1413825543843700738', '反射好神奇！！！学到了', '1413705681544794113', '1413714809650470914', '2021-12-13 19:40:51', null);
INSERT INTO `bms_comment` VALUES ('1413825885666893825', '学会了，就可以自己开发一些简单的小游戏了', '1413705681544794113', '1413716616690851841', '2021-12-13 19:42:13', null);
INSERT INTO `bms_comment` VALUES ('1413826013840629762', '很详细，已关注博主，期待后续', '1413705681544794113', '1413718857074139138', '2021-12-13 19:42:43', null);
INSERT INTO `bms_comment` VALUES ('1413840141611212802', '十分有用，感谢博主', '1413705681544794113', '1413722409557352450', '2021-12-13 20:38:52', null);
INSERT INTO `bms_comment` VALUES ('1413841462556925954', '确实不错，支持博主，关注一波', '1413704941749260289', '1413722409557352450', '2021-12-13 20:44:07', null);
INSERT INTO `bms_comment` VALUES ('1413841537924374529', '学到了，感谢', '1413704941749260289', '1413727184311095298', '2021-12-13 20:44:25', null);
INSERT INTO `bms_comment` VALUES ('1413841699409272833', '其实是需要的，我从最早接触java框架开始是ssh,后面再到ssm,再到现在使用的springboot，springmvc是必须的，这里面分为model,view,control,三个部分分别表示封装的对象，展现的视图以及控制器，保守讲，如果你做java开发是需要的，希望你会有收获。', '1413705681544794113', '1413727184311095298', '2021-12-13 20:45:03', null);
INSERT INTO `bms_comment` VALUES ('1413841957971337218', '踩个脚印，不错哦', '1413705681544794113', '1413714194199273473', '2021-12-14 20:46:05', null);
INSERT INTO `bms_comment` VALUES ('1413855086549729281', '保护我方小灰灰', '1413704941749260289', '1413716616690851841', '2021-12-14 21:38:15', null);
INSERT INTO `bms_comment` VALUES ('1413855294293606402', '学到了', '1413704941749260289', '1413716940361097218', '2021-12-15 21:39:04', null);
INSERT INTO `bms_comment` VALUES ('1413855369224847362', '已关注，希望尽快更新', '1413704941749260289', '1413716940361097218', '2021-12-16 21:39:22', null);
INSERT INTO `bms_comment` VALUES ('1413856103160938498', 'vue交流群444444444 ，欢迎大家', '1413704941749260289', '1413855800340578305', '2021-12-16 21:42:17', null);
INSERT INTO `bms_comment` VALUES ('1413856402118344706', '已看完，准备面试', '1413706063062880257', '1413721826163220482', '2021-12-16 21:43:29', null);
INSERT INTO `bms_comment` VALUES ('1413856515469410305', '如果可以获得offer，我请博主吃饭', '1413706063062880257', '1413721826163220482', '2021-12-16 21:43:56', null);
INSERT INTO `bms_comment` VALUES ('1413856621518192642', 'map已看完，不错', '1413706063062880257', '1413717374832271361', '2021-12-16 21:44:21', null);
INSERT INTO `bms_comment` VALUES ('1413856933234671617', 'springboot封装了更多的操作，极大的方便了我们程序猿编写代码', '1413706063062880257', '1413727184311095298', '2021-12-17 21:45:35', null);
INSERT INTO `bms_comment` VALUES ('1413858081781907457', '找一件可以坚持的事，不要停止去寻找的脚步', '1413706636436819970', '1413857938856804353', '2021-12-17 21:50:09', null);
INSERT INTO `bms_comment` VALUES ('1413858218965008386', '已关注博主，真不错', '1413706636436819970', '1413717374832271361', '2021-12-18 21:50:42', null);
INSERT INTO `bms_comment` VALUES ('1413858335549882369', '已看完，但还啥也不会', '1413706636436819970', '1413716616690851841', '2021-12-18 21:51:10', null);
INSERT INTO `bms_comment` VALUES ('1413859849580380162', '看不懂，我坐着看', '1413706512109260801', '1413859145432236033', '2021-12-19 21:57:11', null);
INSERT INTO `bms_comment` VALUES ('1413859967452905473', '接个楼', '1413706512109260801', '1413727184311095298', '2021-12-19 21:57:39', null);
INSERT INTO `bms_comment` VALUES ('1414180171315703810', '学到了，感谢', '1413706063062880257', '1414171656744366082', '2021-12-19 19:10:01', null);
INSERT INTO `bms_comment` VALUES ('1414180778126635010', '为了money 冲冲冲！！！', '1413706063062880257', '1413859730160156674', '2021-12-20 19:12:26', null);
INSERT INTO `bms_comment` VALUES ('1414181208680329217', '6666，膜拜大佬', '1413706063062880257', '1413858778560659458', '2021-12-20 19:14:09', null);
INSERT INTO `bms_comment` VALUES ('1414214485453660162', '学到了，开始搞钱之路', '1413706636436819970', '1413859730160156674', '2021-12-20 21:26:22', null);
INSERT INTO `bms_comment` VALUES ('1414214648314290178', 'AI牛皮！！！', '1413706636436819970', '1413858778560659458', '2021-12-21 21:27:01', null);
INSERT INTO `bms_comment` VALUES ('1414214806179504130', '我选择躺着看！！！', '1413706636436819970', '1413859145432236033', '2021-12-22 21:27:39', null);
INSERT INTO `bms_comment` VALUES ('1414401695213785089', '小白一号来报道了', '1413704941749260289', '1413859730160156674', '2021-12-22 09:50:17', null);
INSERT INTO `bms_comment` VALUES ('1414427022099034113', '不错，学到了', '1414426801273122818', '1413857479840563202', '2021-12-22 11:30:55', null);
INSERT INTO `bms_comment` VALUES ('1414500709879840770', '学到了，膜拜大佬！！！', '1413704941749260289', '1414427942484520961', '2021-12-22 16:23:44', null);
INSERT INTO `bms_comment` VALUES ('1415309367211560961', '感谢大佬，收获很大！！！', '1413705681544794113', '1414919568994676737', '2021-12-24 21:57:02', null);
INSERT INTO `bms_comment` VALUES ('1474263754479820802', '不错 ，可以学到东西', '1474262823382081537', '1413855800340578305', '2021-12-24 14:20:44', null);

-- ----------------------------
-- Table structure for bms_follow
-- ----------------------------
DROP TABLE IF EXISTS `bms_follow`;
CREATE TABLE `bms_follow` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `parent_id` varchar(20) DEFAULT NULL COMMENT '被关注人ID',
  `follower_id` varchar(20) DEFAULT NULL COMMENT '关注人ID',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=148 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC COMMENT='用户关注';

-- ----------------------------
-- Records of bms_follow
-- ----------------------------
INSERT INTO `bms_follow` VALUES ('132', '1413706236086308865', '1413705681544794113');
INSERT INTO `bms_follow` VALUES ('133', '1413706063062880257', '1413705681544794113');
INSERT INTO `bms_follow` VALUES ('137', '1413705681544794113', '1413704941749260289');
INSERT INTO `bms_follow` VALUES ('138', '1413705681544794113', '1413706512109260801');
INSERT INTO `bms_follow` VALUES ('140', '1413705681544794113', '1413706063062880257');
INSERT INTO `bms_follow` VALUES ('142', '1413706512109260801', '1413706063062880257');
INSERT INTO `bms_follow` VALUES ('143', '1414426801273122818', '1413704941749260289');
INSERT INTO `bms_follow` VALUES ('144', '1413706636436819970', '1413704941749260289');
INSERT INTO `bms_follow` VALUES ('145', '1413704941749260289', '1413705681544794113');
INSERT INTO `bms_follow` VALUES ('146', '1413706063062880257', '1413704941749260289');
INSERT INTO `bms_follow` VALUES ('147', '1474262823382081537', '1413704941749260289');

-- ----------------------------
-- Table structure for bms_post
-- ----------------------------
DROP TABLE IF EXISTS `bms_post`;
CREATE TABLE `bms_post` (
  `id` varchar(20) NOT NULL COMMENT '主键',
  `title` varchar(255) NOT NULL DEFAULT '' COMMENT '标题',
  `content` longtext COMMENT 'markdown内容',
  `user_id` varchar(20) NOT NULL COMMENT '作者ID',
  `comments` int(11) NOT NULL DEFAULT '0' COMMENT '评论统计',
  `view` int(11) NOT NULL DEFAULT '0' COMMENT '浏览统计',
  `create_time` datetime NOT NULL COMMENT '发布时间',
  `modify_time` datetime DEFAULT NULL COMMENT '修改时间',
  `echar_time` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `title` (`title`) USING BTREE,
  KEY `user_id` (`user_id`) USING BTREE,
  KEY `create_time` (`create_time`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='话题表';

-- ----------------------------
-- Records of bms_post
-- ----------------------------
INSERT INTO `bms_post` VALUES ('1413714194199273473', 'C站最全Python库总结', '一、python常用高级库\n\n1、操作数据库：MySQLdb\n\n安装MySQLdb，请访问 http://sourceforge.net/projects/mysql-python\n\n```\nimport MySQLdb\n \n# 连接数据库　\nconn = MySQLdb.connect(host=\'localhost\',user=\'root\',passwd=\'xxxx\',db=\'test1\')\n\n \n# 获取cursor对象来进行操作\ncursor = conn.cursor()\n\n# 从你的全世界错过~\nsql = \"select * from world where someone like \'you\' \"\n\n\n# 执行sql\ncursor.execute(sql)\n```\n\n2、Web 开发： flask\n\n把客户端所有的请求都转发给这个程序实例\n\n```\nfrom flask import Flask\nimport datetime\n \nserver=Flask(__name__)\n \n@server.route(\'/time\',methods=[\'post\',\'get\'])\ndef get_time():\n    now=str(datetime.datetime.now())#把当前时间转换成字符串\n    return \"当前的时间是：%s\"%now\n \n \nserver.run(port=8888)\n```\n\n3、网络爬虫：requests\n\nRequests 允许你发送纯天然的 HTTP/1.1 请求，无需手工劳动。你不需要手动为 URL 添加查询字串，也不需要对 POST 数据进行表单编码。Keep-alive 和 HTTP 连接池的功能是 100% 自动化的。\n\n一个简单的爬虫样例：\n\n```\nimport requests\nheads = {}\nheads[\'User-Agent\'] = \'Mozilla/5.0 \' \\\n                          \'(Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 \' \\\n                          \'(KHTML, like Gecko) Version/5.1 Safari/534.50\'\n \nresponse = requests.get(\'http://www.baidu.com\',headers=headers)\n```\n\n4、操作execl：pandas\n\n```\n# -*- coding: utf-8 -*-\nimport xlrdimport xlwt\nfrom datetime import date,datetime\n \ndef read_excel():\n    # 打开文件\n    workbook = xlrd.open_workbook(r\'F:\\demo.xlsx\')\n    # 获取所有sheet\n    print workbook.sheet_names() # [u\'sheet1\', u\'sheet2\']\n    sheet2_name = workbook.sheet_names()[1]\n \n    # 根据sheet索引或者名称获取sheet内容\n    sheet2 = workbook.sheet_by_index(1) # sheet索引从0开始\n    sheet2 = workbook.sheet_by_name(\'sheet2\')\n \n    # sheet的名称，行数，列数\n    print sheet2.name,sheet2.nrows,sheet2.ncols\n \n    # 获取整行和整列的值（数组）\n    rows = sheet2.row_values(3) # 获取第四行内容\n    cols = sheet2.col_values(2) # 获取第三列内容\n    print rows\n    print cols\n \n    # 获取单元格内容\n    print sheet2.cell(1,0).value.encode(\'utf-8\')\n    print sheet2.cell_value(1,0).encode(\'utf-8\')\n    print sheet2.row(1)[0].value.encode(\'utf-8\')\n    \n    # 获取单元格内容的数据类型\n    print sheet2.cell(1,0).ctype\n \nif __name__ == \'__main__\':\n    read_excel()\n```\n\n5、数据分析：numpy\n\nNumPy 包含大量的各种数学运算的函数，包括三角函数，算术运算的函数，复数处理函数等。\n\nNumPy 提供了多种排序的方法。 这些排序函数实现不同的排序算法，每个排序算法的特征在于执行速度，最坏情况性能，所需的工作空间和算法的稳定性。 下表显示了三种排序算法的比较。\n\n三角函数\n\nNumPy 提供了标准的三角函数：sin()、cos()、tan()。\n\n```\nimport numpy as np\n \na = np.array([0,30,45,60,90])\nprint (\'不同角度的正弦值：\')\n# 通过乘 pi/180 转化为弧度  \nprint (np.sin(a*np.pi/180))\nprint (\'\\n\')\nprint (\'数组中角度的余弦值：\')\nprint (np.cos(a*np.pi/180))\nprint (\'\\n\')\nprint (\'数组中角度的正切值：\')\nprint (np.tan(a*np.pi/180))\n```\n\n6、数据画图分析：Matplotlib\n\n```\nimport numpy as np \nfrom matplotlib import pyplot as plt \n \nx = np.arange(1,11) \ny =  2  * x +  5 \nplt.title(\"Matplotlib demo\") \nplt.xlabel(\"x axis caption\") \nplt.ylabel(\"y axis caption\") \nplt.plot(x,y) \nplt.show()\n```\n\n以上实例中，np.arange() 函数创建 x 轴上的值。y 轴上的对应值存储在另一个数组对象 y 中。 这些值使用 matplotlib 软件包的 pyplot 子模块的 plot() 函数绘制。\n\n图形由 show() 函数显示。\n\n7、科学计算：scipy\n\n  scipy.special库中的特殊函数都是超越函数，所谓超越函数是指变量之间的关系不能用有限次加、减、乘、除、乘方、开方 运算表示的函数。如初等函数中的三角函数、反三角函数与对数函数、指数函数都是初等超越函数，一般来说非初等函数都是超越函数。\n\n\n8、视觉及图像处理：PIL（pillow）\n\n创建缩略图\n\n```\nimport os\nfrom PIL import Image\n \nimage_path = \'python-logo.png\'  # 图片位置\nsize = (128, 128)  # 文件大小\nf, e = os.path.splitext(image_path)  # 获取文件名与后缀\noutfile = f + \".thumbnail\"\nif image_path != outfile:\n    try:\n        im = Image.open(image_path)\n        im.thumbnail(size)  # 设置缩略图大小\n        im.save(outfile, \"JPEG\")\n    except IOError:\n        print(\"cannot convert\", image_path)\n```\n\n创建滚动图形\n\n```\npython学得好，PS也能干！\n\nfrom PIL import Image\n \n \ndef roll(image, delta):\n    \"\"\" 向侧面滚动图像 \"\"\"\n    xsize, ysize = image.size\n \n    delta = delta % xsize\n    if delta == 0: return image\n \n    part1 = image.crop((0, 0, delta, ysize))\n    part2 = image.crop((delta, 0, xsize, ysize))\n    image.paste(part1, (xsize - delta, 0, xsize, ysize))\n    image.paste(part2, (0, 0, xsize - delta, ysize))\n \n    return image\n \n \nif __name__ == \'__main__\':\n    image_path = \'test.jpg\'\n    im = Image.open(image_path)\n    roll(im, 300).show()  # 向侧面滚动 300 像素\n```\n\n9、图形界面开发： PyQT\n\n俄罗斯方块游戏是有史以来最受欢迎的电脑游戏。\n\n最初的游戏是由俄罗斯设计和编程的程序员阿列克谢帕基特诺夫于1985年。此后,俄罗斯方块是几乎所有的计算机平台上可用在很多变化。\n俄罗斯方块称为积木拼图游戏。在这个游戏中,我们有七种不同形状叫tetrominoes:“s”形,Z-shape,t形,一个l型的空间,一个线,MirroredL-shape和正方形。这些形状的形成有四个方格。形状是跌倒。俄罗斯方块游戏的对象是移动和旋转的形状使他们适合尽可能多。\n\n如果我们设法形成一个行,该行摧毁我们得分。我们直到我们玩俄罗斯方块游戏。\n\ntetrominoes\n\nPyQt5是一种用于创建应用程序的工具。还有其他的库是针对创建电脑游戏。\n\n然而,PyQt5和其他应用程序工具包可以用来创建简单的游戏。\n创建一个电脑游戏是一个提高编程技能的很好的方发。\n\n10、游戏开发：pygame\n\n```\nPygame是一组跨平台的Python模块, 用于创建视频游戏。\n它由旨在与Python编程语言一起使用的计算机图形和声音库组成。\nPygame由Pete Shinners正式编写, 以取代PySDL。\nPygame适合于创建客户端应用程序, 这些应用程序可以包装在独立的可执行文件中。\n\nimport pygame\n \npygame.init()\nscreen = pygame.display.set_mode((400, 500))\ndone = False\n \nwhile not done:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            done = True\n    pygame.display.flip()\n```\n\n```\n\n```\n\n', '1413704941749260289', '1', '12', '2021-12-13 12:18:24', '2021-12-13 12:19:16', '2021-12-13');
INSERT INTO `bms_post` VALUES ('1413714809650470914', 'java的上乘武功，反射，好好玩哦', '前言\n\n各位大侠们知道Java的反射是什么吗？可不是反着发射什么的哈。\n\n反射是Java的一种机制，一般也叫做反射机制，本文会讲反射机制是什么和怎么使用。\n\n请先给二当家的一个三连，然后接着读下去吧，多谢。\n\n```\n本文由 二当家的白帽子 https://le-yi.blog.csdn.net/ 博客原创，转载请注明来源，谢谢~\n```\n\n文章目录\n\n```\n前言\n先来看一段魔法吧\n反射机制是个什么玩意儿？\n构造任意一个类的对象\n了解任意一个对象所属的类\n了解任意一个类的成员变量和方法\n调用任意一个对象的属性和方法\n魔法揭秘\n尾声\n```\n\n先来看一段魔法吧\n\npublic class Test {\nprivate static void changeStrValue(String str, char[] value) {\n// 只要执行魔法代码就可以达到下面的效果\n// 施展魔法的代码稍后揭秘\n}\n\n```\npublic static void main(String[] args) {\n    changeStrValue(\"abc\", new char[]{\'d\',\'e\',\'f\'});\n\n    String abc = \"abc\";\n    System.out.println(\"abc\");\n    System.out.println(abc);\n    System.out.println(\"abc\".equals(abc));\n}\n```\n\n二当家的第一次看到这个执行结果觉得很有意思。明明应该是\"abc\"怎么就变成了\"def\"呢？\n反射机制是个什么玩意儿？\n\n```\nJava的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。反射被视为动态语言的关键。\n```\n\n以上就是百科的解释。可能有点抽象，接着看二当家的给你秀起来解释一下。\n构造任意一个类的对象\n\n一般情况下，我们如果想要创建一个类的对象，应该要用到new关键字。但是像spring这样的框架，我们只需要配置类名，就可以得到类的实例。他是怎么做到的呢？\n\nimport java.util.List;\n\npublic class Test {\n/**\n\n* 根据类名取得类实例\n* @author 二当家的白帽子 https://le-yi.blog.csdn.net/\n* @param className\n* @param <T>\n* @return\n* @throws InstantiationException\n* @throws IllegalAccessException\n* @throws ClassNotFoundException\n  */\n  public static <T> T getInstance(String className) throws InstantiationException, IllegalAccessException, ClassNotFoundException {\n  Class<T> clazz = (Class<T>) Class.forName(className);\n  return clazz.newInstance();\n  }\n\n```\npublic static void main(String[] args) throws InstantiationException, IllegalAccessException, ClassNotFoundException {\nList<String> list = getInstance(\"java.util.ArrayList\");\nlist.add(\"abc\");\nlist.add(\"def\");\n\n``for (String v : list) { System.out.println(v); }``\n\n类名可以在程序运行中从配置文件获取，甚至是从网络获取，然后动态创建一个类的实例。\n了解任意一个对象所属的类\n\nimport java.util.ArrayList;\n\npublic class Test {\n/**\n\n* 打印对象的类名\n* @author 二当家的白帽子 https://le-yi.blog.csdn.net/\n* @param o\n  */\n  public static void printClass(Object o) {\n  System.out.printf(o.getClass().getName());\n  }\n\npublic static void main(String[] args) {\nprintClass(new ArrayList<>());\n}\n```\n\n}\n\n```\n了解任意一个类的成员变量和方法\n\n我们一般要使用一个类，先要知道有什么方法和属性，先了解，后使用。但是像spring那样的框架为什么可以为我们自动注入呢？他怎么知道我们一个对象里有什么属性呢？\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\npublic class Test {\n/**\n\n* 打印类的属性\n* @author 二当家的白帽子 https://le-yi.blog.csdn.net/\n* @param clazz\n  */\n  public static void printFields(Class clazz) {\n  System.out.println(clazz.getName() + \"包含如下属性：\");\n  for (Field f : clazz.getDeclaredFields()) {\n  System.out.println(f);\n  }\n  }\n```\n\n/**\n\n* 打印类的方法\n* @author 二当家的白帽子 https://le-yi.blog.csdn.net/\n* @param clazz\n  */\n  public static void printMethods(Class clazz) {\n  System.out.println(clazz.getName() + \"包含如下方法：\");\n  for (Method m : clazz.getDeclaredMethods()) {\n  System.out.println(m);\n  }\n  }\n\npublic static void main(String[] args) {\nprintFields(MyClass.class);\nprintMethods(MyClass.class);\n}\n\n```\n}\n\nclass MyClass {\nprivate String name;\n```\n\npublic String getName() {\nreturn name;\n}\n\npublic void setName(String name) {\nthis.name = name;\n}\n\n像spring这样的框架，即使一个属性是私有属性并且没有set方法，一样可以注入。\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\npublic class Test {\n/**\n\n* 调用一个对象的方法\n* @author 二当家的白帽子 https://le-yi.blog.csdn.net/\n* @param o\n* @param methodName\n* @throws NoSuchMethodException\n* @throws InvocationTargetException\n* @throws IllegalAccessException\n  */\n  public static void callMethod(Object o, String methodName) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n  Method m = o.getClass().getDeclaredMethod(methodName);\n  m.setAccessible(true);\n  m.invoke(o);\n  }\n\n```\n\n```\n\n/**\n\n* 修改一个对象的属性\n* @author 二当家的白帽子 https://le-yi.blog.csdn.net/\n* @param o\n* @param fieldName\n* @param value\n* @throws IllegalAccessException\n  */\n  public static void changeFieldValue(Object o, String fieldName, Object value) throws NoSuchFieldException, IllegalAccessException {\n  Field f = o.getClass().getDeclaredField(fieldName);\n  f.setAccessible(true);\n  f.set(o, value);\n  }\n\npublic static void main(String[] args) throws InvocationTargetException, NoSuchMethodException, IllegalAccessException, NoSuchFieldException {\nMyClass o = new MyClass();\n\n```\n// 修改任意属性，即使是私有的\nchangeFieldValue(o, \"name\", \"二当家的白帽子\");\n\n// 调用任意方法，即使是私有的\ncallMethod(o, \"printName\");\n```\n\n}\n\n```\n}\n\nclass MyClass {\n// 私有属性，只可以调用set方法修改\nprivate String name;\n```\n\nprivate void printName() {\n// 私有方法，只有本类自己的实例可以调用\nSystem.out.println(\"My name is \" + name);\n}\n\npublic String getName() {\nreturn name;\n}\n\npublic void setName(String name) {\nthis.name = name;\n}\n\n\n\n是时候揭秘魔法的真面目了，没错，也是利用了反射。\n\nimport java.lang.reflect.Field;\n\npublic class Test {\n/**\n\n* 修改字符串内部的值\n* @author 二当家的白帽子 https://le-yi.blog.csdn.net/\n* @param str\n* @param value\n  */\n  private static void changeStrValue(String str, char[] value) {\n  try {\n  Field f = str.getClass().getDeclaredField(\"value\");\n  f.setAccessible(true);\n  f.set(str, value);\n  } catch (Exception e) {\n  e.printStackTrace();\n  }\n  }\n```\n\npublic static void main(String[] args) {\nchangeStrValue(\"abc\", new char[]{\'d\',\'e\',\'f\'});\n\n```\n// 这里的\"abc\"字符串和上面调用changeStrValue的参数\"abc\"会指向同一块内存\nString abc = \"abc\";\nSystem.out.println(\"abc\");\nSystem.out.println(abc);\nSystem.out.println(\"abc\".equals(abc));\n```\n\n}\n\n```\n}\n```\n\n要理解这段代码，除了反射机制还需要了解java对于字符串的处理。\"字符串常量池\"已经超出本文的范围，是另一个话题，本文就不多说了。\n\n原本字符串内容是\"abc\"，我们正常情况下无法修改这个内容，因为String是不变类。但是反射大法却可以打破一切禁忌。\n尾声\n\n一般的程序可能用不到写反射的代码。但是像spring这样的框架，如果没有反射，我真的想不出如何实现呢。哪怕永远不需要用反射，了解机制对我们都有着莫大的好处。\n```\n\n', '1413704941749260289', '1', '16', '2021-12-13 12:20:50', '2021-12-15 12:22:20', '2021-12-13');
INSERT INTO `bms_post` VALUES ('1413716616690851841', '从零开发一个灰太狼游戏是什么样的体验？', '```\n开发思路\n```\n\n开发一个游戏，首先你需要知道游戏的规则。\n\n这个游戏名为狂拍灰太狼。\n\n规则：\n\n```\n游戏时间 60 s\n游戏角色为灰太狼、小灰灰\n拼手速殴打灰太狼\n殴打灰太狼 + 10 分，殴打小灰灰 - 10 分\n```\n\n开发技术\n\n```\nhtml\ncss\njq\n```\n\n实现思路\n\n```\n1.利用 html + css 布局游戏界面\n2.导入 jq 库\n3.实现狂拍灰太狼游戏逻辑\n```\n\n核心逻辑\n\n```\n封装 60 s 进度条方法\n封装处理灰太狼动画的方法\n游戏按钮点击监听\n\nHTML 代码\n```\n\n<!DOCTYPE html>\n\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>狂拍灰太狼</title>\n    <link rel=\"stylesheet\" href=\"css/index.css\">\n    <script src=\"js/jquery-1.12.4.js\"></script>\n    <script src=\"js/index.js\"></script>\n</head>\n<body>\n<div class=\"container\">\n    <h1 class=\"score\">0</h1>\n    <div class=\"progress\"></div>\n    <button class=\"start\">开始游戏</button>\n    <div class=\"rules\">游戏规则</div>\n    <div class=\"rule\">\n        <p>游戏规则:</p>\n        <p>1.游戏时间:60s</p>\n        <p>2.拼手速,殴打灰太狼+10分</p>\n        <p>3.殴打小灰灰-10分</p>\n        <a href=\"#\" class=\"close\">[关闭]</a>\n    </div>\n    <div class=\"mask\">\n        <h1>GAME OVER</h1>\n        <button class=\"reStart\">重新开始</button>\n    </div>\n</div>\n</body>\n</html>\n\n*{\nmargin: 0;\npadding: 0;\n}\n.container{\nwidth: 320px;\nheight: 480px;\nbackground: url(\"../images/game_bg.jpg\") no-repeat 0 0;\nmargin: 50px auto;\nposition: relative;\n}\n.container>h1{\ncolor: white;\nmargin-left: 60px;\n}\n.container>.progress{\nwidth: 180px;\nheight: 16px;\nbackground: url(\"../images/progress.png\") no-repeat 0 0;\nposition: absolute;\ntop: 66px;\nleft: 63px;\n}\n.container>.start{\nwidth: 150px;\nline-height: 35px;\ntext-align: center;\ncolor: white;\nbackground: linear-gradient(#E55C3D,#C50000);\nborder-radius: 20px;\nborder: none;\nfont-size: 20px;\nposition: absolute;\ntop: 320px;\nleft: 50%;\nmargin-left: -75px;\n}\n.container>.rules{\nwidth: 100%;\nheight: 20px;\nbackground: #ccc;\nposition: absolute;\nleft: 0;\nbottom: 0;\ntext-align: center;\n}\n.container>.rule{\nwidth: 100%;\nheight: 100%;\nbackground: rgba(0,0,0,0.5);\nposition: absolute;\nleft: 0;\ntop: 0;\npadding-top: 100px;\nbox-sizing: border-box;\ntext-align: center;\ndisplay: none;\n}\n.rule>p{\nline-height: 50px;\ncolor: white;\n}\n.rule>a{\ncolor: red;\n}\n.container>.mask{\nwidth: 100%;\nheight: 100%;\nbackground: rgba(0,0,0,0.5);\nposition: absolute;\nleft: 0;\ntop: 0;\npadding-top: 200px;\nbox-sizing: border-box;\ntext-align: center;\ndisplay: none;\n}\n.mask>h1{\ncolor: #ff4500;\ntext-shadow: 3px 3px 0 #fff;\nfont-size: 40px;\n}\n.mask>button{\nwidth: 150px;\nline-height: 35px;\ntext-align: center;\ncolor: white;\nbackground: linear-gradient(#74ACCF,#007DDC);\nborder-radius: 20px;\nborder: none;\nfont-size: 20px;\nposition: absolute;\ntop: 320px;\nleft: 50%;\nmargin-left: -75px;\n}\n\n$(function () {\n// 1.监听游戏规则的点击\n$(\".rules\").click(function () {\n$(\".rule\").stop().fadeIn(100);\n});\n\n```\n// 2.监听关闭按钮的点击\n$(\".close\").click(function () {\n    $(\".rule\").stop().fadeOut(100);\n});\n\n// 3.监听开始游戏按钮的点击\n$(\".start\").click(function () {\n    $(this).stop().fadeOut(100);\n    // 调用处理进度条的方法\n    progressHandler();\n    // 调用处理灰太狼动画的方法\n    startWolfAnimation();\n});\n\n// 4.监听重新开始按钮的点击\n$(\".reStart\").click(function () {\n    $(\".mask\").stop().fadeOut(100);\n    // 调用处理进度条的方法\n    progressHandler();\n    // 调用处理灰太狼动画的方法\n    startWolfAnimation();\n});\n\n// 定义一个专门处理进度条的方法\nfunction progressHandler() {\n    // 重新设置进度条的宽度\n    $(\".progress\").css({\n        width: 180\n    });\n    // 开启定时器处理进度条\n    var timer = setInterval(function () {\n        // 拿到进度条当前的宽度\n        var progressWidth = $(\".progress\").width();\n        // 减少当前的宽度\n        progressWidth -= 1;\n        // 重新给进度条赋值宽度\n        $(\".progress\").css({\n            width: progressWidth\n        });\n        // 监听进度条是否走完\n        if(progressWidth <= 0){\n            // 关闭定时器\n            clearInterval(timer);\n            // 显示重新开始界面\n            $(\".mask\").stop().fadeIn(100);\n            // 停止灰太狼的动画\n            stopWolfAnimation();\n        }\n    }, 100);\n}\n\nvar wolfTimer;\n// 定义一个专门处理灰太狼动画的方法\nfunction startWolfAnimation() {\n    // 1.定义两个数组保存所有灰太狼和小灰灰的图片\n    var wolf_1=[\'./images/h0.png\',\'./images/h1.png\',\'./images/h2.png\',\'./images/h3.png\',\'./images/h4.png\',\'./images/h5.png\',\'./images/h6.png\',\'./images/h7.png\',\'./images/h8.png\',\'./images/h9.png\'];\n    var wolf_2=[\'./images/x0.png\',\'./images/x1.png\',\'./images/x2.png\',\'./images/x3.png\',\'./images/x4.png\',\'./images/x5.png\',\'./images/x6.png\',\'./images/x7.png\',\'./images/x8.png\',\'./images/x9.png\'];\n    // 2.定义一个数组保存所有可能出现的位置\n    var arrPos = [\n        {left:\"100px\",top:\"115px\"},\n        {left:\"20px\",top:\"160px\"},\n        {left:\"190px\",top:\"142px\"},\n        {left:\"105px\",top:\"193px\"},\n        {left:\"19px\",top:\"221px\"},\n        {left:\"202px\",top:\"212px\"},\n        {left:\"120px\",top:\"275px\"},\n        {left:\"30px\",top:\"295px\"},\n        {left:\"209px\",top:\"297px\"}\n    ];\n\n    // 3.创建一个图片\n    var $wolfImage = $(\"<images src=\'\' class=\'wolfImage\'>\");\n    // 随机获取图片的位置\n    var posIndex = Math.round(Math.random() * 8);\n    // 4.设置图片显示的位置\n    $wolfImage.css({\n       position: \"absolute\",\n        left:arrPos[posIndex].left,\n        top:arrPos[posIndex].top\n    });\n    // 随机获取数组类型\n    var wolfType = Math.round(Math.random()) == 0 ? wolf_1 : wolf_2;\n    // 5.设置图片的内容\n    window.wolfIndex = 0;\n    window.wolfIndexEnd = 5;\n    wolfTimer = setInterval(function () {\n        if(wolfIndex > wolfIndexEnd){\n            $wolfImage.remove();\n            clearInterval(wolfTimer);\n            startWolfAnimation();\n        }\n        $wolfImage.attr(\"src\", wolfType[wolfIndex]);\n        wolfIndex++;\n    }, 300);\n\n    // 6.将图片添加到界面上\n    $(\".container\").append($wolfImage);\n\n    // 7.调用处理游戏规则的方法\n    gameRules($wolfImage);\n}\n\nfunction gameRules($wolfImage) {\n    $wolfImage.one(\"click\",function () {\n        // 修改索引\n        window.wolfIndex = 5;\n        window.wolfIndexEnd = 9;\n\n        // 拿到当前点击图片的地址\n        var $src = $(this).attr(\"src\");\n        // 根据图片地址判断是否是灰太狼\n        var flag = $src.indexOf(\"h\") >= 0;\n        // 根据点击的图片类型增减分数\n        if(flag){\n            // +10\n            $(\".score\").text(parseInt($(\".score\").text()) + 10);\n        }else{\n            // -10\n            $(\".score\").text(parseInt($(\".score\").text()) - 10);\n        }\n    });\n}\nfunction stopWolfAnimation() {\n    $(\".wolfImage\").remove();\n    clearInterval(wolfTimer);\n}\n```\n\n});\n\n```\n开发思路\n```\n\n开发一个游戏，首先你需要知道游戏的规则。\n\n这个游戏名为狂拍灰太狼。\n\n规则：\n\n```\n游戏时间 60 s\n游戏角色为灰太狼、小灰灰\n拼手速殴打灰太狼\n殴打灰太狼 + 10 分，殴打小灰灰 - 10 分\n```\n\n开发技术\n\n```\nhtml\ncss\njq\n```\n\n实现思路\n\n```\n1.利用 html + css 布局游戏界面\n2.导入 jq 库\n3.实现狂拍灰太狼游戏逻辑\n```\n\n核心逻辑\n\n```\n封装 60 s 进度条方法\n封装处理灰太狼动画的方法\n游戏按钮点击监听\n\nHTML 代码\n```\n\n```\ncss 代码\n<!DOCTYPE html>\n\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>狂拍灰太狼</title>\n    <link rel=\"stylesheet\" href=\"css/index.css\">\n    <script src=\"js/jquery-1.12.4.js\"></script>\n    <script src=\"js/index.js\"></script>\n</head>\n<body>\n<div class=\"container\">\n    <h1 class=\"score\">0</h1>\n    <div class=\"progress\"></div>\n    <button class=\"start\">开始游戏</button>\n    <div class=\"rules\">游戏规则</div>\n    <div class=\"rule\">\n        <p>游戏规则:</p>\n        <p>1.游戏时间:60s</p>\n        <p>2.拼手速,殴打灰太狼+10分</p>\n        <p>3.殴打小灰灰-10分</p>\n        <a href=\"#\" class=\"close\">[关闭]</a>\n    </div>\n    <div class=\"mask\">\n        <h1>GAME OVER</h1>\n        <button class=\"reStart\">重新开始</button>\n    </div>\n</div>\n</body>\n</html>\n```\n\n\n$(function () {\n// 1.监听游戏规则的点击\n$(\".ruls\").click(function () {\n$(\".rule\").stop().fadeIn(100);\n});\n\n```\n// 2.监听关闭按钮的点击\n$(\".close\").click(function () {\n    $(\".rule\").stop().fadeOut(100);\n});\n\n// 3.监听开始游戏按钮的点击\n$(\".start\").click(function () {\n    $(this).stop().fadeOut(100);\n    // 调用处理进度条的方法\n    progressHandler();\n    // 调用处理灰太狼动画的方法\n    startWolfAnimation();\n});\n\n// 4.监听重新开始按钮的点击\n$(\".reStart\").click(function () {\n    $(\".mask\").stop().fadeOut(100);\n    // 调用处理进度条的方法\n    progressHandler();\n    // 调用处理灰太狼动画的方法\n    startWolfAnimation();\n});\n\n// 定义一个专门处理进度条的方法\nfunction progressHandler() {\n    // 重新设置进度条的宽度\n    $(\".progress\").css({\n        width: 180\n    });\n    // 开启定时器处理进度条\n    var timer = setInterval(function () {\n        // 拿到进度条当前的宽度\n        var progressWidth = $(\".progress\").width();\n        // 减少当前的宽度\n        progressWidth -= 1;\n        // 重新给进度条赋值宽度\n        $(\".progress\").css({\n            width: progressWidth\n        });\n        // 监听进度条是否走完\n        if(progressWidth <= 0){\n            // 关闭定时器\n            clearInterval(timer);\n            // 显示重新开始界面\n            $(\".mask\").stop().fadeIn(100);\n            // 停止灰太狼的动画\n            stopWolfAnimation();\n        }\n    }, 100);\n}\n\nvar wolfTimer;\n// 定义一个专门处理灰太狼动画的方法\nfunction startWolfAnimation() {\n    // 1.定义两个数组保存所有灰太狼和小灰灰的图片\n    var wolf_1=[\'./images/h0.png\',\'./images/h1.png\',\'./images/h2.png\',\'./images/h3.png\',\'./images/h4.png\',\'./images/h5.png\',\'./images/h6.png\',\'./images/h7.png\',\'./images/h8.png\',\'./images/h9.png\'];\n    var wolf_2=[\'./images/x0.png\',\'./images/x1.png\',\'./images/x2.png\',\'./images/x3.png\',\'./images/x4.png\',\'./images/x5.png\',\'./images/x6.png\',\'./images/x7.png\',\'./images/x8.png\',\'./images/x9.png\'];\n    // 2.定义一个数组保存所有可能出现的位置\n    var arrPos = [\n        {left:\"100px\",top:\"115px\"},\n        {left:\"20px\",top:\"160px\"},\n        {left:\"190px\",top:\"142px\"},\n        {left:\"105px\",top:\"193px\"},\n        {left:\"19px\",top:\"221px\"},\n        {left:\"202px\",top:\"212px\"},\n        {left:\"120px\",top:\"275px\"},\n        {left:\"30px\",top:\"295px\"},\n        {left:\"209px\",top:\"297px\"}\n    ];\n\n    // 3.创建一个图片\n    var $wolfImage = $(\"<images src=\'\' class=\'wolfImage\'>\");\n    // 随机获取图片的位置\n    var posIndex = Math.round(Math.random() * 8);\n    // 4.设置图片显示的位置\n    $wolfImage.css({\n       position: \"absolute\",\n        left:arrPos[posIndex].left,\n        top:arrPos[posIndex].top\n    });\n    // 随机获取数组类型\n    var wolfType = Math.round(Math.random()) == 0 ? wolf_1 : wolf_2;\n    // 5.设置图片的内容\n    window.wolfIndex = 0;\n    window.wolfIndexEnd = 5;\n    wolfTimer = setInterval(function () {\n        if(wolfIndex > wolfIndexEnd){\n            $wolfImage.remove();\n            clearInterval(wolfTimer);\n            startWolfAnimation();\n        }\n        $wolfImage.attr(\"src\", wolfType[wolfIndex]);\n        wolfIndex++;\n    }, 300);\n\n    // 6.将图片添加到界面上\n    $(\".container\").append($wolfImage);\n\n    // 7.调用处理游戏规则的方法\n    gameRules($wolfImage);\n}\n\nfunction gameRules($wolfImage) {\n    $wolfImage.one(\"click\",function () {\n        // 修改索引\n        window.wolfIndex = 5;\n        window.wolfIndexEnd = 9;\n\n        // 拿到当前点击图片的地址\n        var $src = $(this).attr(\"src\");\n        // 根据图片地址判断是否是灰太狼\n        var flag = $src.indexOf(\"h\") >= 0;\n        // 根据点击的图片类型增减分数\n        if(flag){\n            // +10\n            $(\".score\").text(parseInt($(\".score\").text()) + 10);\n        }else{\n            // -10\n            $(\".score\").text(parseInt($(\".score\").text()) - 10);\n        }\n    });\n}\nfunction stopWolfAnimation() {\n    $(\".wolfImage\").remove();\n    clearInterval(wolfTimer);\n}\n```\n\n});\n\n', '1413705681544794113', '3', '21', '2021-12-13 12:28:01', '2021-12-15 17:51:22', '2021-12-13');
INSERT INTO `bms_post` VALUES ('1413716940361097218', 'Java 动态代理', '好几天不写文章，今天来写一篇，从之前的计划表上看到还有关于java的动态代理没写，这个技术平常用的少，也不是特别好理解，今天补上这篇，希望能讲明白，不至于像我一样迷茫好久，开始吧\n\n动态代理分两部分，动态和代理，我们先说下代理模式\n1、代理模式\n\n代理模式是常用的设计模式之一，也是开发中常见的设计模式。\n\n简单的描述一下，代理模式就是将实现类隔离开，比如你想给你女朋友过个生日，找个明星唱生日歌，你女朋友的偶像是周杰伦，想找周杰伦给她过生日，唱歌，但是你不太能联系上周杰伦，即使在社交网站上联系，可能也不太理你，所以你可以联系周杰伦的经纪人进行沟通，经纪人就是周杰伦的代理。\n\n实现过程：\n\n```\n定义一个唱歌的接口，代表业务\n\n    public interface ISing {\n       void sing();\n    }\n\n周杰伦有唱歌的业务，并且业务突出，实现接口\n\n    /**\n    * 周杰伦\n    */\n    public class JayImp implements ISing {\n       @Override\n       public void sing() {\n           System.out.println(\"say happy birthday to you girl friend\");\n      }\n    }\n\n经纪人接受业务, 经纪人的构造函数需要和明星绑定\n\n经纪人接收唱歌的业务，今天可能是周杰伦唱，明天可能经纪人换了明星，比如蔡依林也是可以的\n\n    /**\n    * 经纪人\n    */\n    public class JayProxy implements ISing{\n       ISing target;\n     \n       /**\n        * 初始化的时候，和明星进行签约\n        * @param target\n        */\n       public JayProxy(ISing target) {\n           this.target = target;\n      }\n     \n       @Override\n       public void sing() {\n           target.sing();\n      }\n    }\n\n联系经纪人进行唱歌，周杰伦唱完歌之后，经纪人收钱，very happy\n\n    public class MoneyOwner {\n       public static void main(String[] args) {\n           JayImp jay = new JayImp();\n           // 周杰伦和经纪人进行签约，这一步可以放在内部实现\n           JayProxy jayProxy = new JayProxy(jay);\n           jayProxy.sing();\n      }\n    }\n```\n\n看下执行结果，皆大欢喜，你女朋友很开心。\n\n图片\n\n上面这一套就是代理模式的实现，\n\n但是代理类只能代理一种类，如果为每一个服务都创建一个代理类，有点傻\n\n而且接口如果改变的情况下代理类也需要改变，非常不方便，周杰伦又是拍电影，做综艺，写歌，业务很多\n\n好了，静态代理该说的也说了，相信看到这里你应该没有什么不理解的，下面我们正式开始今天的正餐，动态代理\n2、动态代理\n\n动态代理是Java提供的一种代理方式，这个技术的核心点就是在运行期的时候对接口进行增强，生成class 对象，然后加载进虚拟机，说简单点就是虚拟机帮你创建了一个实现你接口的class\n\n废话少说，先来实现一个动态代理\n\n第一步定义接口，上面代码已经有了 ISing 就不重复定义了\n\n第二步 实现接口，上面代码也已经实现了 JayImp ,也不重复定义了，这次经纪人多签约了一个歌手，林俊杰，看下实现\n\n```\npackage org.pdool.dynamic;\n \n/**\n* 林俊杰\n*/\npublic class JJImp implements ISing {\n   @Override\n   public void sing() {\n       System.out.println(\"I am JJ! happy birthday to you\");\n  }\n}\n```\n\n第三步，经纪人可以动态派出签约歌手，注意经纪人要实现InvocationHandler，这样才能统一处理所有的方法调用\n\n```\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n \npublic class JayAgentFactory implements InvocationHandler {\n   Object target;\n \n   public JayAgentFactory(Object target) {\n       this.target = target;\n  }\n \n   // 生成代理类\n   public ISing CreatProxyedObj() {\n       return (ISing) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);\n  }\n \n   @Override\n   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n       Object invoke = method.invoke(target, args);\n       logAfter(invoke);\n       return invoke;\n  }\n \n   public void logAfter(Object invoke) {\n       System.out.println(\"结果 \" + invoke);\n       System.out.println(\"收入 ++ \");\n  }\n}\n```\n\n第四步，接收业务\n\n```\npackage org.pdool.dynamic;\n \nimport java.lang.reflect.Proxy;\n \npublic class Aain {\n   public static void main(String[] args) {\n       JayImp jayImp = new JayImp();\n       ISing subjectProxy=(ISing) Proxy.newProxyInstance(jayImp.getClass().getClassLoader(), jayImp.getClass().getInterfaces(), new JayAgentFactory(jayImp));\n       subjectProxy.sing();\n  }\n}\n```\n\n总结：动态代理是Java提供的实现方式，需要InvocationHandler 的实现类\n\n1、为什么编辑器可以提示接口的方法？因为强转编辑器才会能有提示\n\n2、生成的内存class是的默认构造函数是需要InvocationHandler参数\n\n3、创建代理class的核心参数是 类加载器，接口，还有InvocationHandler 子类。\n\n类加载器保证和目标类在同一个加载器内，可以调用，防止不同加载器加载的类之间不能调用\n\n接口就是你要代理的接口\n\nInvocationHandler 子类是转发器，将所有的消息进行拦截处理转发\n3、原理研究\n\n实现看到了，探究下原理，动态代理的最根本的在于根据接口创建内存class，这一步是怎么实现的，我们跟着源码瞧一瞧\n\n图片\n\n1、克隆接口里函数的信息\n\n2、查找或生成指定的代理类，如果缓存中有，则用缓存的，没有则创建\n\n3、通过反射，拿到代理类的构造函数\n\n4、通过构造函数创建一个代理对象，并关联InvocationHandler 的对象\n\n```\n/** parameter types of a proxy class constructor */\n   private static final Class<?>[] constructorParams =\n      { InvocationHandler.class };\n```\n\n看到了流程，我们看下代理class  到底是什么样子的，\n\n```\nimport sun.misc.ProxyGenerator;\n \npublic class Test {\n   public static void main(String[] args) {\n       //开启保存代码class属性\n       System.getProperties().put(\"sun.misc.ProxyGenerator.saveGeneratedFiles\", \"true\");\n       ProxyGenerator.generateProxyClass(\"Xiangcai\", JayImp.class.getInterfaces());\n  }\n}\n```\n\n执行上面的函数，可以看到在项目的路径下生成Xiangcai.class\n\n图片\n\n接着看看xiangcai.class 到底有哪些东西，直接拖到编辑器就可以了\n\n```\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.lang.reflect.UndeclaredThrowableException;\nimport org.pdool.dynamic.ISing;\n \npublic final class xiangcai extends Proxy implements ISing {\n   private static Method m1;\n   private static Method m2;\n   private static Method m3;\n   private static Method m0;\n \n   public xiangcai(InvocationHandler var1) throws {\n       super(var1);\n  }\n \n   public final boolean equals(Object var1) throws {\n       try {\n           return (Boolean)super.h.invoke(this, m1, new Object[]{var1});\n      } catch (RuntimeException | Error var3) {\n           throw var3;\n      } catch (Throwable var4) {\n           throw new UndeclaredThrowableException(var4);\n      }\n  }\n \n   public final String toString() throws {\n       try {\n           return (String)super.h.invoke(this, m2, (Object[])null);\n      } catch (RuntimeException | Error var2) {\n           throw var2;\n      } catch (Throwable var3) {\n           throw new UndeclaredThrowableException(var3);\n      }\n  }\n//注意看这里！！！其他的都不重要\n   public final void sing() throws {\n       try {\n           super.h.invoke(this, m3, (Object[])null);\n      } catch (RuntimeException | Error var2) {\n           throw var2;\n      } catch (Throwable var3) {\n           throw new UndeclaredThrowableException(var3);\n      }\n  }\n \n   public final int hashCode() throws {\n       try {\n           return (Integer)super.h.invoke(this, m0, (Object[])null);\n      } catch (RuntimeException | Error var2) {\n           throw var2;\n      } catch (Throwable var3) {\n           throw new UndeclaredThrowableException(var3);\n      }\n  }\n \n   static {\n       try {\n           m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\"));\n           m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\");\n           m3 = Class.forName(\"org.pdool.dynamic.ISing\").getMethod(\"sing\");\n           m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\");\n      } catch (NoSuchMethodException var2) {\n           throw new NoSuchMethodError(var2.getMessage());\n      } catch (ClassNotFoundException var3) {\n           throw new NoClassDefFoundError(var3.getMessage());\n      }\n  }\n}\n```\n\n可以看到实现了sing的接口，并且调用了invokehandler的方法invoke.好了，真相大白了，你明白了吗？\n\n有人会说，道理我都懂，可是不会用啊，但是没看到好的应用场景，所以有段时间是没掌握这些的，下面我们就具体一下应用场景\n4、应用\n\n在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。看个具体的例子 spring-data-jpa 的实现\n\n具体的使用：\n\nspring中访问数据库的使用\n\n```\nimport com.tao.springboot.hibernate.entity.Customer;\nimport org.springframework.data.jpa.repository.JpaRepository;\n \npublic interface CustomerRepository extends JpaRepository<Customer, Long> {\n \n}\n```\n\n只要实现上面的接口就可以直接操作数据库，是不是很简单？\n\n有几个问题，你稍微思考下：\n\n1、两个泛型什么意思？\n\n2、数据库连接在哪？是怎么注入的？\n\n3、只实现接口是怎么操作数据库的？\n\n第一个问题答案：\n\nCustomer 为表对象对应的entity实体。\n\nLong 是表的主键类型，\n\n第二个答案：\n\n数据库连接是在spring启动的时候自动注入到spring 容器中的，在JpaRepository 的实现类自动注入的\n\n第三个答案：\n\n所有的的接口在spring启动的时候会生成代理类，目标类target就是实现类SimpleJpaRepository\n\n看下类图\n\n图片\n\n看下JpaRepository的定义，都是一些常用方法\n\n```\npublic interface JpaRepository<T, ID> extends PagingAndSortingRepository<T, ID>, QueryByExampleExecutor<T> {\n   List<T> findAll();\n \n   List<T> findAll(Sort var1);\n \n   List<T> findAllById(Iterable<ID> var1);\n \n   <S extends T> List<S> saveAll(Iterable<S> var1);\n \n   void flush();\n \n   <S extends T> S saveAndFlush(S var1);\n \n   void deleteInBatch(Iterable<T> var1);\n \n   void deleteAllInBatch();\n \n   T getOne(ID var1);\n \n   <S extends T> List<S> findAll(Example<S> var1);\n \n   <S extends T> List<S> findAll(Example<S> var1, Sort var2);\n}\n```\n\n看下SimpleJpaRepository 的定义：\n\n```\npublic class SimpleJpaRepository<T, ID> implements JpaRepositoryImplementation<T, ID> {\n   private static final String ID_MUST_NOT_BE_NULL = \"The given id must not be null!\";\n   private final JpaEntityInformation<T, ?> entityInformation;\n  private final EntityManager em;//看这里！！！\n   private final PersistenceProvider provider;\n   @Nullable\n   private CrudMethodMetadata metadata;\n   \n   //具体的实现方法\n      @Transactional\n   public void delete(T entity) {\n       Assert.notNull(entity, \"The entity must not be null!\");\n       this.em.remove(this.em.contains(entity) ? entity : this.em.merge(entity));\n  }\n```\n\n类似下面的代码调用：\n\nProxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), JpaRepository.class.getInterfaces(), new SimpleJpaRepository(());\n\n注：只是表达一下意思，具体的实现应该不是这样的\n5、总结\n\n所有的事情都解开了，下面进行总结下：\n\n1、静态代理是代理模式的实现，是针对某一个具体的接口的实现\n\n2、动态代理的是jdk提供的一种方式，必须要接口，还有其他的实现方式cglib,javassit 等等\n\n3、动态代理是在运行的时候生成class 文件然后自动加载的class\n\n4、动态代理是基于反射调用的技术\n\n5、动态代理会生成class 到 metaspace\n\n6、多应用在框架中\n\n7、解密了spring data jpa的实现\n\n', '1413705681544794113', '2', '15', '2021-12-13 12:29:18', '2021-12-15 19:10:43', '2021-12-13');
INSERT INTO `bms_post` VALUES ('1413717374832271361', 'MySql知识体系总结（2021版）', '1、第一层负责连接管理、授权认证、安全等等。\n\n每个客户端的连接都对应着服务器上的一个线程。服务器上维护了一个线程池，避免为每个连接都创建销毁一个线程。当客户端连接到MySQL服务器时，服务器对其进行认证。可以通过用户名和密码的方式进行认证，也可以通过SSL证书进行认证。登录认证通过后，服务器还会验证该客户端是否有执行某个查询的权限。\n2、第二层负责解析查询\n\n编译SQL，并对其进行优化(如调整表的读取顺序，选择合适的索引等)。对于SELECT语句，在解析查询前，服务器会先检查查询缓存，如果能在其中找到对应的查询结果，则无需再进行查询解析、优化等过程，直接返回查询结果。存储过程、触发器、视图等都在这一层实现。\n3、第三层是存储引擎\n\n存储引擎负责在MySQL中存储数据、提取数据、开启一个事务等等。存储引擎通过API与上层进行通信，这些API屏蔽了不同存储引擎之间的差异，使得这些差异对上层查询过程透明。存储引擎不会去解析SQL。\n二、对比InnoDB与MyISAM\n1、 存储结构\n\nMyISAM：每个MyISAM在磁盘上存储成三个文件。分别为：表定义文件、数据文件、索引文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。\n\nInnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。\n2、 存储空间\n\nMyISAM： MyISAM支持支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。当表在创建之后并导入数据之后，不会再进行修改操作，可以使用压缩表，极大的减少磁盘的空间占用。\n\nInnoDB： 需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。\n3、 可移植性、备份及恢复\n\nMyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。\n\nInnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。\n4、 事务支持\n\nMyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。\n\nInnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。\n5、 AUTO_INCREMENT\n\nMyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。\n\nInnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。\n6、 表锁差异\n\nMyISAM： 只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。\n\nInnoDB： 支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。\n7、 全文索引\n\nMyISAM：支持 FULLTEXT类型的全文索引\n\nInnoDB：不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。\n8、表主键\n\nMyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。\n\nInnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。\n9、表的具体行数\n\nMyISAM： 保存有表的总行数，如果select count() from table;会直接取出出该值。\n\nInnoDB： 没有保存表的总行数，如果使用select count(*) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。\n10、CRUD操作\n\nMyISAM：如果执行大量的SELECT，MyISAM是更好的选择。\n\nInnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。\n11、 外键\n\nMyISAM：不支持\n\nInnoDB：支持\n三、sql优化简介\n1、什么情况下进行sql优化\n\n性能低、执行时间太长、等待时间太长、连接查询、索引失效。\n2、sql语句执行过程\n\n（1）编写过程\n\nselect distinct ... from ... join ... on ... where ... group by ... having ... order by ... limit ...\n\n（2）解析过程\n\nfrom ... on ... join ... where ... group by ... having ... select distinct ... order by ... limit ...\n\n3、sql优化就是优化索引\n\n索引相当于书的目录。\n\n索引的数据结构是B+树。\n四、索引\n1、索引的优势\n\n（1）提高查询效率（降低IO使用率）\n\n（2）降低CPU使用率\n\n比如查询order by age desc，因为B+索引树本身就是排好序的，所以再查询如果触发索引，就不用再重新查询了。\n2、索引的弊端\n\n（1）索引本身很大，可以存放在内存或硬盘上，通常存储在硬盘上。\n\n（2）索引不是所有情况都使用，比如①少量数据②频繁变化的字段③很少使用的字段\n\n（3）索引会降低增删改的效率\n3、索引的分类\n\n（1）单值索引\n\n（2）唯一索引\n\n（3）联合索引\n\n（4）主键索引\n\n备注：唯一索引和主键索引唯一的区别：主键索引不能为null\n4、创建索引\n\nalter table user add INDEX `user_index_username_password` (`username`,`password`)\n\n5、MySQL索引原理 -> B+树\n\nMySQL索引的底层数据结构是B+树\n\nB+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。\n\nB-Tree结构图中每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。\n\nB+Tree相对于B-Tree有几点不同：\n\n非叶子节点只存储键值信息。\n所有叶子节点之间都有一个链指针。\n数据记录都存放在叶子节点中。\n将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：\n\n通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。\n\n可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：\n\nInnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。\n\n实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。\n\n数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。\n五、如何触发联合索引\n1、对user表建立联合索引username、password\n\n2、触发联合索引\n\n（1）使用联合索引的全部索引键可触发联合索引\n\n（2）使用联合索引的全部索引键，但是用or连接的，不可触发联合索引\n\n（3）单独使用联合索引的左边第一个字段时，可触发联合索引\n\n（4）单独使用联合索引的其它字段时，不可触发联合索引\n\n六、分析sql的执行计划---explain\n\nexplain可以模拟sql优化执行sql语句。\n1、explan使用简介\n\n（1）用户表\n\n（2）部门表\n\n（3）未触发索引\n\n（4）触发索引\n\n（5）结果分析\n\nexplain中第一行出现的表是驱动表。\n\n```\n指定了联接条件时，满足查询条件的记录行数少的表为[驱动表]\n未指定联接条件时，行数少的表为[驱动表]\n```\n\n对驱动表直接进行排序就会触发索引，对非驱动表进行排序不会触发索引。\n2、explain查询结果简介\n\n（1）id：SELECT识别符。这是SELECT的查询序列号。\n\n（2）select_type：SELECT类型：\n\n```\nSIMPLE： 简单SELECT(不使用UNION或子查询)\nPRIMARY： 最外面的SELECT\nUNION：UNION中的第二个或后面的SELECT语句\nDEPENDENT UNION：UNION中的第二个或后面的SELECT语句，取决于外面的查询\nUNION RESULT：UNION的结果\nSUBQUERY：子查询中的第一个SELECT\nDEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外面的查询\nDERIVED：导出表的SELECT(FROM子句的子查询)\n```\n\n（3）table：表名\n\n（4）type：联接类型\n\n```\nsystem：表仅有一行(=系统表)。这是const联接类型的一个特例。\nconst：表最多有一个匹配行，它将在查询开始时被读取。因为仅有一行，在这行的列值可被优化器剩余部分认为是常数。const用于用常数值比较PRIMARY KEY或UNIQUE索引的所有部分时。\neq_ref：对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型。它用在一个索引的所有部分被联接使用并且索引是UNIQUE或PRIMARY KEY。eq_ref可以用于使用= 操作符比较的带索引的列。比较值可以为常量或一个使用在该表前面所读取的表的列的表达式。\nref：对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。如果联接只使用键的最左边的前缀，或如果键不是UNIQUE或PRIMARY KEY(换句话说，如果联接不能基于关键字选择单个行的话)，则使用ref。如果使用的键仅仅匹配少量行，该联接类型是不错的。ref可以用于使用=或<=>操作符的带索引的列。\nref_or_null：该联接类型如同ref，但是添加了MySQL可以专门搜索包含NULL值的行。在解决子查询中经常使用该联接类型的优化。\nindex_merge：该联接类型表示使用了索引合并优化方法。在这种情况下，key列包含了使用的索引的清单，key_len包含了使用的索引的最长的关键元素。\nunique_subquery：该类型替换了下面形式的IN子查询的ref：value IN (SELECT primary_key FROMsingle_table WHERE some_expr);unique_subquery是一个索引查找函数，可以完全替换子查询，效率更高。\nindex_subquery：该联接类型类似于unique_subquery。可以替换IN子查询，但只适合下列形式的子查询中的非唯一索引：value IN (SELECT key_column FROM single_table WHERE some_expr)\nrange：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。key_len包含所使用索引的最长关键元素。在该类型中ref列为NULL。当使用=、<>、>、>=、<、<=、IS NULL、<=>、BETWEEN或者IN操作符，用常量比较关键字列时，可以使用range\nindex：该联接类型与ALL相同，除了只有索引树被扫描。这通常比ALL快，因为索引文件通常比数据文件小。\nall：对于每个来自于先前的表的行组合，进行完整的表扫描。如果表是第一个没标记const的表，这通常不好，并且通常在它情况下很差。通常可以增加更多的索引而不要使用ALL，使得行能基于前面的表中的常数值或列值被检索出。\n```\n\n（5）possible_keys：possible_keys列指出MySQL能使用哪个索引在该表中找到行。注意，该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。\n\n（6）key：key列显示MySQL实际决定使用的键(索引)。如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。\n\n（7）key_len：key_len列显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。注意通过key_len值我们可以确定MySQL将实际使用一个多部关键字的几个部分。\n\n（8）ref：ref列显示使用哪个列或常数与key一起从表中选择行。\n\n（9）rows：rows列显示MySQL认为它执行查询时必须检查的行数。\n\n（10）Extra：该列包含MySQL解决查询的详细信息。\n\n```\nDistinct：MySQL发现第1个匹配行后，停止为当前的行组合搜索更多的行。\nNot exists：MySQL能够对查询进行LEFT JOIN优化，发现1个匹配LEFT JOIN标准的行后，不再为前面的的行组合在该表内检查更多的行。\nrange checked for each record (index map: #)：MySQL没有发现好的可以使用的索引，但发现如果来自前面的表的列值已知，可能部分索引可以使用。对前面的表的每个行组合，MySQL检查是否可以使用range或index_merge访问方法来索取行。\nUsing filesort：MySQL需要额外的一次传递，以找出如何按排序顺序检索行。通过根据联接类型浏览所有行并为所有匹配WHERE子句的行保存排序关键字和行的指针来完成排序。然后关键字被排序，并按排序顺序检索行。\nUsing index：从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。当查询只使用作为单一索引一部分的列时，可以使用该策略。\nUsing temporary：为了解决查询，MySQL需要创建一个临时表来容纳结果。典型情况如查询包含可以按不同情况列出列的GROUP BY和ORDER BY子句时。\nUsing where：WHERE子句用于限制哪一个行匹配下一个表或发送到客户。除非你专门从表中索取或检查所有行，如果Extra值不为Using where并且表联接类型为ALL或index，查询可能会有一些错误。\nUsing sort_union(...), Using union(...), Using intersect(...)：这些函数说明如何为index_merge联接类型合并索引扫描。\nUsing index for group-by：类似于访问表的Using index方式，Using index for group-by表示MySQL发现了一个索引，可以用来查询GROUP BY或DISTINCT查询的所有列，而不要额外搜索硬盘访问实际的表。并且，按最有效的方式使用索引，以便对于每个组，只读取少量索引条目。\n```\n\n\n', '1413706063062880257', '2', '7', '2021-12-13 12:31:02', null, '2021-12-13');
INSERT INTO `bms_post` VALUES ('1413718857074139138', '【Python从入门到精通】（六）Python内置的数据类型-列表（list）和元组（tuple）,九浅一深，十个章节，不信你用不到', '```\n一浅: 列表（list）的介绍\n    二浅：列表的操作\n    三浅：向列表中新增元素\n    四浅：修改列表中的元素\n    五浅：删除列表中的元素\n    六浅：列表中元素的查找以及访问\n        访问列表中的元素\n        查找某个元素在列表中出现的位置 index()\n    七浅：列表使用技巧及注意事项\n        Python新增元素中各个方法的区别\n    八浅：元组（tuple）的介绍\n        元组的创建方式\n    九浅：元组和列表的区别\n        小结\n    一深：列表和元组的底层实现\n    总结\n```\n\n一浅: 列表（list）的介绍\n\n列表作为Python序列类型中的一种，其也是用于存储多个元素的一块内存空间，这些元素按照一定的顺序排列。其数据结构是：\n\n[element1, element2, element3, ..., elementn]\n\n```\n1\n```\n\nelement1~elementn表示列表中的元素，元素的数据格式没有限制，只要是Python支持的数据格式都可以往里面方。同时因为列表支持自动扩容，所以它可变序列，即可以动态的修改列表，即可以修改，新增，删除列表元素。看个爽图吧！\n在这里插入图片描述\n二浅：列表的操作\n\n首先介绍的是对列表的操作：包括列表的创建，列表的删除等！其中创建一个列表的方式有两种：\n第一种方式：\n通过[]包裹列表中的元素，每个元素之间通过逗号,分割。元素类型不限并且同一列表中的每个元素的类型可以不相同，但是不建议这样做，因为如果每个元素的数据类型都不同的话则非常不方便对列表进行遍历解析。所以建议一个列表只存同一种类型的元素。\n\nlist=[element1, element2, element3, ..., elementn]\n\n```\n1\n```\n\n例如：test_list = [\'测试\', 2, [\'码农飞哥\', \'小伟\'], (12, 23)]\nPS: 空列表的定义是list=[]\n第二种方式：\n通过list(iterable)函数来创建列表，list函数是Python内置的函数。该函数传入的参数必须是可迭代的序列，比如字符串，列表，元组等等，如果iterable传入为空，则会创建一个空的列表。iterable不能只传一个数字。\n\nclassmates1 = list(\'码农飞哥\')\nprint(classmates1)\n\n生成的列表是：[\'码\', \'农\', \'飞\', \'哥\']\n三浅：向列表中新增元素\n\n向列表中新增元素的方法有四种，分别是：\n第一种: 使用**+运算符将多个列表**连接起来。相当于在第一个列表的末尾添加上另一个列表。其语法格式是listname1+listname2\n\nname_list = [\'码农飞哥\', \'小伟\', \'小小伟\']\nname_list2 = [\'python\', \'java\']\nprint(name_list + name_list2)\n\n输出结果是：[\'码农飞哥\', \'小伟\', \'小小伟\', \'python\', \'java\']，可以看出将name_list2中的每个元素都添加到了name_list的末尾。\n第二种：使用append()方法添加元素\nappend()方法用于向列表末尾添加元素，其语法格式是:listname.append(p_object)其中listname表示要添加元素的列表，p_object表示要添加到列表末尾的元素，可以是字符串，数字，也可以是一个序列。举个栗子：\n\nname_list.append(\'Adam\')\nprint(name_list)\nname_list.append([\'test\', \'test1\'])\nprint(name_list)\n\n运行结果是：\n\n[\'码农飞哥\', \'小伟\', \'小小伟\', \'Adam\']\n[\'码农飞哥\', \'小伟\', \'小小伟\', \'Adam\', [\'test\', \'test1\']]\n\n```\n\n```\n\n可以看出待添加的元素都成功的添加到了原列表的末尾处。并且当添加的元素是一个序列时，则会将该序列当成一个整体。\n第三种：使用extend()方法\nextend()方法跟append()方法的用法相同，同样是向列表末尾添加元素。元素的类型只需要Python支持的数据类型即可。不过与append()方法不同的是，当添加的元素是序列时，extend()方法不会将列表当成一个整体，而是将每个元素添加到列表末尾。还是上面的那个例子：\n\nname_list = [\'码农飞哥\', \'小伟\', \'小小伟\']\nname_list.extend(\'Adam\')\nprint(name_list)\nname_list.extend([\'test\', \'test1\'])\nprint(name_list)\n\n运行结果是：\n\n[\'码农飞哥\', \'小伟\', \'小小伟\', \'A\', \'d\', \'a\', \'m\']\n[\'码农飞哥\', \'小伟\', \'小小伟\', \'A\', \'d\', \'a\', \'m\', \'test\', \'test1\']\n\n从结果看出，当添加字符串时会将字符串中的每个字符作为一个元素添加到列表的末尾处，当添加的列表时会将列表中的每个元素添加到末尾处。\n第四种：使用insert()方法\n前面介绍的几种插入方法，都只能向列表的末尾处插入元素，如果想在列表指定位置插入元素则无能为力。insert()方法正式用于处理这种问题而来的。其语法结构是listname.insert(index, p_object) 其中index表示指定位置的索引值，insert()会将p_object插入到listname列表第index个元素的位置。与append()方法相同的是，如果待添加的元素的是序列，则insert()会将该序列当成一个整体插入到列表的指定位置处。举个栗子：\n\nname_list = [\'码农飞哥\', \'小伟\', \'小小伟\']\nname_list.insert(1, \'Jack\')\nprint(name_list)\nname_list.insert(2, [\'test\', \'test1\'])\nprint(name_list)\n\n运行结果是：\n\n[\'码农飞哥\', \'Jack\', \'小伟\', \'小小伟\']\n[\'码农飞哥\', \'Jack\', [\'test\', \'test1\'], \'小伟\', \'小小伟\']\n\n四浅：修改列表中的元素\n\n说完了列表中元素新增的方法，接着让我们来看看修改列表中的元素相关的方法。修改列表元素的方法有两种：\n第一种：修改单个元素：\n修改单个元素的方法就是对某个索引上的元素进行重新赋值。其语法结构是：listname[index]=newValue，就是将列表listname中索引值为index位置上的元素替换成newValue。\n举个栗子：\n\nname_list = [\'码农飞哥\', \'小伟\', \'小小伟\']\nname_list[1] = \'Sarah\'\nprint(name_list)\n\n运行结果：[\'码农飞哥\', \'Sarah\', \'小小伟\'] 从结果可以看出索引为1处的元素值被成功修改成了Sarch。\n第二种：通过切片语法修改一组元素\n通过切片语法可以修改一组元素，其语法结构是:listname[start:end:step]，其中，listname表示列表名称，start表示起始位置，end表示结束位置（不包括），step表示步长，如果不指定步长，Python就不要求新赋值的元素个数与原来的元素个数相同，这意味着，该操作可以为列表添加元素，也可以为列表删除元素。举个栗子：\n\nname_list = [\'码农飞哥\', \'小伟\', \'小小伟\']\nname_list[0:1] = [\'飞哥\', \'牛逼\']\nprint(name_list)\n\n运行结果是：[\'飞哥\', \'牛逼\', \'小伟\', \'小小伟\'] ，从结果可以看出将原列表中索引为0处的元素值已经被替换为飞哥,并且插入了牛逼 这个元素。\n五浅：删除列表中的元素\n\n删除列表中元素的方法共有四种。\n第一种：根据索引值删除元素的del关键字\n根据索引值删除元素的del关键字有两种形式，一种是删除单个元素，del listname[index]，一种是根据切片删除多个元素del listname[start : end]，其中，listname表示列表名称，start表示起始索引，end表示结束索引，del会删除从索引start到end之间的元素，但是不包括end位置的元素。还是举个栗子：\n\nname_list = [\'码农飞哥\', \'小伟\', \'小小伟\', \'超人\']\nname_list2 = name_list\nprint(\'原始的name_list={0}\'.format(name_list))\nprint(\'原始的name_list2={0}\'.format(name_list2))\n\n# 删除索引0到2之间的元素，即删除索引0和索引1两个位置的元素\n\ndel name_list[0:2]\nprint(\'使用del删除元素后name_list={0}\'.format(name_list))\nprint(\'使用del删除元素后name_list2={0}\'.format(name_list2))\ndel name_list\nprint(\'使用del删除列表后name_list2={0}\'.format(name_list2))\n\n运行结果是：\n\n原始的name_list=[\'码农飞哥\', \'小伟\', \'小小伟\', \'超人\']\n原始的name_list2=[\'码农飞哥\', \'小伟\', \'小小伟\', \'超人\']\n使用del删除元素后name_list=[\'小小伟\', \'超人\']\n使用del删除元素后name_list2=[\'小小伟\', \'超人\']\n使用del删除列表后name_list2=[\'小小伟\', \'超人\']\n\n可以看出用del删除列表元素时是真实的删除了内存数据的，但是用del删除列表时，则只是删除了变量，name_list2所指向的内存数据还是存在的。\n第二种：根据索引值删除元素的pop()方法\n根据索引值删除元素的pop()方法的语法结构是：listname.pop(index)，其中，listname表示列表名称，index表示索引值，如果不写index参数，默认会删除列表中最后一个元素，类似于数据结构中的出栈操作。举个例子：\n\nname_list = [\'码农飞哥\', \'小伟\', \'小小伟\', \'超人\']\n\n# 删除list末尾的元素\n\nname_list.pop()\nprint(name_list)\n\n# 删除指定位置的元素，用pop(i)方法，其中i是索引位置\n\nname_list.pop(1)\nprint(name_list)\n\n运行结果是：\n\n[\'码农飞哥\', \'小伟\', \'小小伟\']\n[\'码农飞哥\', \'小小伟\']\n\n第三种：根据元素值进行删除的remove()方法\n根据元素值进行删除的remove()方法,其语法结构是:listname.remove(object)，其中listname表示列表的名称，object表示待删除的元素名称。需要注意的是：如果元素在列表中不存在则会报ValueError的错误。举个栗子：\n\nname_list = [\'码农飞哥\', \'小伟\', \'小小伟\', \'超人\']\nname_list.remove(\'小小伟\')\nprint(name_list)\n\n运行结果是：[\'码农飞哥\', \'小伟\', \'超人\']。\n第四种：删除列表中的所有元素clear()方法\n通过clear()方法可以删除掉列表中的所有元素，其语法结构是：listname.clear()，其中listname表示列表的名称。还是举个栗子吧：\n\nname_list = [\'码农飞哥\', \'小伟\', \'小小伟\', \'超人\']\nname_list.clear()\nprint(name_list)\n\n运行结果是：[]，可以看出列表中元素被全部清空了。\n六浅：列表中元素的查找以及访问\n\n说完了第五浅列表元素的删除，略感疲惫。接着进行第六浅吧！看看列表中元素的查找以及访问。看完这个之后，列表相关的内容也就告一段落了。\n访问列表中的元素\n\n访问列表中的元素有两种方式，分别是通过索引定位访问单个元素，通过切片访问多个元素。\n第一种：通过索引定位访问单个元素，其语法结构是：listname[index] ,其中listname表示列表的名字，index表示要查找元素的索引值。\n第二种：通过切片的方式访问多个元素，其语法结构是：listname[start:end:step]。其中，listname表示列表的名字，start表示开始索引，end表示结束索引（不包括end位置），step表示步长。同样是举个栗子：\n\nlist = [\'码农飞哥\', \'小伟\', \'小小伟\',123]\nprint(list[0])  # 输出列表的第一个元素\nprint(list[1:3])  # 输出第二个至第三个元素\nprint(list[2:])  # 输出从第三个开始至列表末尾的所有元素\n\n运行结果是：\n\n码农飞哥\n[\'小伟\', \'小小伟\']\n[\'小小伟\', 123]\n\n查找某个元素在列表中出现的位置 index()\n\nindext()方法用来查找某个元素在列表中出现的位置（也就是索引），如果该元素在列表中不存在，则会报ValueError错误。其语法结构是：listname.index(object, start, end) 其中listname表示列表的名字，object表示要查找的元素，start表示起始索引，end表示结束索引（不包括）。\n\nname_list = [\'码农飞哥\', \'小伟\', \'小小伟\', \'超人\']\nprint(name_list.index(\'小伟\', 0, 2))\n\n```\n1\n2\n```\n\n运行结果是：1\n七浅：列表使用技巧及注意事项\n\n此处留一个空白，欢迎小伙伴留言告诉我，先看个图放松下吧！！\n在这里插入图片描述\n图片看完之后是不是感觉好多了，那就让我们接着来学习吧。\nPython新增元素中各个方法的区别\n\n前面介绍了使用+运算符，使用append方法，使用extend方法都可以新增元素，那么他们到底有啥区别呢？还是举例说明吧;\n\nname_list = [\'码农飞哥\', \'小伟\', \'小小伟\', \'超人\']\nname_list2 = [\'牛魔王\']\nname_list3 = name_list + name_list2\nprint(\"原始的name_list的值={0}；内存地址={1}\".format(name_list, id(name_list)))\nprint(\"使用+运算符后name_list3的值={0}；内存地址={1}\".format(name_list3, id(name_list3)))\nprint(\"使用+运算符后name_list的值{0}；内存地址={1}\".format(name_list, id(name_list)))\nname_list4 = name_list.append(\'牛魔王\')\nprint(\'使用append方法后name_list4的值={0}；内存地址={1}\'.format(name_list4, id(name_list4)))\nprint(\"使用append方法后name_list的值{0}；内存地址={1}\".format(name_list, id(name_list)))\nname_list5 = name_list.extend(\'牛魔王\')\nprint(\'使用extend方法后name_list5的值={0}；内存地址={1}\'.format(name_list4, id(name_list4)))\nprint(\"使用extend方法后name_list的值{0}；内存地址={1}\".format(name_list, id(name_list)))\n\n运行结果是：\n\n原始的name_list的值=[\'码农飞哥\', \'小伟\', \'小小伟\', \'超人\']；内存地址=2069467533448\n使用+运算符后name_list3的值=[\'码农飞哥\', \'小伟\', \'小小伟\', \'超人\', \'牛魔王\']；内存地址=2069467533896\n使用+运算符后name_list的值[\'码农飞哥\', \'小伟\', \'小小伟\', \'超人\']；内存地址=2069467533448\n使用append方法后name_list4的值=None；内存地址=2012521616\n使用append方法后name_list的值[\'码农飞哥\', \'小伟\', \'小小伟\', \'超人\', \'牛魔王\']；内存地址=2069467533448\n使用extend方法后name_list5的值=None；内存地址=2012521616\n使用extend方法后name_list的值[\'码农飞哥\', \'小伟\', \'小小伟\', \'超人\', \'牛魔王\', \'牛\', \'魔\', \'王\']；内存地址=2069467533448\n\n从运行结果可以看出如下几点：\n\n```\n使用+运算符是创建一个新的列表，新列表的地址与原列表的地址不相同，并且原始列表的内容不会改变。\nappend方法和extend方法都是修改原始列表的内容，并且都没有返回值，所以两者都不能使用链式表达式。\n当待添加的元素是列表时,append方法会将列表当成一个整体，而extend不会。\n```\n\n八浅：元组（tuple）的介绍\n\n说完了列表，接着让我们来看看另外一个重要的序列–元组（tuple），和列表类似，元组也是由一系列按特定书序排序的元素组成，与列表最重要的区别是，元组属于不可变序列，即元组一旦被创建，它的元素就不可更改了。\n元组的创建方式\n\n第一种：使用()直接创建\n使用()创建元组的语法结构是tuplename=(element1,element2,....,elementn),其中tuplename表示元组的变量名，element1~elementn表示元组中的元素。小括号不是必须的，只要将元素用逗号分隔，Python就会将其视为元组。还是举个栗子：\n\n#创建元组\ntuple_name = (\'码农飞哥\', \'小伟\', \'小小伟\', \'超人\')\nprint(tuple_name)\n#去掉小括号创建元组\ntuple2 = \'码农飞哥\', \'小伟\', \'小小伟\', \'超人\'\nprint(type(tuple2))\n\n运行结果是：\n\n(\'码农飞哥\', \'小伟\', \'小小伟\', \'超人\')\n<class \'tuple\'>\n\n第二种：使用tuple()函数创建\n与列表类似的，我们可以通过tuple(iterable)函数来创建元组，如果iterable传入为空，则创建一个空的元组，iterable 参数必须是可迭代的序列，比如字符串，列表，元组等。同样的iterable不能传入一个数字。举个栗子：\n\nname_list = [\'码农飞哥\', \'小伟\', \'小小伟\', \'超人\']\nprint(tuple(name_list))\nprint(tuple(\'码农飞哥\'))\n\n运行结果是：\n\n(\'码农飞哥\', \'小伟\', \'小小伟\', \'超人\')\n(\'码\', \'农\', \'飞\', \'哥\')\n\n由于元组是不可变序列，所以没有修改元素相关的方法，只能对元组中的元素进行查看。查看元素的方式也与列表类似，共两种方式：\n第一种：通过索引（index）访问元组中的元素，其语法结构是tuplename[index]\n第二种：通过切片的方式访问，其语法结构是：tuplename[start:end:step]\n相关参数的描述在此不再赘述了。依然是举例说明：\n\ntuple_name = (\'码农飞哥\', \'小伟\', \'小小伟\', \'超人\')\n\n# 获取索引为1的元素值\n\nprint(tuple_name[1])\n#获取索引为1到索引为2之间的元素值，不包括索引2本身\nprint(tuple_name[0:2])\n\n运行结果是：\n\n小伟\n(\'码农飞哥\', \'小伟\')\n\n元组中的元素不能修改，不过可以通过 + 来生成一个新的元组。\n九浅：元组和列表的区别\n\n说完了前面八浅之后，也有点累了。接着说下元组和列表的区别吧。为啥Python要另外设置元组这样一个数据结构呢？元组的功能列表不是都可以满足么？所以，这一浅主要是介绍元组的优点，存在即合理，哈哈哈哈。\n区别：\n\n```\n元素是否可以修改？\n列表中的元素可以修改，而元组中的元素不能修改。如果强行修改元组中的元素，你会得到如下错误：\n```\n\nTypeError: \'tuple\' object does not support item assignment\n\n```\n1\n\n存储同样数据所占空间\n下面展示初始化一个空列表和一个空元组所占的字节数\n```\n\n> > > listdemo = []\n> > > listdemo.__sizeof__()\n> > > 40\n> > > tupleDemo = ()\n> > > tupleDemo.__sizeof__()\n> > > 24\n\n可以看出元组比列表少占用16个字节，这是因为列表是动态的，它需要存储指针来指向对应的元素（占用8个字节），另外，由于列表中的元素可变，所以需要额外存储已经分配的长度大小（占用8个字节）。但是对于元组，情况就不同了，元组长度的大小固定，其存储元素不可变，所以存储空间也是固定的。总体来说，元组的存储性能要由于列表，存储同样数据所占用空间更小。\n3. 初始化同样数据所需时间\n大家想一想初始化同样数据的元组和列表，哪个的速度更快呢？是元组还是列表呢？相信大部分人都会选择元组，那么元组到底快多少呢？下面就用一个例子说明一下：同样是初始化元素为1,2,3,4两个序列。\n\n(python-demo)  root$ python3 -m timeit \'x=(1,2,3,4)\'\n10000000 loops, best of 3: 0.029 usec per loop\n(python-demo)  root$ python3 -m timeit \'x=[1,2,3,4]\'\n10000000 loops, best of 3: 0.165 usec per loop\n\n初始化元组花了0.029秒，初始化话列表花了0.165 秒，所以，可以得出的结论是初始化一个相同元素的列表和元组分别所需的时间，元组的初始化速度要比列表快5倍多。\n小结\n\n元组有如下优点：元组比列表的访问和处理速度更快，存储相同内容所需空间更小。\n一深：列表和元组的底层实现\n\n九浅已经完成了，最后就来一次更深入的交流吧。知其然更要知其所以然。话不多说，下面就直接从源码层面来看看列表和元组的底层实现。\n首先来分析列表（list），它的具体结构如下所示：\n\ntypedef struct {\nPyObject_VAR_HEAD\n/* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */\nPyObject **ob_item;\n\n```\n/* ob_item contains space for \'allocated\' elements.  The number\n * currently in use is ob_size.\n * Invariants:\n *     0 <= ob_size <= allocated\n *     len(list) == ob_size\n *     ob_item == NULL implies ob_size == allocated == 0\n * list.sort() temporarily sets allocated to -1 to detect mutations.\n *\n * Items must normally not be NULL, except during construction when\n * the list is not yet visible outside the function that builds it.\n */\nPy_ssize_t allocated;\n```\n\n} PyListObject;\n\nPS：列表实现的源码文件是 listobject.h 和 listobject.c。\nlist 本质上是一个长度可变的连续数组。其中ob_item是一个指针列表，里面的每个指针都指向列表中的元素，而allocated则用于存储该列表目前被分配的空间大小。\n需要注意的是，allocated和列表的实际空间大小不同，列表实际空间大小是指len(list)返回的结果，即上面注释中的ob_size,表示该列表实际存储了多少个元素，而实际情况是，为了优化存储结构，避免每次增加元素都要重新分配内存，列表预分配的空间allocated往往大于ob_size。他们的关系是0 <= ob_size <= allocated。\n接下来在分析元组，如下所示为Python3.7 tuple元组的具体结构:\n\ntypedef struct {\nPyObject_VAR_HEAD\nPyObject *ob_item[1];\n\n```\n/* ob_item contains space for \'ob_size\' elements.\n * Items must normally not be NULL, except during construction when\n * the tuple is not yet visible outside the function that builds it.\n */\n```\n\n} PyTupleObject;\n\nPS: 元组（tuple）实现的源码文件是 tupleobject.h 和 tupleobject.c。\ntuple和list相似，本质也是一个数组，但是空间大小固定。不同于一般数组，Python 的 tuple 做了许多优化，来提升在程序中的效率。\n在这里插入图片描述\n总结\n\n本文详细介绍了Python内置数据类型中的列表（list）和元组（tuple）。特别是列表，它的新增元素和删除元素的方法很多，各种方法之间还有许多不同，需要在使用时特别注意。对于不涉及修改元素操作的场景，优先使用元组。因为它的性能更好，所占空间更少。\n\n', '1413706636436819970', '1', '13', '2021-12-13 12:36:55', '2021-12-15 12:44:03', '2021-12-13');
INSERT INTO `bms_post` VALUES ('1413721826163220482', 'Java 学习路线，学完轻松获得offer', '13 年 Java 编程经验的老油条了，拒绝过阿里，在日企搬砖过 5 年，Java 领域的优质创作者，说实话，如果是单纯奔着实习 Offer 去的话，还是不难的。\n\n说句挺不好意思的话，上学和刚参加工作那会，我一直傻乎乎的认为，只要把 Java 吃透的话就可以了，直到近些年我才恍然大悟，我的认知是有缺陷的。想从事 Java 后端开发工作，需要从以下 5 个方面做起，找到实习 Offer 绝壁不是问题。\n\n```\nC 程序设计语言，为什么学 Java 要学 C 语言呢？这也是我最近才想明白的一个问题，因为 C语言是其他编程语言的母胎，包括 Java，不少同学感觉自己学 Java 很吃力，原因可能就在这，没有把根基打好。\n数据结构与算法，清华大学的邓俊辉教授曾说过这样一句话，数据结构作为构建高效算法的必要基础，在计算机科学领域中，起到了技术体系基石的作用。而算法呢？又是面试的必考内容，在国外，甚至可以只刷算法题就能拿到大厂的 Offer，这里给大家推荐一份纯 Java 版的 LeetCode 刷题笔记，美团技术大佬写的，主力编程语言是 Java 的同学可以借鉴下，刷题的幸福指数会提高很多：刷完 300 道 LeetCode 题后，我膨胀到要飘起来了！纯正 Java 版\n计算机组成原理，这方面知识比较扎实的话，学妹再找你装机修电脑的话，可以说轻松搞定。计算机是由 CPU、内存、显示器这些设备组成的硬件，但我们大学毕业后，往往从事的是软件方面的开发工作。那怎样才能在硬件和软件之间自由穿梭呢？答案就是学好计算机组成原理。弄明白了计算机的组成原理，也就对整个软件开发有了一个系统的认知，不论是计算机的硬件原理，还是软件架构，都能很好的驾驭，随之而来的，我们的职业发展机会也就更多了。\n计算机操作系统，为什么要学习计算机操作系统？第一，面试要考，第二，无论学习哪门子编程语言，比如说 Java、C/C++，都需要和操作系统打交道，像 Java 中的多线程技术，其实是由操作系统来负责进程和线程管理的；第三，学习操作系统，还能学到内存分配方面的知识。\n计算机网络，又是一块面试经常被问到的知识点，什么 TCP 为什么三次握手？四次挥手？TCP 为什么是可靠传输协议，而 UDP 不是？键入网址到网页显示，期间发生了什么？HTTPS 握手过程是怎样的？\nJava 源码，我大学时期有一个很牛逼的同学，基本上我们遇到的问题在他那都能搞得定，我问他有什么秘诀吗？他的答案很简答，看 Java 源码啊！确实，面试的时候，像 HashMap 这种源码级别的知识点，基本上是必问项目。\n```\n\n我之前整理过一个 Java 工程师进阶之路的大纲思维导图，这里贴出来大家围观下（参考自 hollis 的成神之路）。\n\n当然了，这只是 Java 后端体系的鸟瞰图，校招的时候，不会要求上面的这些知识点全部都得掌握，像设计模式这块，通常需要大量的实战经验才能运用得恰到好处，学生阶段，往往项目经验比较缺乏，所以这部分内容在大学的时候往往没办法施展拳脚。\n\n我之前曾分享过这么一个观点，假如有那么残酷的一天，我不小心喝错了一瓶药，一下子抹掉了我这十多年的编程经验，把我变成了一只小白。我想自学 Java，并且想要找到一份工作，我预计需要 6 个月的时间，前提条件是每天都处于高效率的学习状态当中，并且每天的学习时间至少在 12 个小时以上。\n\n现在回头再评估下，发现这个观点依然是成立的。\n\n如果大学阶段，学校开设了数据结构与算法、计算机操作系统、计算机网络、C语言程序设计这些基础课程的话，其实学起来会更快一点。\n\n对于那些转专业的同学来说，如果时间比较紧迫的话，可以直接上手 Java，等到拿到了实习 Offer 后再把这些基础补一补我认为也是可以的。但这种情况下，就必须在找工作前很刷面试题和算法题了，通过强化突击弥补自己在计算机基础知识方面的短板。\n\n我认识这样一些同学，是真事，初中高中阶段就对编程很感兴趣，在兴趣的驱使下很早的就有了编程的基础。我之前就认识这么一位小妹妹，初中的时候学习成绩特别好，直接保送到北航的一所直属高中，不是搞卫星就是搞航天模型，立志以后做一名黑客。\n\n对于这些未来潜在的技术大佬，她们学什么都会特别快，因为论语里不是有一句话嘛，“知之者不如好之者，好之者不如乐之者”！\n一、Java 基础\n\n关于 Java 基础篇的学习，我这有一份 GitHub 上标星 115k 的 Java 教程：包括 Java 核心、Java 集合框架、Java 并发编程、 Java IO，非常全面，是我花了一周多时间手工整理的，非常辛苦，大家一定要珍惜。\n\n太赞了，GitHub 上标星 115k+ 的 Java 教程\n​\n你也可以选择看书，我推荐《Java 核心技术卷》，分为上下两册，上册的难度较低，可以在短时间内刷完。下册涉及到的内容有流与文件（☆）、XML、网络（☆）、数据库编程、国际化、Swing、AWT、JavaBean、安全（☆）、脚本编译和注解处理、分布式对象、本地方法（☆），没有标星的内容我认为可以略过。\n\n然后再看一看《Java 编程思想》，看自己是否能驾驭得了。因为思想的东西嘛，只有经过一些实践后才能有所感悟，否则就像王阳明一开始对着竹子格物一样，屁也格不出来，有了后面领军作战的经验，以及到地方上体验艰苦生活的感受后就开创了心学。\n\n视频的话，可以看一下浙江大学教授翁恺老师的。在浙大，每年最受关注的内容之一就是永平奖的百万大奖会花落谁家。2018 年，获得永平杰出教学贡献奖的人，就是翁恺教授。\n\n```\nhttps://www.bilibili.com/video/BV1DJ411B7cG?p=3\n​\n```\n\n翁恺教授可以说是浙大的网红教授，非常受欢迎，网络上各种风评都很不错。\n\n我来列一下 Java 基础部分要掌握的知识点吧，可以按照这个顺序来学习，每学完一部分就打卡下。\n\n初学阶段，强烈建议大家把书本上、视频上的代码都敲一遍。由于不像工作后，有大量的项目可以实践，所以不能得到及时的反馈，记笔记就显得特别的重要。另外，一定要分门别类保存好自己的 demo，以便以后可以快速得找得到，尤其是一些小套路，会很有用，积累得多了，可能就变成了自己的工具库。如果还有精力的话，可以把自己的学习心得分享出来，发表到博客上。\n\n我之前就记了蛮多笔记的。像下面这些基础到不能再基础的知识点，我都有重新去学，并且尝试用自己的方式把这些知识点表达清楚。就这样不断的分享，不断的积累，我好像才真有点清醒的感觉。\n\n什么是面向对象编程（OOP）？\n\n为什么要将局部变量的作用域最小化？\n\nJava到底是值传递还是引用传递？\n\n如何比较 Java 的字符串？\n\n再谈 Java 的继承和超类 Object\n\nJava Serializable：明明就一个空的接口嘛\n\nJava Socket：飞鸽传书的网络套接字\n\nJava 网络编程：必知必会的 URL 和 URLConnection\n\nJava面试官：兄弟，你确定double精度比float低吗？\n\n请用面向对象的思想，谈一谈这次面试的过程\n\nJava：接口和抽象类，傻傻分不清楚？\n\nJava生成二维码分享海报\n\nJava：优雅地处理异常真是一门学问啊！\n\n教妹学 Java：晦涩难懂的泛型\n\n教妹学Java：大有可为的集合\n\n教妹学 Java：难以驾驭的多线程\n\nJava 的核心目的和并发编程\n\nJava：程序不过是几行代码的集合\n\n如何理解 Java 中的继承？\n\n吃人的那些 Java 名词：对象、引用、堆、栈\n\nJava 的操作符——“=”号\n\n害死人的自动递增，不偿命的自动递减\n\nJava 流程控制语句\n\nJava是通过什么机制来确保对象初始化呢？\n\nJava 访问权限控制：public、private、protected\n\nJava代码复用的三种常用方式：继承、组合和代理\n\nJava：多态乃幸福本源\n\nJava String，看这篇就够了\n\nJava 数组，看这一篇就够了\n\nHashMap，难的不在Map，而在Hash\n\nJava枚举：小小enum，优雅而干净\n\nJava注解（Annotation）：请不要小看我！\n\nJava I/O 入门篇\n\nJava：并发不易，先学会用\n\n我给学弟学妹们提供这样一个思路。\n\n首先，我们需要一个思维导图（我一开始贴出来的那副），顺藤摸瓜，看看都有哪些知识点需要学习。\n\n然后，我们不断地细分，切入这些零散的知识点，从书中、视频中、博客中找答案，吸收。\n\n再然后，我们尝试按照自己的思考方式去分享这些知识点，不怕丢人，勇敢地做分享，力求让自己教会别人。\n\n最后，和他人进行沟通，再通过实践去检验自己的学习成果。\n\n这一套下来，不能说编程上有了突飞猛进，至少可以能突破瓶颈。\n二、Java 框架\n\n这部分也可以叫做 JavaWeb，但我更倾向于把这部分叫做 Java 框架，因为 JavaWeb 最初要学习的东西是 JSP，Servlet 这些东西，都已经被淘汰了，再去学这些知识只会浪费时间。有了大佬推荐了这部分内容，说 Spring 的那些系列框架也只是围绕这些知识点展开的，有一定的道理，但还是不太建议把时间花到这部分知识点上，要知道，技术是要更新换代的，好钢用在刀刃上。\n\n做 Web 开发，是会涉及到前端的一些知识点的，尤其是在练手阶段，不会像进公司后一个萝卜一个坑，只负责后端或者只负责前端，往往需要全栈，但想从事 Java 后端开发的话，前端这些知识点还是尽量少花时间，尽量在练手阶段找同学合伙做项目，不要把自己搞成一个全栈，前端也是很累的一个活，需要时间的。\n\n前端技术蛮多的，我举几个常见的，比如说：\n\n```\nVue，前端框架\nVue-router，路由框架\nVuex，全局状态管理框架\nAnt Design Vue，前端 UI 框架\nAxios，前端 HTTP 框架\n```\n\n这还不包括 JavaScript+HTML+CSS 在内。\n\n所以，学弟学妹们明白我的意思吗？如果一心想从事 Java 后端开发，尽量找喜欢前端的同学配合一起做练手项目，不仅能锻炼团队配合的默契，还能让自己有充分的时间学习更深度的 Java 后端技术。\n\n从事 Java 后端开发的话，自然也就离不开 Spring 的系列框架。Spring 框架早已成为 Java 后端开发事实上的行业标准，如何用好 Spring ，也就成为 Java 程序员的必修课之一。同时，Spring Boot 和 Spring Cloud 的出现，可以帮助 Java 程序员更好地基于 Spring 框架及各种基础设施来快速搭建系统，可以说，它们的诞生又一次解放了Java 程序员的生产力。\n\n所以，Spring Boot 和 Spring Cloud 已成为 Spring 生态中不可或缺的一环。想成为一名合格的 Java 后端工程师，Spring Framework、Spring Boot、Spring Cloud 这三者必须牢牢掌握。\n\n首先来学 SSM（Spring+SpringMVC+MyBatis，企业级应用的必须品）的整合教程，哪怕是已经有了 Spring Boot，SSM 仍然是必学的，能打下更坚实的基础。\n\n其中 Spring 是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。它可以装载 Bean（也就是 Java 中的类，包括 Service、Dao 里面的），有了控制反转这个机制，我们就不用在每次使用类的时候先初始化，用 new 关键字声明。另外，Spring 的 AOP、事务管理等等都是我们经常用到的。\n\nSpringMVC 分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。\n\nMyBatis 是一个支持普通 SQL 查询，存储过程和高级映射的优秀持久层框架。MyBatis 对 JDBC 做了封装，它让数据库底层操作变的透明。 MyBatis 的操作都是围绕一个叫 sqlSessionFactory 的实例展开的，通过配置文件关联到各实体类的 Mapper 文件，Mapper 文件中配置了每个类对数据库所需进行的 SQL 语句映射。在每次与数据库交互时，通过 sqlSessionFactory 拿到 sqlSession，再执行 SQL 命令。\n\n怎么学习这部分内容呢？我不太建议看书，因为这方面的书籍在豆瓣上的评分都不怎么高。\n\n```\nSSM 实战 100 集：https://www.bilibili.com/video/BV1NX4y1G7wx\nSpring5框架最新版教程：https://www.bilibili.com/video/BV1Vf4y127N5\n2021 最新版 SpringMVC 视频教程：https://www.bilibili.com/video/BV1qp4y1n7D1\n2021 最新版 MyBatis 视频教程：https://www.bilibili.com/video/BV1c54y1a7GE\n```\n\n然后是 Spring Boot。Spring Boot 是由 Pivotal 团队提供的一个全新框架，其设计目的是用来简化 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。说句人话就是，Spring Boot 不是什么新的框架，它默认配置了很多框架的使用方式，就像 Maven 整合了所有的 Jar 包，Spring Boot 整合了所有的框架。使用 Spring Boot有什么好处其实就是简单、快速、方便！我推荐看纯洁的微笑的博客，访问量在千万级别以上，影响了无数的初学者，我个人强烈推荐。\n\nspring-boot - 纯洁的微笑博客\n\n如果说已经掌握了 Spring、SpringMVC、MyBatis、Spring Boot 等内容，就有能力进行一些真正有用的应用项目开发了，可以拿下面这些项目作为练手，都是 GitHub 上一些星标超级多的优质项目，对增加项目经验有很大帮助。\n\n1）电商秒杀\n\nSpringBoot 完整电商系统 Mall：包括前台商城系统及后台管理系统，基于 SpringBoot+MyBatis 实现。\n\n一套微服务商城系统 mall-swarm：采用了 Spring Cloud Greenwich、Spring Boot 2、MyBatis、Docker、Elasticsearch 等核心技术，同时提供了基于 Vue 的管理后台。\n\nmiaosha：秒杀系统设计与实现。\n\n2）博客论坛\n\nvhr：微人事是一个前后端分离的人力资源管理系统，项目采用 SpringBoot+Vue 开发。\n\nhalo（[ˈheɪloʊ]，意为光环，也可以当成拼音读(哈喽)）：一个优秀的开源博客发布应用。\n\n对于在校生来说，缺的就是实战经验，我推荐的这些练手项目可以很好的弥补这块短板，挑一个拿出来练就足够了哈，不需要全部都练。\n三、Java 虚拟机和 Java 源码\n\n先说 Java 虚拟机。\n\nJava 虚拟机（JVM）是相对难吃透的一个环节，但却十分的重要，JVM 屏蔽了与具体操作系统平台相关的信息，使得 Java 程序只需要生成在 Java 虚拟机上能运行的目标代码，也就是字节码，就可以实现跨平台的诉求了。JVM 学得通透的话，可以说是非常牛逼的程序员了。\n\n给大家推荐一个 B 站上的视频，分为《内存与垃圾回收篇》《字节码与类的加载篇》《性能监控与调优篇》三个篇章。\n\n```\nhttps://www.bilibili.com/video/av83622425\n```\n\n然后再推荐一本书《深入理解 Java 虚拟机》，周志明老师的。第三版在豆瓣上的评分直接来到了 9.5 分，可以说是强得一笔！这是一部从工作原理和工程实践两个维度深入剖析 JVM 的著作，是计算机领域公认的经典。\n\n```\n第一部分（第1章），主要讲 Java 虚拟机的历史\n第二部分（第2~5章），详细讲解了 Java 的内存区域划分和垃圾收集器\n第三部分（第6~9章），深入分析了class 文件结构、虚拟机的类加载机制\n第四部分（第10~11章），程序编译和代码优化\n第五部分（第12~13章），主要讲解了 Java 实现高并发的原理，包括线程与协程、锁优化等等。\n```\n\n总之一点，Java 虚拟机是成神之路上的巅峰之战！\n\n再来说说 Java 源码。\n\n面试的时候，面试官都特别喜欢问一些源码方面的知识，比如说 HashMap 的一些经典问题，加载因子为什么是 0.75？哈希冲突的时候，HashMap 是如何查找并确认元素的等等，这些问题只有通过源码才能得出比较准确的回答，对吧？\n\n给大家推荐 B 站上一个视频，详细地介绍了如何阅读 Java 源码。\n\n```\nhttps://www.bilibili.com/video/BV1V7411U78L\n```\n\n这里说一下 Java 源码阅读的顺序：\n\n```\nlang\nutil\nio\nnio\nmath\ntime\nnet\n```\n\n其中的重点：\n\n```\nString\nInteger\nArrayList\nLinkedList\nCopyOnWriteArrayList\nHashMap\nTreeMap\nLinkedHashMap\nConcurrentHashMap\nCopyOnWriteArrayList\n```\n\n四、数据库\n\n学习一门编程语言，如果不去操作下数据，就感觉这门编程语言空有皮囊却没有灵魂，对吧？所以数据库部分是必学的。\n\n先说书。\n\n《SQL 必知必会》是麻省理工学院、伊利诺伊大学等众多大学的参考教材，这本书直接从 SQL 的 SELECT 开始，讲述了实际工作环境中最常用和最必需的 SQL 知识，实用性极强。该书作者后来还出了一本《MySQL 必知必会》，同样很薄的一本书，也可以看一看。\n\n《高性能 MySQL》，业界公认的一本经典的 MySQL 读物了，有着广泛的影响力。\n\n目前大多数公司的存储都是 MySQL + Redis，MySQL 作为主要的存储方式，Redis 作为缓存，用来加快热点数据的读写速度，从而提高性能。所以学完 MySQL，可以趁热打铁学一下 Redis。\n\n```\n《Redis 深入历险核心原理与应用实战》分为基础和应用篇、原理篇、集群篇、拓展篇、源码篇共 5\n大块内容。基础和应用篇讲解对读者来说最有价值的内容，可以直接应用到实际工作中；原理篇、集群篇让开发者透过简单的技术表面看到精致的底层世界；拓展篇帮助读者拓展技术视野和夯实基础，便于进阶学习；源码篇让高阶的读者能够读懂源码，掌握核心技术实力。\n```\n\nRedis 的重要性不言而喻了，是互联网技术架构在存储系统中最为广泛的中间件，也是后端面试中最经常被问到的模块之一。\n\n《MongoDB 权威指南》是一本广受好评的 MongoDB 权威著作，作者是谷歌的一名软件工程师，曾有 5 年是 MongoDB 项目的核心成员。\n\n再来说说推荐的视频。\n\nSQL 推荐 B 站上一个老外的课，英文中字版的，内容制作得非常棒，所以完全不用担心听不懂。10 个小时就能看完。\n\n```\nhttps://www.bilibili.com/video/BV1UE41147KC\n```\n\nMySQL 的推荐 B 站上的一个女老师的，讲得很精彩，弹幕也很精彩。\n\n```\nhttps://www.bilibili.com/video/BV12b411K7Zu\n```\n\nRedis 的也推荐一个：\n\n```\nhttps://www.bilibili.com/video/BV1S54y1R7SB\n```\n\nRedis 是面试中经常考的一块知识点，像下面这些经常被问，参考自老钱的文章：\n\n```\nRedis 有哪些数据结构？\n使用过Redis分布式锁么，它是什么回事？\n假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？\n使用过Redis做异步队列么，你是怎么用的？\n如果有大量的key需要设置同一时间过期，一般需要注意什么？\nRedis如何做持久化的？\nPipeline有什么好处，为什么要用pipeline？\nRedis的同步机制了解么？\n是否使用过Redis集群，集群的原理是什么？\n```\n\n五、计算机组成原理\n\n众所周知，计算机是由 CPU、内存、显示器这些设备组成的硬件，但我们大学毕业后，往往从事的是软件方面的开发工作。那怎样才能在硬件和软件之间自由穿梭呢？答案就是学好计算机组成原理。弄明白了计算机的组成原理，也就对整个软件开发有了一个系统的认知，不论是计算机的硬件原理，还是软件架构，都能很好的驾驭，随之而来的，我们的职业发展机会也就更多了。\n\n计算机组成原理这门课完全可以用一个词来概括，就是“抽象”。在我看来这也是整个计算机设计中所蕴含的的灵魂。《计算机是怎样跑起来的》，很适合作为一本了解计算机的入门书。在外人看来，计算机很复杂，对内行人来说，计算机说起来很简单：\n\n```\n输入、运算、输出是硬件的基础\n软件是数据和指令的集合\n计算机和人的思考方式不同，对计算机来说，什么都是数字\n```\n\n既然聊到计算机，很有必要给大家推荐 B 站上的一门计算机科学速成课，讲解的内容有：\n\n计算机早期历史\n电子计算机\n布尔逻辑\n二进制\n算术逻辑单元\n寄存器 & 内存\n中央处理器\n指令和程序\n高级 CPU 设计\n早期的编程方式\n编程语言发展史\n编程原理\n算法入门\n数据结构\n阿兰图灵（我最喜欢的一集）\n软件工程\n集成电路 & 摩尔定律\n操作系统\n内存 & 储存介质\n文件系统\n压缩\n命令行界面\n屏幕 & 2D 图形显示\n个人计算机革命\n图形用户界面\n3D 图形\n计算机网络\n互联网\n万维网\n计算机安全\n黑客 & 攻击\n加密\n机器学习 & 人工智能\n计算机视觉\n自然语言处理\n机器人\n计算机心理学\n天网 & 计算机的未来\n\n非常值得每个程序员去刷一刷的，全部都是计算机专业需要掌握的知识点啊，至少是应该了解的知识点。关键是视频的画面特别精良，我来截幅图给大家感受下。\n\n关键是英文中字版的，观看起来毫无压力。我自己每天会刷一集。像二进制这一集，以前经常被二进制搞得晕头转向，刷了这集视频后，明显感觉对二进制没那么生疏了，仿佛一个陌生人坐在对面，喝了一杯酒后，就成了老熟人。\n\n```\nhttps://www.bilibili.com/video/av21376839\n```\n\n我看弹幕有人说，“第一次用 B 站看这么正经的东西。”好他喵的真实呀！我也是。\n\n最后再推荐一本书，《编码-印尼在计算机软硬件背后的语言》，这本书讲述的是计算机背后的工作原理。\n\n```\n你是否想知道计算机如何工作和运行的？\n你是否想了解计算机是如何一步一步创造出来的？\n你是否想了解计算机知识的来龙去脉？\n你是否想了解计算机的历史？\n你是否想制造出一台自己的计算机？\n你是否想知道硬件与软件的区别？\n你是否想知道电报机、电的原理？\n你是否想创造自己的编程语言？\n你是否想知道你买的电脑中说明书上说的主频、内存、显示器象素、显存的概念和意义？\n你是否想知道我们常用的十进制的由来？\n你是否一直迷惑于二进制的理解？\n你是否想知道那些赫赫有名的IT公司的历史和发展？\n你是否想探询那些天才是如何思考和发明的？\n你是否想象科学家一样思考？\n\n这一连串问答摘自豆瓣书评\n```\n\n这本书将一一为你揭开谜底。本书的内容涉及数理逻辑、布尔代数、组合数学、集合、物理、化学和电子学等等知识。\n六、计算机网络\n\n当今这个时代，没有网络简直无法生存，哪怕是在电梯里的一分钟，我都受不了那种手机没有网络的状态。我们所学的编程知识，如果脱离了网络，将变得毫无意义，因为没有哪个编程语言是要在单机环境下运行的。\n\n计算机网络课怎么学习，给大家推荐四本书，一门公开课。\n\n《网络是怎样连接的》，这本书从在浏览器中输入网址开始，一路追踪到显示出网页内容为止的整个过程，以图配文，讲解了网络的全貌，并重点介绍了网络设备和软件是如何工作的。\n在这里插入图片描述\n\n《TCP/IP 详解》，这是一本完整而详细的 TCP/IP 协议指南，基本上做通信的是人手一本。对于大多数程序员来说，了解这个 TCP/IP 对面试和编程也有很大的帮助。\n\n在这里插入图片描述\n\n《图解 HTTP》，HTTP协议是互联网的基石，学完后可以尝试实现一个属于自己的 HTTP 服务器了。\n在这里插入图片描述\n\n《计算机网络-自顶向下方法》，算是一本经典的大学教材了，\n在这里插入图片描述\n\n关于计算机网络这块，可以配合 B 站上的《计算机网络微课堂》一起来学习。\n\n```\nhttps://www.bilibili.com/video/BV1c4411d7jb\n```\n\n这门课主要介绍了计算机网络的基本概念和基本原理，从下到上依次讲解物理层、数据链路层、网络层、运输层和应用层，以因特网和网络技术为实例，深入讲解和分析了计算机网络的基本原理、方法和技术精髓。这门课程学完后，你将：\n\n```\n轻松学懂计算机网络，掌握相关的理论基础。\n对于要参加 408 考研的同学，可以从容应考。\n如果将来要从事计算机网络相关的科研，也能打下坚实的基础。\n```\n\n七、计算机操作系统\n\n为什么要学习操作系统呢？\n\n第一，面试要考；\n\n第二，无论学习哪门子编程语言，比如说 Java、C/C++，都需要和操作系统打交道，像 Java 中的多线程技术，其实是由操作系统来负责进程和线程管理的；\n\n第三，学习操作系统，还能学到内存分配方面的知识。\n\n同样推荐两本书，《深入理解计算机系统》和《鸟哥的Linux私房菜 基础学习》。\n\n《深入理解计算机系统》，按理说，这本书的名字应该叫《计算机系统导论》，有 C语言、数据结构的知识就可以学这本书了，想在毕业后去大厂的学弟学妹值得花时间去三刷一下这本书，注意是三刷，第一刷大致了解，第二刷精度，第三刷温习。可以说得上是程序员了解计算机系统的最佳书籍了，可以去 CSAPP 课程官网找 Lab 配合刷起来。\n\n《鸟哥的Linux私房菜 基础学习》，这是一本 Linux 方面的畅销书了，全面详细地介绍了 Linux 操作系统，如果要学习 Linux 的话，首选。\n\n八、数据结构与算法\n\n无论什么时候，程序=数据结构+算法这种说法都是成立的。\n\n常用的数据结构有：\n\n```\n栈：栈是一种非常有用的数据结构，它就像一摞盘子，第一个放在最下面，第二个放在第一个上面，第三个放在第二个上面，最后一个放在最上面。栈遵循后进先出的原则，也就是“Last In First Out”（简称 LIFO）——最后的一个进的，最先出去。\n队列：只允许在队尾添加数据，队首移除数据。队列在 Java 中的出现频率非常高，有各种不同的类来满足不同的场景需求。像优先级队列 PriorityQueue、延时队列 DelayQueue 等等。队列遵循的是First In First Out，缩写为FIFO，也就是先进先出，第一个进入队列的第一个先出来。\n数组：数组这种数据结构最大的好处，就是可以根据下标（或者叫索引）进行操作，插入的时候可以根据下标直接插入到具体的位置，但与此同时，后面的元素就需要全部向后移动，需要移动的数据越多，就越累。\n链表：链表在物理存储空间是不连续的，但每个节点要么知道它的下一个节点是谁，要么知道它的上一个节点是谁，仿佛就像我们之间隔着千山万水，却心有灵犀一点链。像 LinkedList 就是最典型的链表结构，通过引用相互链接。\n树：树是一种典型的非线性结构，它是由 n（n>0）个有限节点组成的一个具有层次关系的集合。之所以叫“树”，是因为这种数据结构看起来就像是一个倒挂的树，只不过根在上，叶在下。\n哈希表：也叫散列表，是一种可以通过关键码值（key-value）直接访问的数据结构，它最大的特点就是可以快速实现查找、插入和删除。\n图：图是一种复杂的非线性结构，由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V，E），其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。\n```\n\n常用的算法有：\n\n```\n查找\n插入\n删除\n更新\n排序\n```\n\n算法研究的目的是为了更有效的处理数据，提高数据运算的效率，数据运算是定义在数据结构上的，各大公司的笔试基本都考这个，《剑指 Offer》上的所有题目如果能背下来，LeetCode 上的题如果能刷个一百到三百道，ACM 竞赛如果能拿到一些奖项。在找工作的时候会非常有优势，基本上大厂小厂的 offer 可能会拿到手软。\n\n刷完 300 道 LeetCode 题后，我强到可以和面试官硬刚！纯正 Java 版\n\n视频的话，推荐 B 站上的一个，韩顺平老师的。\n\n```\nhttps://www.bilibili.com/video/av54029771\n```\n\n评论区有同学给出了数据结构与算法在面试中经常考的知识点，和视频是关联的：\n\n```\nP16~P23 单链表\nP24~P26 双向链表\nP27~P29 约瑟夫环\nP30~P35 栈·栈实现计算器\nP36~P42 前缀，中缀，后缀表达式，逆波兰计算器的实现\nP43~P49 递归，迷宫回溯，八皇后\nP50~P53 排序算法基础\n54~56 冒泡排序\n57~59 选择排序\n60~62 插入排序\n63~65 希尔排序\n66~68 快速排序\n69~71 归并排序\n72~75 基数排序\n76 各种排序的比较\n127~131 二叉排序树\n132~134 BST删除一棵子树的节点\n135 二叉平衡树\n146~151 图，图的深度优先和广度优先\n156~159 动态规划\n160~163 暴力匹配和KMP算法\n164~ 167 贪心算法\n```\n\n顺带说一下，我上面总结的这套体系是非常完备的，可以说拿到任何地方都是有公信力的，几乎完美到无可挑剔（自信有点上头）。\n\n如果你很幸运的，从大一就看到了这个学习路线，那么恭喜你，实习 Offer 可以说是手到擒来了！如果稍微有那么一点不走运，看到的比较晚，那么一句很鸡贼的话送给你，“种一棵树最好的时间要么是十年前，要么是现在。”\n\n', '1413706512109260801', '2', '12', '2021-12-13 12:48:43', null, '2021-12-13');
INSERT INTO `bms_post` VALUES ('1413722409557352450', 'C++ map用法总结（整理）', '1，map简介\n\nmap是STL的一个关联容器，它提供一对一的hash。\n\n```\n第一个可以称为关键字(key)，每个关键字只能在map中出现一次；\n第二个可能称为该关键字的值(value)；\n```\n\nmap以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。Map主要用于资料一对一映射(one-to-one)的情況，map內部的实现自建一颗红黑树，这颗树具有对数据自动排序的功能。在map内部所有的数据都是有序的，后边我们会见识到有序的好处。比如一个班级中，每个学生的学号跟他的姓名就存在著一对一映射的关系。\n\n2，map的功能\n\n自动建立key － value的对应。key 和 value可以是任意你需要的类型，包括自定义类型。\n\n3，使用map\n\n使用map得包含map类所在的头文件\n\n#include <map>  //注意，STL头文件没有扩展名.h\n\nmap对象是模板类，需要关键字和存储对象两个模板参数：\n\nstd:map<int, string> personnel;\n\n这样就定义了一个用int作为索引,并拥有相关联的指向string的指针.\n\n为了使用方便，可以对模板类进行一下类型定义，\n\ntypedef map<int,CString> UDT_MAP_INT_CSTRING;\n\nUDT_MAP_INT_CSTRING enumMap;\n\n4，map的构造函数\n\nmap共提供了6个构造函数，这块涉及到内存分配器这些东西，略过不表，在下面我们将接触到一些map的构造方法，这里要说下的就是，我们通常用如下方法构造一个map：\n\nmap<int, string> mapStudent;\n\n5，插入元素\n\n```\n// 定义一个map对象\nmap<int, string> mapStudent;\n \n// 第一种 用insert函數插入pair\nmapStudent.insert(pair<int, string>(000, \"student_zero\"));\n \n// 第二种 用insert函数插入value_type数据\nmapStudent.insert(map<int, string>::value_type(001, \"student_one\"));\n \n// 第三种 用\"array\"方式插入\nmapStudent[123] = \"student_first\";\nmapStudent[456] = \"student_second\";\n```\n\n以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是不能在插入数据的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值，用程序说明如下：\n\n```\nmapStudent.insert(map<int, string>::value_type (001, \"student_one\"));\n \nmapStudent.insert(map<int, string>::value_type (001, \"student_two\"));\n```\n\n上面这两条语句执行后，map中001这个关键字对应的值是“student_one”，第二条语句并没有生效，那么这就涉及到我们怎么知道insert语句是否插入成功的问题了，可以用pair来获得是否插入成功，程序如下\n\n```\n// 构造定义，返回一个pair对象\npair<iterator,bool> insert (const value_type& val);\n \npair<map<int, string>::iterator, bool> Insert_Pair;\n \nInsert_Pair = mapStudent.insert(map<int, string>::value_type (001, \"student_one\"));\n \nif(!Insert_Pair.second)\n    cout << \"\"Error insert new element\" << endl;\n```\n\n我们通过pair的第二个变量来知道是否插入成功，它的第一个变量返回的是一个map的迭代器，如果插入成功的话Insert_Pair.second应该是true的，否则为false。\n\n6， 查找元素\n\n当所查找的关键key出现时，它返回数据所在对象的位置，如果沒有，返回iter与end函数的值相同。\n\n```\n// find 返回迭代器指向当前查找元素的位置否则返回map::end()位置\niter = mapStudent.find(\"123\");\n \nif(iter != mapStudent.end())\n       cout<<\"Find, the value is\"<<iter->second<<endl;\nelse\n   cout<<\"Do not Find\"<<endl;\n```\n\n7， 刪除与清空元素\n\n```\n//迭代器刪除\niter = mapStudent.find(\"123\");\nmapStudent.erase(iter);\n \n//用关键字刪除\nint n = mapStudent.erase(\"123\"); //如果刪除了會返回1，否則返回0\n \n//用迭代器范围刪除 : 把整个map清空\nmapStudent.erase(mapStudent.begin(), mapStudent.end());\n//等同于mapStudent.clear()\n```\n\n8，map的大小\n\n在往map里面插入了数据，我们怎么知道当前已经插入了多少数据呢，可以用size函数，用法如下：\n\nint nSize = mapStudent.size();\n\n9，map的基本操作函数：\n\n```\nC++ maps是一种关联式容器，包含“关键字/值”对\n\n begin()         返回指向map头部的迭代器\n\n clear(）        删除所有元素\n\n count()         返回指定元素出现的次数, (帮助评论区理解： 因为key值不会重复，所以只能是1 or 0)\n\n empty()         如果map为空则返回true\n\n end()           返回指向map末尾的迭代器\n\n equal_range()   返回特殊条目的迭代器对\n\n erase()         删除一个元素\n\n find()          查找一个元素\n\n get_allocator() 返回map的配置器\n\n insert()        插入元素\n\n key_comp()      返回比较元素key的函数\n\n lower_bound()   返回键值>=给定元素的第一个位置\n\n max_size()      返回可以容纳的最大元素个数\n\n rbegin()        返回一个指向map尾部的逆向迭代器\n\n rend()          返回一个指向map头部的逆向迭代器\n\n size()          返回map中元素的个数\n\n swap()           交换两个map\n\n upper_bound()    返回键值>给定元素的第一个位置\n\n value_comp()     返回比较元素value的函数\n```\n\n\n', '1413706236086308865', '2', '16', '2021-12-13 12:51:02', null, '2021-12-13');
INSERT INTO `bms_post` VALUES ('1413727184311095298', 'springboot和springmvc的区别', '面试题：你知道springboot和springmvc的区别是什么？\n\n```\n之前自己搭过springboot的相关项目，但是如何进行比较，从自我感觉来看就是使用springboot用起来几乎没有配置，个人搭的项目没有用到配置相关的内容。于是我就用了这个回答给面试官，可想而知，这种回答并不好。于是现在百度了相关文章，就把理解写成博客当做笔记。\n\n    springmvc从两个方面来看，一是spring,spring的核心中IOC和AOP,IOC就是控制反转(就是将原本由程序代码直接操作的对象的调用权交给容器)，目的是为了减低计算机代码的耦合度，所谓的耦合度就是代码中的逻辑关系不要太紧密，避免后面改的人会因为不懂业务逻辑导致改错代码；除此之外也避免我们每次创建新的对象，减少对应的代码量。我们实际代码过程中最常见的方式是依赖注入（DI Dependency Injection）,所谓依赖注入就是通过构造注入或者set进行注入。依赖查找（DL Dependency Lookup)这是通过名称和类型查找bean。AOP是面向切面编程，AOP分为五大部分：（1）Aspect(切面):通常是一个类，里面可以定义切入点和通知。（2）JointPoint（连接点）：程序执行中明确的点，一般是方法的调用。(3)Advice(通知）：AOP在特定的切入点上做出的增强处理，有before,after,afterRunning,afterThrowing,around;（4）Pointcut(切入点）：就是带有通知的连接点，在程序中主要体现为书写切入点表达式；(5)AOP代理：AOP框架创建的对象，代理就是目标对象的加强，Spring的AOP可以使用JDK代理，也可以使用CGLIB代理，前者基于接口，后者是基于子类。\n```\n\n通知类型：\n\n(1)Before:在目标方法被调用之前做增强处理,@Before只需要指定切入点表达式即可\n\n(2)AfterReturning:在目标方法正常完成后做增强,@AfterReturning除了指定切入点表达式后，还可以指定一个返回值形参名returning,代表目标方法的返回值\n\n(3)AfterThrowing:主要用来处理程序中未处理的异常,@AfterThrowing除了指定切入点表达式后，还可以指定一个throwing的返回值形参名,可以通过该形参名\n\n来访问目标方法中所抛出的异常对象\n\n(4)After:在目标方法完成之后做增强，无论目标方法时候成功完成。@After可以指定一个切入点表达式\n\n(5)Around:环绕通知,在目标方法完成前后做增强处理,环绕通知是最重要的通知类型,像事务,日志等都是环绕通知,注意编程中核心是一个ProceedingJoinPoint\n\n```\nspringboot引入自动配置的概念，让项目配置变得更容易，Spring Boot本身并不提供Spring框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于Spring框架的应用程序。也就是说，它并不是用来替代Spring的解决方案，而是和Spring框架紧密结合用于提升Spring开发者体验的工具。同时它集成了大量常用的第三方库配置(例如Jackson, JDBC, Mongo, Redis, Mail等等)，Spring Boot应用中这些第三方库几乎可以零配置的开箱即用(out-of-the-box)，大部分的SpringBoot应用都只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。Spring Boot只是承载者，辅助开发者简化项目搭建过程的。如果承载的是WEB项目，使用Spring MVC作为MVC框架，那么工作流程和SpringMVC的是完全一样的，因为这部分工作是Spring MVC做的而不是Spring Boot。\n\n    springmvc与springboot的联系和区别：\n\n    联系：\n\n     Spring最初利用工厂模式（DI)和代理模式解耦应用组件，为了解耦开发了springmvc；而实际开发过程中，经常会使用到注解，程序的样板很多，于是开发了starter，这套就是springboot。\n\n    区别：\n\n   1.springboot是约定大于配置，可以简化spring的配置流程；springmvc是基于servlet的mvc框架，个人感觉少了model中的映射。\n\n   2.以前web应用要使用到tomat服务器启动，而springboot内置服务器容器，通过@SpringBootApplication中注解类中main函数启动即可。例如：\n\npackage com.bjsxt;\n \nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.web.servlet.ServletComponentScan;\n \n/**\n * springBoot整合Listener方式一\n *\n *\n */\n@SpringBootApplication\n@ServletComponentScan\npublic class App {\n \n	public static void main(String[] args) {\n		SpringApplication.run(App.class, args);\n	}\n \n}\n```\n\n\n', '1413706236086308865', '4', '15', '2021-12-13 13:10:01', null, '2021-12-13');
INSERT INTO `bms_post` VALUES ('1413855800340578305', ' Vue基础', '一、渐进式框架\n二、两个核心点\n\n```\n响应的数据绑定\n当数据发生改变时，自动更新视图。\n是利用Object.defineProperty中的getter和setter代理数据。\n```\n\nvar obj = {};\nObject.defineProperty(obj,\"a\",{\nvalue:10,  //obj.a值为10\nwritable:false,   //表示不可写\nenumerable:false,   //表示不可遍历\nconfigurable:false,  // 表示不可配置，即不能改变writable:false或者enumerable:false\nget(){               //   当读取obj.a时会自动调用该函数，不管是什么都返回1000\nreturn 1000;\n},\nset(){         //   当写入obj.a时会自动调用该函数，不管写什么都写入2000\nreturn 2000;\n}\n});\n\n```\nvar obj = {};\nObject.defineProperty(obj,\"a\",{\n	value:10,  //obj.a值为10\n	writable:false,   //表示不可写\n	enumerable:false,   //表示不可遍历\n	configurable:false,  // 表示不可配置，即不能改变writable:false或者enumerable:false\n	get(){               //   当读取obj.a时会自动调用该函数，不管是什么都返回1000\n		return 1000;\n	},\n	set(){         //   当写入obj.a时会自动调用该函数，不管写什么都写入2000\n		return 2000;\n	}\n});\n\n```\n\nVue监控的数据变化就是监控的getter和setter得变化。变化就去重新渲染。\n2. 视图组件\nUI页面映射出一个组件树\n组件可重用，可维护性好。\n视图与组件的映射\n三、虚拟DOM\n\n要改变一个DOM节点，才能把视图重新渲染出来。但这样会发生重排重绘，十分耗费性能。\n虚拟DOM就是使用js去模拟一个节点。把js封装出来，变为一个真实的DOM。（使用js对象的嵌套形式模仿出一个html文档），通过底层的算法可以让重排重绘只发生在局部。优化页面。\n虚拟DOM工作流程\n虚拟DOM\n\n//  模仿实现\nfunction VElement(tagName,prop,children){  //参数为( \"\",{},[] )\n// 判断是不是一个VElement的一个实例\nif ( !(this instanceof VElement) ) {\nreturn new VElement(tagName,prop,children);\n}\n//  假如用户没有属性prop，就没有给参数prop，进行兼容性处理\nif( Object.prototype.toString.call(prop) === \"[object Array]\" ){\nchildren = prop;\nprop = {};\n}\nthis.tagName = tagName;\nthis.prop = prop;\nthis.children = children;\nvar count = 0;  //  用于记录虚拟节点个数\nthis.children.forEach(function(child,index){\nif(child instanceof VElement){\n// 如果子节点是一个虚拟节点，让总节点数加上子节点的子子节点数\ncount += child.count;\n}\ncount ++;\n});\nthis.count = count;\n}\nvar dom = VElement(\"div\",[VElement(\"div\",[\"Vue牛逼\"])]);\nconsole.log(dom);\n// 结果  虚拟DOM   相当于：<div><div>Vue牛逼</div></div>\n// VElement {\n//   tagName: \'div\',\n//   prop: {},\n//   children: [ VElement { tagName: \'div\', prop: {}, children: [Object], count: 1 } ],\n//   count: 2 }\nVElement.prototype.render = function(){\n//rander函数将虚拟DOM转换为真实DOM\nvar dom = document.createElement(this.tagName);\nvar children = this.children;\nvar prop = this.prop;\nfor(var item in prop){\ndom.setAttribute(item,prop[item]);\n}\nchildren.forEach( function(child,index){\nif(child instanceof VElement){\nvar childDom = child.render();\n}else{\nvar childDom = document.createTextNode(child);\n}\ndom.appendChild(childDom);\n} );\nreturn dom;\n};\nconsole.log(dom.render());\n//  结果\n// <div>\n//  	<div>Vue牛逼</div>\n// </div>\n\n```\n//  模仿实现\nfunction VElement(tagName,prop,children){  //参数为( \"\",{},[] ) \n	// 判断是不是一个VElement的一个实例\n	if ( !(this instanceof VElement) ) {\n		return new VElement(tagName,prop,children);\n	}\n	//  假如用户没有属性prop，就没有给参数prop，进行兼容性处理\n	if( Object.prototype.toString.call(prop) === \"[object Array]\" ){\n		children = prop;\n		prop = {};\n	}\n	this.tagName = tagName;\n	this.prop = prop;\n	this.children = children;\n	var count = 0;  //  用于记录虚拟节点个数\n	this.children.forEach(function(child,index){\n		if(child instanceof VElement){\n			// 如果子节点是一个虚拟节点，让总节点数加上子节点的子子节点数\n			count += child.count;\n		}\n		count ++;\n	});\n	this.count = count;\n}\nvar dom = VElement(\"div\",[VElement(\"div\",[\"Vue牛逼\"])]);\nconsole.log(dom);\n// 结果  虚拟DOM   相当于：<div><div>Vue牛逼</div></div>\n// VElement {\n//   tagName: \'div\',\n//   prop: {},\n//   children: [ VElement { tagName: \'div\', prop: {}, children: [Object], count: 1 } ],\n//   count: 2 }\nVElement.prototype.render = function(){\n	//rander函数将虚拟DOM转换为真实DOM\n	var dom = document.createElement(this.tagName);\n	var children = this.children;\n	var prop = this.prop;\n	for(var item in prop){\n		dom.setAttribute(item,prop[item]);\n	}\n	children.forEach( function(child,index){\n		if(child instanceof VElement){\n			var childDom = child.render();\n		}else{\n			var childDom = document.createTextNode(child);\n		}\n		dom.appendChild(childDom);\n	} );\n	return dom;\n};\nconsole.log(dom.render());\n//  结果\n// <div>\n//  	<div>Vue牛逼</div>\n// </div>\n\n\n```\n\nVue底层时使用深度遍历优先算法转化为dom节点的\n四、MVVM模式\n\nM：model 数据模型\nV：视图模板\nVM：视图模型\nVM层是中间层，连接数据模型和视图模板，由Vue实现。由vm代替以前的dom操作，只操作vm层\n五、Vue实例\n\n```\n数据绑定\n计算属性与侦听器\n属性绑定\n条件渲染 v-if v-show\n列表渲染 v-for\n绑定事件 事件修饰符 表单\n```\n\n<!DOCTYPE html>\n\n<html>\n<head>\n	<title>Vue</title>\n</head>\n<body>\n\n```\n<div id=\"demo\">\n	{{name}}   <!-- 数据绑定 -->\n	{{changeName}}     <!-- 绑定计算属性的changeName -->\n	<!-- 通过v-bind:命令绑定属性名 -->\n	<!-- 其中class和style比较特殊，要使用数组形式：v-bind:class=\"[class1]\" -->\n	<!-- 也可以通过对象的形式：v-bind:class=\"{class1:classBoolean}\",其中class1是class名，而classBoolean才是绑定的变量，为true时才将class1绑定上  （实现添加或删除class） -->\n	<span v-bind:data=\"message\" v-bind:id=\"id\">{{name}}</span>\n	<!-- v-show 控制节点显示或隐藏,ifshow是绑定的数据，为true时显示，false时内部设为display:none -->\n	<!-- v-if也是控制节点显示隐藏，但v-if为false时，是删除节点 -->\n	<!-- 频繁切换时，考虑重拍重绘，v-if会更浪费性能 -->\n	<div v-show=\'ifshow\'>条件渲染演示</div>\n	<!-- items是一个数组，会被v-for遍历，item就是遍历的结果 -->\n	<span v-for=\"item in items\">{{item.title}}</span>\n	<!-- v-on绑定事件，click为事件名，click1为回调函数，写在methods内 -->\n	<button v-on:click=\"click1\">点击</button>\n	<!-- 事件修饰符，在事件的回调函数后添加一个.enter，代表只有按下回车键才会触发该事件 -->\n	<input type=\"text\" name=\"\" v-on:keyup.enter=\"keyup1\">\n	表单，初始化时，会将value的值默认填入input框\n	<input type=\"text\" name=\"\" v-model=\"value\">\n\n</div>		\n\n<script type=\"text/javascript\" src=\"https://vuejs.org/js/vue.js\"></script>\n<script type=\"text/javascript\">\n	//在vue当中，需要一个dom节点挂载Vue,并且vue语法只在此节点内生效\n	var vm = new Vue({\n		el: \"#demo\",   // el对应dom节点的id,就把Vue挂载在了dom节点上了\n		data:{   // 数据绑定   所有数据都会绑定到实例vm上\n			name:\"tanjw\",\n			message : 123,\n			id:\"demo1\",\n			ifshow:false,\n			items:[{\n				title:\"18\"\n			},{\n				title:\"20\"\n			}],\n			value:123\n		},\n		//  当name变化时，就会在computed内找一些相关属性\n		computed:{  //   计算属性，内部写一些函数\n			changeName: function(){  //  当通过控制台改变vm实例name时，changName也会随着变化，监控name的变化\n				return \"my name is \" + this.name;\n			}\n		},\n		methods:{\n		// 专门处理异步回调函数\n			click1:function(){\n				console.log(this);\n			},\n			keyup1:function(){\n				console.log(this.value);\n	})\n</script>\n```\n\n</body>\n</html>\n六、模板\n\n```\nhtml模板\n字符串模板\nrender函数\n```\n\n<!DOCTYPE html>\n\n<html>\n<head>\n	<title></title>\n</head>\n<body>\n\n```\n<div id=\"demo\">\n	{{message}}\n	<!-- 双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，需要使用 v-html 指令： -->\n	<div v-html=\"message\"></div>  <!-- 这是两层div -->\n	<!-- 当使用message时，{{id}}并没有被当做一个绑定数据，而是一个字符串，这就是v-html模板的不足 -->\n	<div v-html=\"message1\"></div>  <!-- 这是两层div -->\n	<!-- 为弥补次不足，Vue又引入了字符串模板，写在template中 -->\n	<!-- 但template的内容会覆盖掉整个被挂载的div -->\n</div>\n\n<!-- 一般会把template单独拿出来，如下 -->\n<script type=\"x/template\" id=\"template1\">\n	<div>hello Vue{{id}}</div>\n</script>\n\n<script type=\"text/javascript\" src=\"https://vuejs.org/js/vue.js\"></script>\n<script type=\"text/javascript\">\n	 var vm = new Vue({\n	 	el:\"#demo\",\n	 	data:{\n	 		message:\"<div>hello Vue</div>\",  //当绑定的数据是一个节点时，在浏览器并没有被解析成为一个节点，而是一个字符串\n	 		//  显而易见，我希望<div>hello Vue</div>要被解析成为一个节点\n	 		message1:\"<div>hello Vue{{id}}</div>\",\n	 		id:\"true\"    \n	 	},\n	 	template:\"#template1\",\n	 	//  render()函数模板，创建一个虚拟节点\n	 	render(creatElement){\n	 		var dom = creatElement(\"\",{},[]);\n	 		// 或者写成\n	 		creatElement(\"div\",{  \n	 			attrs:{id：\"1\"},  \n	 			class:{     // class特殊，所以单独拿出来写\n	 				vue1:true\n	 			},\n	 			domProps:{   // 会覆盖掉第三位的[]参数，优先级最高\n	 				innerHTML:\"任意\"\n	 			}\n	 		},[\"任意\"]);\n	 		return dom;     //return dom 就相当于调用了render函数，会将此节点渲染到页面\n	 		//  不管以何种方式底层都是调用了render函数\n	 		// 但直接使用虽然会增加性能，但无法使用v-if v-for等指令，但可以通过原生JavaScript的if-else和map重写render函数\n	 	} \n	 });\n</script>\n```\n\n</body>\n</html>\n\n', '1413704941749260289', '2', '20', '2021-12-13 21:41:05', '2021-12-15 21:41:52', '2021-12-13');
INSERT INTO `bms_post` VALUES ('1413857479840563202', '人工智能--CV视觉方向详细知识体系总结', '本文专注整理一些有关计算机视觉的知识体系，这不是最终版，会不定期的更新。\n\n整理的CV知识体系主要包括基础知识，工具，图像分类，目标检测，图像分割，目标跟踪，人脸识别，推荐书籍以及一些常见面试题目，包含了作为一个CV工程师在开发工作学习中需要用到或者可能用到的绝大部分知识。千里之行始于足下，希望大家根据自己的薄弱点，查缺补漏，根据自己感兴趣的方面多学习，学的精通一点，从现在开始行动起来。路漫漫其修远兮，吾将上下而求索，不管编程开发的路有多么难走，多么艰辛，我们都将百折不挠，不遗余力地去追求和探索。\n\n文中有哪里写的不对的地方，欢迎各位大佬前来指正~~~\n\n在这里插入图片描述\n\n文章目录\n\n```\n工具\n        Conda\n        pycharm\n        jupyter\n    python\n    FAQ\n    常用工具类库\n    图像处理\n    机器学习\n        经典算法（待整理）\n            线性回归\n            逻辑回归\n            Kmeans\n            SVM\n    深度学习\n        深度学习框架\n        图像分类\n        目标检测\n            Rcnn系列\n            Yolo系列\n        图像分割\n            Mask Rcnn\n        目标跟踪\n        人脸识别\n    操作系统\n    AI面试总结\n    推荐福利\n```\n\n工具\nConda\n序号	内容	地址\n1	什么是conda？	https://blog.csdn.net/weixin_46112766/article/details/111317247\n2	windows系统利用conda搭建深度学习环境	https://blog.csdn.net/weixin_46112766/article/details/109067399\n3	Mac系统利用conda搭建深度学习环境	https://blog.csdn.net/weixin_46112766/article/details/109067652\n4	Linux系统利用conda搭建深度学习环境	https://blog.csdn.net/weixin_46112766/article/details/109067632\npycharm\n序号	内容	地址\n1	pycharm快捷键	https://blog.csdn.net/weixin_46112766/article/details/111318975\n2	安装常见问题	https://blog.csdn.net/weixin_46112766/article/details/109203589\njupyter\n序号	内容	地址\n1	jupyter插件安装	https://blog.csdn.net/weixin_46112766/article/details/110949584\n2	jupyter快捷键	https://blog.csdn.net/weixin_46112766/article/details/111320617\npython\n序号	内容	地址\n1	python简介	https://blog.csdn.net/weixin_46112766/article/details/111631580\n2	python语法：缩进	https://blog.csdn.net/weixin_46112766/article/details/111632600\n3	format格式化函数	https://blog.csdn.net/weixin_46112766/article/details/111632874\n4	变量命名&标识符	https://blog.csdn.net/weixin_46112766/article/details/111632948\n5	python注释	https://blog.csdn.net/weixin_46112766/article/details/111633069\n6	python运行的三种方式	https://blog.csdn.net/weixin_46112766/article/details/111633128\n7	os模块	https://blog.csdn.net/weixin_46112766/article/details/111633216\nFAQ\n序号	内容	地址\n1	tf2报错cudnn初始化失败	https://blog.csdn.net/weixin_46112766/article/details/111354006\n2	conda不是内外部命令解决办法	https://blog.csdn.net/weixin_46112766/article/details/112873131\n3	jupyter文件转换为py文件	https://blog.csdn.net/weixin_46112766/article/details/112940626\n常用工具类库\n序号	内容	地址\n1	numpy	更新ing\n2	matplotlib	更新ing\n3	pandas	更新ing\n4	opencv	更新ing\n图像处理\n序号	内容	地址\n1	图像滤波与比边缘检测	https://blog.csdn.net/weixin_46112766/article/details/111181200\n2	opencv常用函数API注意事项	https://blog.csdn.net/weixin_46112766/article/details/111317520\n3	几何变换	更新ing\n4	形态学滤波	更新ing\n机器学习\n序号	内容	地址\n1	损失函数	https://blog.csdn.net/weixin_46112766/article/details/111314068\n2	激活函数	https://blog.csdn.net/weixin_46112766/article/details/109255872\n3	反向传播	https://blog.csdn.net/weixin_46112766/article/details/109262133\n4	评价指标	https://blog.csdn.net/weixin_46112766/article/details/111863236\n5	梯度下降	https://blog.csdn.net/weixin_46112766/article/details/112308601\n6	BN	https://blog.csdn.net/weixin_46112766/article/details/112362297\n经典算法（待整理）\n线性回归\n逻辑回归\nKmeans\nSVM\n深度学习\n序号	内容	地址\n1	CNN卷积	https://blog.csdn.net/weixin_46112766/article/details/109399748\n深度学习框架\n序号	内容	地址\n1	Tensorflow	更新ing\n3	PyTorch	https://blog.csdn.net/weixin_46112766/article/details/111318152\n4	pytorch的安装	https://blog.csdn.net/weixin_46112766/article/details/111870610\n图像分类\n\n常用经典分类网络\n序号	内容	地址\n1	Vgg	https://blog.csdn.net/weixin_46112766/article/details/111354240\n2	Lenet	更新ing\n3	AlexNet	更新ing\n4	ResNet	更新ing\n5	DenseNet	更新ing\n目标检测\nRcnn系列\n序号	内容	地址\n1	Rcnn	更新ing\n2	Fast Rcnn	更新ing\n3	Faster Rcnn	更新ing\nYolo系列\n序号	内容	地址\n1	YoloV1	更新ing\n2	YoloV2	更新ing\n3	YoloV3	更新ing\n4	YoloV4	更新ing\n图像分割\n\n图像分割可以分为普通分割，语义分割和实例分割。\n\n普通分割：将不同分属不同物体的像素区域分开。 如前景与后景分割开，狗的区域与猫的区域与背景分割开。\n\n语义分割：在普通分割的基础上，分类出每一块区域的语义（即这块区域是什么物体）。如把画面中的所有物体都指出它们各自的类别。\n\n实例分割：在语义分割的基础上，给每个物体编号。 如这个是该画面中的狗A，那个是画面中的狗B。\nMask Rcnn\n目标跟踪\n\n视觉跟踪技术是计算机视觉领域的一个重要研究方向，在军事制导、视频监控、机器人视觉导航、人机交互、以及医疗诊断等许多方面有着广泛的应用前景。、视觉目标跟踪在近十几年里有了突破性的进展，使得视觉跟踪算法不仅仅局限于传统的机器学习方法，更是结合了近些年人工智能热潮—深度学习（神经网络）和相关滤波器等方法，并取得了鲁棒（robust）、精确、稳定的结果。目标跟踪分为单目标跟踪和多目标跟踪，后续会更新详细的算法介绍。\n人脸识别\n\n人脸识别，是基于人的脸部特征信息进行身份识别的一种生物识别技术。用摄像机或摄像头采集含有人脸的图像或视频流，并自动在图像中检测和跟踪人脸，进而对检测到的人脸进行脸部识别的一系列相关技术，通常也叫做人像识别、面部识别。人脸识别任务首先需要检测到人脸，在对人脸进行信息的匹配，从而实现特定的任务。人脸识别的算法页很多，详细的算法介绍更新中。\n序号	内容	地址\n1	人脸识别流程图	https://blog.csdn.net/weixin_46112766/article/details/111867120\n2	MTCNN训练流程以及注意事项	https://blog.csdn.net/weixin_46112766/article/details/111866737\n3	FaceNet训练流程以及注意事项	https://blog.csdn.net/weixin_46112766/article/details/111867077\n4	人脸识别整合操作步骤	https://blog.csdn.net/weixin_46112766/article/details/111867248\n5	人脸识别面试常见题目总结	https://blog.csdn.net/weixin_46112766/article/details/111869820\n操作系统\n序号	内容	地址\n1	windows系统 cmd常用命令	https://blog.csdn.net/weixin_46112766/article/details/111318507\n2	Linux系统常用命令	https://blog.csdn.net/weixin_46112766/article/details/111318835\n3	windows安装双系统教程	https://blog.csdn.net/weixin_46112766/article/details/111319779\n4	进程，线程	更新ing\nAI面试总结\n序号	内容	地址\n1	机器学习面试题	https://blog.csdn.net/weixin_46112766/article/details/111315346\n2	面试真题（1）	https://blog.csdn.net/weixin_46112766/article/details/112802233\n推荐福利\n\n\n\n\n', '1413706063062880257', '1', '9', '2021-12-13 21:47:46', null, '2021-12-13');
INSERT INTO `bms_post` VALUES ('1413857938856804353', '如何成为一名AI人工智能算法工程师？', '经常有朋友私信问，如何学python呀，如何敲代码呀，如何进入AI行业呀？\n\n正好回头看看自己这一年走过的路，进行一次经验总结。\n\n来看看你距离成为一名AI工程师还有多远吧~\n\n:star:具体内容：\n\n我是因为什么开始接触敲代码\n\n人工智能/机器学习/深度学习\n\n自学如何寻找学习资料\n\n如何选择编程语言/框架\n\n校招/社招/实习/面试经验\n\n一碗鸡汤\n\n:star:声明：\n\n本篇内容均属于个人观点，建议采纳对自己有用的经验，如有疏漏，欢迎指正，共同进步！\n\n2017年5月开始第一份实习 / 2017年7月开始学敲代码 / 2017年11月硕士毕业\n\n擅长的编程语言：R / Python\n\n不花钱报班，全靠自学，最初是因为穷，后来发现“开源”的世界真是太美好了！\n\n![如何成为一名AI人工智能算法工程师？](http://p1.pstatp.com/large/pgc-image/bad5aae56c2647478fc6826ca201001e)\n\n**我是因为什么开始接触敲代码？**\n\n**我的第一个模型是什么**\n\n由于本科是数学，研究生是量化分析，第一份实习是一家金融科技公司，开始接触所谓的“Fintech”\n\n第一个任务就是做客户的信用评分卡模型，目的给每个用户打一个信用分数，类似支付宝的芝麻信用分。这是银行标配的一个模型，最常见最传统的算法用的就是 **逻辑回归** 。\n\n在课堂上使用的工具是SAS，SPSS，属于有操作界面的，菜单非常齐全，只需要鼠标点一点就能建模，很好上手。但是SAS这些要付钱的，年费还是相当的贵，所以深圳大部分公司进行数据分析和建模工作都选择开源免费的R语言或者Python。这就体现了掌握一门编程语言的重要性。\n\n虽然说是建模任务，但是前三个月跟建模基本都扯不上边。都在做数据清洗，表格整理（摊手），都在library各种包，用的最多的可能是data.table和dplyr。没办法，很多模型都有包可以直接调用，是最简单的环节了。其实一开始，我一直在犯很低级的错误，各种报错，没有library啦，标点符号没打对啦，各种很low的错误犯了一次又一次，而且连报错的内容都不会看，不知道怎么去改正。如果你也像我一样， **真的请不要灰心** ，我就是这样走过来的。对着错误一个个去解决就好了~\n\n当时什么都不知道的时候，觉得真难呀，每个环节都有那么多细节要照顾，要学的那么多，做完一个还有一个，还要理解业务含义。但是当完整的做一遍之后再回头，就会觉得，其实，也没那么难嘛~\n\n![如何成为一名AI人工智能算法工程师？](http://p1.pstatp.com/large/pgc-image/ee5c26c7d4bc42a89799b989ebed1f59)\n\n**敲代码容易吗？**\n\n因为我不是计算机专业的，所以基本上属于没怎么敲过代码的那种。\n\n后来发现程序员也有好多种类的，前端后端等，因此敲的代码种类也很多，才会有几十种的编程语言，下图是一些这几年的主流语言。\n\n![如何成为一名AI人工智能算法工程师？](http://p3.pstatp.com/large/pgc-image/2ec0142b49a54ca6ba533253865617c4)\n\n实习时我一直被队友嫌弃很蠢，而且一开始敲的东西怎么也运行不通，运行出来的都是鬼结果。有n次想放弃的念头，“我干嘛一定要敲这玩意儿？”，但也有n+1次想坚持的理由，因为我真的喜欢我正在做的事。为什么用“坚持”，因为真的不容易。不难，但真的需要有耐心。\n\n一开始我的状态就是一行行代码的运行，一个个命令的熟悉，反复看，反复运行。\n\n* **从敲出第一行代码到敲出第一个完整的模型花了3个月**\n* 学习XGBoost，光是理论学了3个月，因为前期铺垫要学的还有adaboost/gbdt和各种机器学习的知识模块\n* **从R切换到python花了1个月**\n* 从机器学习(Machine Learning)切换到自动机器学习(Auto Machine Learning)花了2个月\n* **从NLP零基础到搭建一个智能问答机器人花了1个月**\n\n从一年前的“什么是过拟合，什么是交叉检验，损失函数有哪些”到后来参加全球人工智能峰会时都能听懂的七七八八，会觉得，努力没有白费呀！\n\n![如何成为一名AI人工智能算法工程师？](http://p1.pstatp.com/large/pgc-image/08da5606681149658ee82b1124824bfa)\n\n可以看出，经过前面的积累，后面会学的越来越快。\n\n慢慢的就从一开始的那种“唉，怎么又报错啊，好挫败”的心态变成现在的“啊？没error？感觉不对啊，再查验一遍吧”这种抖M倾向的人。代码虐我千百遍，我已经被磨的没有了脾气。\n\n已经有几个朋友说想转行了，我何曾没想过，只是不知不觉中坚持了下来而已。因为热爱，越虐越停不下来\n\n**小结**\n\n**设定一个非常清晰的目标**\n\n为什么第一个写：“我是因为什么开始敲代码的”，因为动机真的非常重要！\n\n所以，很多人在问我“如何学python？”这种问题时，我的第一回答都是“你学python用来干嘛？”\n\n在学校也敲打过python，做个爬虫demo什么的，因为目的性不强没多久就放一边了。清晰的目标就比如说你要做NLP，你要知道NLP的应用有智能问答，机器翻译，搜索引擎等等。然后如果你要做智能问答你要知道现在最发达的技术是深度学习，使用的算法有RNN/LSTM/Seq2Seq/等等一系列。而我的清晰目标是在实习的时候给我的任务。当任务很明确的时候，所需要的语言就明确了，所要学习的算法也就明确了，很多东西就顺理成章了不用一头乱撞了。\n\n**从金融到科技**\n\nAI的应用范围很广，每一个研究方向都是无穷尽的。由于金融公司很少与图像处理，NLP等技术会有交集，而我强大的好奇心让我决定去纯粹的科技公司一探究竟。目前已投身于智能家居，目标是Javis\n\n**人工智能/机器学习/深度学习**\n\n我经常在公交的广告牌上看见这些词，好像哪家公司没有这个技术就落后了似的。更多的还有强化学习，迁移学习，增量学习等各种学习。\n\n**这些词儿之间到底什么关系**\n\n机器学习是人工智能的一种，深度学习是机器学习的一种。 **学AI先学机器学习** 。\n\n![如何成为一名AI人工智能算法工程师？](http://p3.pstatp.com/large/pgc-image/b5199c1f23a4448d9fcf15c0b1315c34)\n\n**计算机的“算法” 与 数学的“算法” 的区别**\n\n理论知识对于AI算法工程师极其重要。敲代码只是思路的一个实现过程。这里的“算法”和计算机CS的“算法”还不太一样，AI算法是偏数学推导的，所以数学底子还是需要点的，学的越深，要求越高。面试的时候，很少让手写代码，90%都是在问模型抠算法细节。\n\n在学校我是一个不爱记笔记的人，甚至是一个不爱上课的人。但是自从入了机器学习的坑后，笔记写的飞起~\n\n![如何成为一名AI人工智能算法工程师？](http://p1.pstatp.com/large/pgc-image/2f6d1cb7366845f08c0583975642fb7a)\n\n![如何成为一名AI人工智能算法工程师？](http://p1.pstatp.com/large/pgc-image/84132e9a823144d8a2f8c5ad343cb780)\n\n**机器学习的框架**\n\n按照数据集有没有Y值可以将机器学习分为监督学习、半监督学习和无监督学习。监督学习是分类算法，无监督学习是聚类算法。\n\n![如何成为一名AI人工智能算法工程师？](http://p3.pstatp.com/large/pgc-image/eb84d6c703b84ebf9e5f9918df22e3a5)\n\n机器学习的通用流程和相关技术如下图：\n\n![如何成为一名AI人工智能算法工程师？](http://p1.pstatp.com/large/pgc-image/af68c897a46942e2992ff7cca9c039bd)\n\nML这棵树还可以有更多的分支。先有个整体感受，再一个一个的解决掉。这里的知识点也是面试最爱问的几个，是重点呀！面试过的同学应该都不陌生了。\n\n**机器学习如何入门**\n\n机器学习之大，初学者都无从下手。说白了，机器学习就是各种模型做预测，那么就需要有数据，要想有好的效果，就要把原始的脏数据洗干净了才能用。数据内隐藏的信息有时候是肉眼不可见的，那么就需要一些相关技巧来把有用信息挖出来。所有绞尽脑汁使用的技巧，都是为了能预测的更准确。但是谁也没办法做到百分百的命中。\n\n这里简单介绍下机器学习的三大块：传统的机器学习ML、图像处理CV、自然语言处理NLP\n\n再推荐一个入门神器：\n\n**Kaggle（www.kaggle.com）**\n\n这是一个世界级的最权威的机器学习比赛，已被谷歌收购。上面的赛题不仅很有代表性，还有很多免费的优秀的数据集供你使用，要知道收集数据是机器学习的第一大难题，它就帮你解决了。入门不用立马参加比赛，把数据下载下来，尽情折腾就好了，要是没有思路，去网上搜别人的解题笔记和代码借鉴一下也很美好~因为这是大家都争相打榜的比赛，所以你并不孤单。\n\n**ML入门该参加的赛题（Titanic）**\n\n![如何成为一名AI人工智能算法工程师？](http://p3.pstatp.com/large/pgc-image/e5054824be994ab7b0c5c343ac929459)\n\n**图像入门该参加的赛题（数字识别）**\n\n![如何成为一名AI人工智能算法工程师？](http://p3.pstatp.com/large/pgc-image/5e74208b2b26426fba4a1ee2ca31cd07)\n\n**NLP入门该参加的赛题（情感分析、quora问句语义匹配）**\n\n![如何成为一名AI人工智能算法工程师？](http://p3.pstatp.com/large/pgc-image/e03f7500fbb2447c817570d473675876)\n\n![如何成为一名AI人工智能算法工程师？](http://p3.pstatp.com/large/pgc-image/fb9bc920a6314b5ebd01e9b8c953507c)\n\n等做完第一个titanic的比赛应该就有点感觉了。上面4个比赛我都做过，觉得很经典，很适合入门。\n\n**深度学习的入门算法有哪些**\n\n如今的样本输入可以是文字，可以是图像，可以是数字。\n\n深度学习是跟着图像处理火起来的。甚至现在这个概念都火过了“机器学习”。\n\n深度学习的算法主要都是神经网络系列。入门推荐CNN(卷积神经网络)的一系列：\n\nLeNet5\n\nAlexNet\n\nVGG\n\nGoogleNet\n\nResNet\n\n**自学如何寻找学习资料？**\n\n**开源的世界，美好的世界:heart:**\n\n“开源”，我的爱！代码届里开源的中心思想就是，share and free\n\n对于机器学习，网上的社区氛围特别好，分享的很多很全面，而且MLer都非常乐于助人。\n\n介绍几个我经常逛的社区，论坛，和网页：\n\n**kaggle （www.kaggle.com）**\n\n全球最权威的机器学习比赛，已被谷歌收购。赛题覆盖传统机器学习、nlp、图像处理等，而且都是很实际的问题，来自各行各业。kaggle是数一数二完善的ML社区了，赛题开放的数据集就很有用，非常适合新手练手。对优秀的kaggler也提供工作机会。\n\n**github（www.github.com）**\n\n全球最大同性交友网站，适合搜项目，开源大社区，大家一起看星星，看issue~\n\n**StackOverFlow（www.stackoverflow.com）**\n\n代码报错找它，代码不会敲找它！所有与代码相关的坑，基本都有人踩过啦\n\n**csdn（www.csdn.net）**\n\n最接地气的博客聚集地，最常看的网页之一，一般用来搜索细节知识点或者代码报错时\n\n**sklearn（scikit-learn.org/stable）**\n\n专业做机器学习100年！各算法各技巧的例子code应有尽有\n\n**medium（medium.com）**\n\n创办人是Twitter的创始人，推崇优质内容，国内很多AI公众大号的搬运都来自于这里，medium里每个作者都有自己独特的见解，值得学习和开拓眼界，需要科学上网\n\n**towards data science（towardsdatascience.com）**\n\n与medium很像，需要科学上网\n\n**google AI blog（ai.googleblog.com）**\n\n谷歌的AI团队维护的博客，每天至少更新一篇技术博客。刚在上海开的谷歌开发者大会宣布将会免费开放机器学习课程，值得关注一下，毕竟是AI巨头\n\n**各种大神的技术博客/个人网站**\n\n有很多的网站，会不定期的更新在我的个人博客里\n\n**有口碑的AI公开课平台**\n\n首先说明我没有上课，也没有报班，属于个人学习习惯问题。但考虑到学习差异性，所以还是总结了口碑排名靠前的课程系列。前提，需要有一定数学基础，没有的可以顺便补一补。\n\n**coursera（www.coursera.org/browse）**\n\n**吴恩达(Andrew Ng)机器学习**\n\n**deeplearning.ai（www.deeplearning.ai）**\n\n**fast.ai（www.fast.ai）**\n\n专注于深度学习。Fast.ai的创始人就蛮有意思的，是横扫kaggle图像处理的高手，不摆架子，也不故弄玄虚。中心思想就是深度学习很简单，不要怕。fast.ai有博客和社区。Jeremy和Rachel鼓励撰写博客，构建项目，在会议中进行讨论等活动，以实力来代替传统证书的证明作用。\n\n**udacity（in.udacity.com）**\n\n有中文版，课程覆盖编程基础，机器学习，深度学习等。\n\n**网易云课堂**\n\n**碎片时间**\n\n科技圈也是有潮流要赶的，等你入坑就知道。\n\n追最新的论文，最新的算法，最新的比赛，以及AI圈的网红是哪些~有条件的开个twitter，平时娱乐看看机器学习板块还是蛮有意思的，有很多自嘲的漫画~\n\n推荐几个我超爱看的AI主题美剧\n\n**硅谷** （强推！简直是我日常生活，太有共鸣了~下饭剧）\n\n**西部世界** （看的时候不要学我一直在思考如何实现这个那个技术）\n\n**实用的小技巧**\n\n浏览器首推 chrome\n\n当阅读英文网页呼吸困难时，右击选择“翻成中文（简体）”\n\n考过雅思和GMAT，曾经我也是一个热爱英文的孩子，如今跪倒在海量技术文档和文献里苟活\n\n搜索问题一定用google，如果没解决是你的问题不是google的锅\n\nbaidu？？？ummm......别为难我......很少用\n\n学会提问很重要，搜索格式推荐\n\n语言+问题，例如：python how to convert a list to a dataframe\n\n直接复制错误信息，例如：ValueError: No variables to save...\n\n请把所有的问题往上抛，网上查比问人快！总是问别人会引起关系破裂的~\n\n学会顺藤摸瓜\n\n当你读到一个非常不错的技术文档时，看完别急着关掉。这可能是一个个人网站，去观察菜单栏里有没有【About】选项。或者这也可能是一个优秀的社区，看看有没有【Home】选项，去看看po的其它的文章。\n\n很多优秀网站都是英文，科学上网必不可少\n\n学习费用不来自课程，可能来自于硬件要求，学生党要利用好学校资源\n\n**小结**\n\n虽然说了那么多，但还是要说 **请放弃海量资料！用多少，找多少就好了！（别把这句话当耳旁风** ）\n\n**资料不在量多而在于内容是有质量保证的** 。很多课程或者公众号只管塞知识，你有疑问它也解答不了的时候，这样出来的效果不好，就像一个模型 **只管训练，却不验证，就是耍流氓** 。\n\n**如何选择编程语言/框架**\n\n**首选英语！！！（咳咳，我认真的）**\n\n说到底，语言只是工具，不去盲目的追求任何一种技术。根据任务来选择语言，不一样的程序员选择不一样的编程语言。很多人最后不是把重点放在能力而是炫工具，那就有点走偏了。\n\n据观察，在机器学习组里R和Python是使用率最高的两门语言，一般你哪个用的顺就用哪个，只要能达到效果就行，除非强制规定。\n\n我使用之后的感受是，**人生苦短，我用python**\n\n**用python建个模型到底多难？**\n\n算法任务大致分为两种，一种是普通算法工程师做的“调包、调参”，另一种是高级算法工程师做的，可以自己创建一个算法或者能灵活修改别人的算法。\n\n先说说建个模到底有多简单吧。\n\n有优秀的算法封装框架\n\ntensorflow / caffe / keras /...\n\nAuto ML 是不可阻挡的一个方向\n\nAuto ML(auto machine\nlearning)，自动机器学习。就是你只管丢进去数据，坐等跑出结果来就行了。前一阵子谷歌的CloudML炒的很火，愿景是让每个人都能建模，但毕竟这种服务是要钱的。所以我研究了下开源的auto\nsklearn框架的代码，发现了什么呢？建模到底有多简单呢？就，简单到4行代码就可能打败10年工作经验的建模师。\n\n再说回来，如果你自己根本不知道自己在做什么，**只能跑出来一个你不能负责的结果，就是很糟糕**的，那还不是一个合格的算法工程师。**你的模型必须像你亲生的那样。但是，只要你想，绝对能做到的！**\n\n**学习python电脑上要装哪些东西**\n\nAnaconda\n\n对，就是这么简单粗暴，装这个就ok了\n\n学python的应该都会面临到底是python2还是python3的抉择吧。语言版本和环境真的很让人头疼，但是Anaconda惊艳到我了，就是可以自定义python环境，你可以左手py2右手py3\n\n**推荐几个python的IDE**\n\nSpyder\n\nAnaconda自带的ide。界面排版与Rstudio和Matlab很相似。输入什么就输出什么结果，适合分析工作，我写小功能的时候很喜欢用。\n\nJupyter Notebook\n\nAnaconda自带的ide，属于web界面的。当你程序跑在虚拟机，想调代码的时候适合用。\n\nPyCharm\n\n对于写项目的，或者代码走读的比较友好。当你需要写好多python文件互相import时，特别好用。\n\n**我的笔记本配置**\n\n（不考虑经济约束的请忽略这条）\n\n牌子+型号：ThinkPad X1 Carbon\n\n推荐配置：i7+16G内存+256G(或更多)硬盘\n\n系统推荐：Linux，因为开源，有空可以玩玩\n\n:zap:**校招/社招/实习/面试经验**\n\n如何安排校招\n\n大厂的开放时间会比较早，密切关注网申时间节点：\n\n2019届的秋招：2019年7月 - 2019年11月\n\n2020届的春招：2020年2月 - 2020年4月\n\n2020届的暑期实习：2020年3月 - 2020年5月\n\n2020届的秋招：2020年7月 - 2020年11月\n\n（以此类推）\n\n手撕代码能力\n\n建议提早半年开始准备。我的代码也是从实习开始敲起，敲了半年才觉得下手如有神哈哈。不要做没实际意义的课后题，也不要照着书本例题敲，敲完你就忘了，书本这些都是已经排除万难的东西，得不到什么成长。\n\n入门修炼：全国大学生数学建模竞赛、全美大学生数学建模竞赛、kaggle、天池…\n\n项目经历/实习经历\n\n如果明确自己的职业方向为人工智能/数据挖掘类的，请不要浪费时间去申请其他与技术无关的实习。端茶送水，外卖跑腿，打印纸并不能帮你。当时由于身边同学都断断续续出去实习，面前有一份大厂行政的实习，我…竟然犹豫了一下，好在也还是拒绝了。\n\n尽量选择大厂的技术实习，毕竟以后想进去会更难。但是不要因为一个月拿3000块就只干3000块的活。把整个项目跟下来，了解框架的架构，优化的方向，多去尝试，就算加班（加班在深圳很正常）也是你赚到，思考如何简化重复性工作，去尝试了解自己部门和其他部门的工作内容与方向，了解的越多你对自己想做的事情了解的也越多。我实习做的评分卡模型，除了传统逻辑回归，也尝试新的XGB等等，而且虽然别人也在做，但是私下自己会把整个模型写一遍，包含数据清洗和模型调优等，这样对业务的了解也更透彻，面试起来所有的细节都是亲手做过的，也就比较顺了。\n\n如果没有实习在手，世界给我们数据挖掘选手的大门还是敞开着的。kaggle上有专门给数据挖掘入门者的练习场。相关的比赛还有很多，包括腾讯、阿里等大厂也时不时会发布算法大赛，目测这样的算法大赛只会越来越多，你坚持做完一个项目，你在平台上还可以得到相关名次，名次越靠前越有利哈哈哈这是废话。\n\nBAT常见的面试题（不分先后）\n\n自我介绍/项目介绍\n\n类别不均衡如何处理\n\n数据标准化有哪些方法/正则化如何实现/onehot原理\n\n为什么XGB比GBDT好\n\n数据清洗的方法有哪些/数据清洗步骤\n\n缺失值填充方式有哪些\n\n变量筛选有哪些方法\n\n信息增益的计算公式\n\n样本量很少情况下如何建模\n\n交叉检验的实现\n\n决策树如何剪枝\n\nWOE/IV值计算公式\n\n分箱有哪些方法/分箱原理是什么\n\n手推SVM：目标函数，计算逻辑，公式都写出来，平面与非平面\n\n核函数有哪些\n\nXGB原理介绍/参数介绍/决策树原理介绍/决策树的优点\n\nLinux/C/Java熟悉程度\n\n过拟合如何解决\n\n平时通过什么渠道学习机器学习（好问题值得好好准备）\n\n决策树先剪枝还是后剪枝好\n\n损失函数有哪些\n\n偏向做数据挖掘还是算法研究（好问题）\n\nbagging与boosting的区别\n\n模型评估指标有哪些\n\n解释模型复杂度/模型复杂度与什么有关\n\n说出一个聚类算法\n\nROC计算逻辑\n\n如何判断一个模型中的变量太多\n\n决策树与其他模型的损失函数、复杂度的比较\n\n决策树能否有非数值型变量\n\n决策树与神经网络的区别与优缺点对比\n\n数据结构有哪些\n\nmodel ensembling的方法有哪些\n\n小结\n\n问题是散的，知识是有关联的，学习的时候要从大框架学到小细节。\n\n没事多逛逛招聘网站看看招聘需求，了解市场的需求到底是什么样的。时代变化很快，捕捉信息的能力要锻炼出来。你可以关注的点有：职业名/职业方向/需要会什么编程语言/需要会什么算法/薪资/...\n\n每个面试的结尾，面试官会问你有没有什么想问的，请注意这个问题也很关键。\n\n比如：这个小组目前在做什么项目/实现项目主要用什么语言和算法/…\n\n尽量不要问加不加班，有没有加班费之类的，别问我为什么这么说（摊手）\n\n在面试中遇到不理解的，比如C++语法不懂，可以问这个C++具体在项目中实现什么功能。 **如果你提出好问题，能再次引起面试官对你的兴趣** ，那就能增加面试成功率。\n\n应届生就好好准备校招，别懒，别怕输，别怕被拒，从哪里跌倒从哪里起来。社招不是你能招呼的，会更挫败，因为你什么也没做过。\n\n虽然是做技术的，但是日常social一下还是收益很大的。实习的时候，也要与周围同事和平相处，尤其是老大哥们，也许哪天他就帮你内推大厂去了。内推你能知道意想不到的信息，面试官，岗位需求，最近在做什么项目之类的。\n\n**挑选给你机会的公司，不要浪费自己的时间** 。不要每家都去，去之前了解这家公司与你的 **匹配度** 。\n\n尤其社招，你一改动简历就很多人给你打电话，你要有策略的去进行面试，把握总结每个机会。像我就是东一榔头西一榔头的，好多都是止步于第一面，就没回信儿了，因为每次面完没有好好反思总结，等下次再遇到这问题还是抓瞎，十分消耗自己的时间和信心。\n\n**一碗鸡汤**\n\n**一切才刚刚开始，别着急**\n\nAI才刚刚起步，为什么呢？因为上数学课的时候，课本上都是柯西，牛顿，高斯等等，感觉他们活在遥远的时代，很有陌生感。但是现在，我每天用的模型是比我没大几岁的陈天奇创造出来的，我甚至follow他的社交账号，他就鲜活在我的世界里，这种感觉，很奇妙。每次查论文查文献的时候，看2017年出来的都觉得晚了，懊悔自己怎么学的这么慢，看2018年2月出来的才心里有点安慰。这个证明，你在时代发展的浪潮上，也是一切刚刚起步的证明。机遇与挑战并肩出现的时候，是你离创造历史最近的时候。而所谓的风口所谓的浪尖都不重要， **重要的是，因为你喜欢** 。\n\n**找一件可以坚持的事，不要停止去寻找的脚步**\n\n当人做喜欢的事情时，会发光呀！\n\n当你因为真的热爱某件事，而不断接近它的时候，你的灵魂像是被上帝指点了迷津，受到了指示，受到了召唤。你会很自然的知道该做什么，你想做什么，好像生而为了这件事而来。你有时候自己都想不明白为什么做这件事。看过月亮与六便士的应该懂这种使命感~\n\n![如何成为一名AI人工智能算法工程师？](http://p1.pstatp.com/large/pgc-image/893ca2b92fdf4bed9d4fa606f1a7e879)\n\n我不是属于聪明的那类人，我是属于比较倔的那种。就是只要我认定的，我认定到底。天知道我有多少次怀疑过自己，有多少次想放弃，但我还是选择咬牙向前，选择相信自己。坚持的意义就在这里。\n\n![如何成为一名AI人工智能算法工程师？](http://p1.pstatp.com/large/pgc-image/a4f8156be696475ba2c2635ace9a5105)\n\n', '1413706636436819970', '1', '15', '2021-12-13 21:49:35', null, '2021-12-13');
INSERT INTO `bms_post` VALUES ('1413858778560659458', 'ai人工智能_人工智能（AI）简介', 'ai人工智能\n\nHere you will get an introduction to artificial intelligence.\n\n在这里，您将获得有关人工智能的介绍。\n\nFirst of all let us quickly recall what we have learnt in previous\nblog posts to get an idea of what we already have covered and shouldn’t\ninvest time on. So far, we’ve learnt about [Machine Learning](https://www.thecrazyprogrammer.com/2017/11/introduction-machine-learning.html)\nconcepts, the algorithms, packages and IDEs etc. Now when we are quite\nfamiliar about the term Machine Learning, it is time to explore further\nin the domain. It is time to understand what Artificial Intelligence is?\nMany people use Machine Learning and AI interchangeably and think both\nof them as the same. But the fact is they are not the same as inferred\nby majority. Come let’s understand how these two terms (ML and AI) are\nnot the same.\n\n首先，让我们快速回顾一下以前在博客文章中学到的内容，以了解我们已经介绍的内容，不应浪费时间。 到目前为止，我们已经了解了[机器学习的](https://www.thecrazyprogrammer.com/2017/11/introduction-machine-learning.html)概念，算法，包和IDE等。现在，当我们对机器学习一词非常熟悉时，就该在该领域进行进一步的探索了。\n是时候了解什么是人工智能了？ 许多人互换使用机器学习和AI，并认为两者是相同的。 但事实是，它们与多数人推论的并不相同。\n快来让我们了解一下这两个术语(ML和AI)是如何不同的。\n\n![Introduction to Artificial Intelligence (AI)](https://img-blog.csdnimg.cn/img_convert/0889ae77b3623a0eb8c92f987884b3cb.png)\n\n[Image Source](https://blogs.nvidia.com/blog/2016/07/29/whats-difference-artificial-intelligence-machine-learning-deep-learning-ai/)\n\n[图片来源](https://blogs.nvidia.com/blog/2016/07/29/whats-difference-artificial-intelligence-machine-learning-deep-learning-ai/)\n\nAs we can see in the image above it is quite clear that we see AI\nand ML differently instead a single domain. In other words “ML is a\nsubset of AI.”\n\n正如我们在上图中所看到的，很明显，我们看到AI和ML的方式有所不同，而不是单个域。 换句话说，“ ML是AI的子集。”\n\nArtificial Intelligence can be thought of as a broader term in which\na machine is expected to behave humanly. Whereas on the other hand as\nwe are already aware that in ML we train our machine providing to do a\nspecific task by providing it some data.\n\n人工智能可以被认为是广义的术语，指的是机器会表现出人类的行为。 另一方面，正如我们已经知道的那样，在ML中，我们通过提供一些数据来训练提供特定任务的机器。\n\nWe know you guys might be wondering now what the heck is this Deep\nLearning. As for now think of it as “a subset of ML (comes under\nReinforcement Learning)” and we will discuss on this too on some later\nposts. Let us now quickly dive into Artificial Intelligence and explore\nwhat’s interesting in it.\n\n我们知道你们现在可能想知道深度学习到底有什么用。 现在，将其视为“ ML的子集(来自强化学习)”，我们将在以后的文章中对此进行讨论。 现在让我们快速进入人工智能并探索其中有趣的部分。\n\n## 什么是人工智能？ (What is Artificial Intelligence?)\n\n![Artificial Intelligence (AI)](https://img-blog.csdnimg.cn/img_convert/4bd55eb4671456491b79d077e015cb5d.png)\n\n[Image Source](https://www.youtube.com/watch?v=kWmX3pd1f10)\n\n[图片来源](https://www.youtube.com/watch?v=kWmX3pd1f10)\n\nIt is believed that AI is not a new term, people say that according to Greek myths there were *mechanical men *in early days that act like humans.\n\n人们相信AI并不是一个新名词，人们说，根据希腊神话，早期有*机械*人像人类一样行事。\n\nInstead of understanding AI as machines that do complex\ncalculations, it can better be explained as machines that are built to\nact and behave like human, contains features of human like facial\nrecognition, voice recognition, decision making, vision system etc. The\ndevices (machines or computers) that are AI powered are often classified\ninto two categories namely: Applied AI and General AIs.\n\n与其将AI理解为进行复杂计算的机器，不如将其解释为被构造为像人类一样行动和行为的机器，包含面部识别，语音识别，决策，视觉系统等人类特征。由AI驱动的计算机(或计算机)通常分为两类：应用AI和通用AI。\n\n**Applied AI: **Applied AI is considered as the common\nAI, result of which can be spotted in the field of Stock trading,\nautonomous vehicles etc.\n\n**应用的AI：** 应用的AI被认为是常见的AI，其结果可以在股票交易，自动驾驶汽车等领域发现。\n\n**General AI: **The devices that run on principles are\nnot very common to spot in our locality but it is interesting to know\nthat some of the buzzing topics like Machine Learning is an example of\nthis.\n\n**通用AI：** 基于原理运行的设备在我们当地并不常见，但有趣的是，诸如机器学习之类的一些热门话题就是其中的一个例子。\n\n**Two thoughts on AI:**\n\n**关于AI的两种想法：**\n\n1. How to make machines behave like human.\n   \n   如何使机器表现得像人一样。\n2. Have machine behaviour in best possible way.\n   \n   以最佳方式使机器运转。\n\n**What are the ways to carry out AI task?**\n\n**开展AI任务的方式有哪些？**\n\nThere are believed to be seven different steps that help in making\nany AI system behave humanly. We are eager to know what those steps are\nthat can make any machine mimic human behaviour.\n\n据信有七个不同的步骤可以帮助使任何AI系统表现得人性化。 我们渴望知道这些步骤可以使任何机器模仿人类的行为。\n\n* Simulating higher function of human brain.\n  \n  模拟人脑的更高功能。\n* Programming a computer to use general (natural) language.\n  \n  对计算机进行编程以使用通用(自然)语言。\n* Arranging hypothetical neurons in a manner so that they can form concept.\n  \n  以某种方式排列假设的神经元，以便它们可以形成概念。\n* A way to determine and measure problem complexity.\n  \n  确定和衡量问题复杂性的一种方法。\n* Self improvement.\n  \n  自我提升。\n* Abstraction – defined as, the quality of dealing with the idea rather than events.\n  \n  抽象–定义为处理想法而非事件的质量。\n* Randomness and creativity.\n  \n  随机性和创造力。\n\n### 图灵测试 (Turing Test)\n\nTuring Test was proposed by an English computer scientist **Alan Turing **in\n1950. The main objective of Turing test was to find out if a computer\nis intelligent or not? Though this was proved to be not that effective\nto measure the system’s smartness.\n\n图灵测试是由英国计算机科学家**艾伦·图灵** (  **Alan Turing)** 在1950年提出的。图灵测试的主要目的是找出计算机是否智能？ 尽管事实证明这对衡量系统的智能程度不是那么有效。\n\nTuring test consist of three units – an interrogator, a computer\nsystem and a human unit both situated in different rooms. The means of\ncommunication between them was through keyboard and a screen only. The\ninterrogator asks a question to both the units located in different\nrooms and tries to distinguish between the responses received from both\nthe units (human and computer), i.e. which answer is given by the\ncomputer and which one by human, if interrogator fails to correctly\nidentify the computer’s response because of the very minor difference\n(or even no difference) then the system is supposed to be intelligent.\n\n图灵测试由三个单元组成–询问器，计算机系统和人工单元，它们都位于不同的房间中。 它们之间的通信方式仅通过键盘和屏幕进行。\n询问器向位于不同房间的两个单元都询问一个问题，并试图区分从两个单元(人和计算机)接收到的响应，即，如果询问器无法正确执行，则哪个回答由计算机给出，哪个由人给出如果因为差异很小(甚至没有差异)而确定计算机的响应，则该系统应该是智能的。\n\nOther scientists like **Steven Harnad** extended this\nas Total Turing Test in which computer must interact in all areas of\nhuman behaviour instead of language (in case of turing test) only and\nthe test duration extended to lifetime instead of five or ten minutes\nonly.\n\n其他像 **史蒂文·哈纳德(Steven Harnad)** 这样的科学家将其扩展为“全面图灵测试”，其中计算机必须在人类行为的所有方面进行交互，而不仅仅是语言(在图林测试中)，并且测试持续时间可以延长到整个生命周期，而不是五到十分钟。\n\nHuhh.. much of the theoretical knowledge. Come on let’s quickly see what computer needs to pass this test.\n\n嗯..很多理论知识。 来吧，让我们快速查看需要什么计算机通过此测试。\n\n1. NLP (Natural Language Processing)\n   \n   NLP(自然语言处理)\n2. Knowledge Representation\n   \n   知识表示\n3. Automated Reasoning\n   \n   自动推理\n4. Machine Learning ability\n   \n   机器学习能力\n5. Computer Vision\n   \n   计算机视觉\n6. Robotics (touch of Robotism)\n   \n   机器人技术(机器人精神)\n\n### 人工智能的能力(人工智能能做什么？) (Capabilities of AI (What AI can do?))\n\n1. Computer Vision (eg. Facial Recognition)\n   \n   计算机视觉(例如面部识别)\n2. Robotics\n   \n   机器人技术\n3. NLP (Natural Language Processing)\n   \n   NLP(自然语言处理)\n4. Expert System\n   \n   专业系统\n5. Speech Understanding\n   \n   言语理解\n6. Test Categorization\n   \n   测试分类\n7. In games\n   \n   在游戏中\n8. Surf the web\n   \n   浏览网页\n\n### 哪里缺少AI？ (Where AI lacks yet?)\n\n1. Understanding NLP robustly\n   \n   深入了解NLP\n2. Interpret arbitrary visual scene\n   \n   解释任意视觉场景\n3. Learn a natural language\n   \n   学习自然语言\n4. Exhibit true autonomy and intelligence\n   \n   展现真正的自主权和智慧\n\n### 什么是自然语言处理(NLP)？ (What is Natural Language Processing (NLP)?)\n\nRefers to AI method of communicating with intelligent system using\nnatural language such as English. Computer should be able to understand\nthe natural language and give response to it.\n\n指使用自然语言(例如英语)与智能系统通信的AI方法。 计算机应该能够理解自然语言并做出响应。\n\nInput/output can be in the form of Speech or Written Text.\n\n输入/输出可以采用语音或书面文本的形式。\n\n#### NLP的组成部分 (Components of NLP)\n\n1. **Natural Language Understanding (NLU): **Mapping the input provided in natural language into some useful representation is the art of NLU.\n   **自然语言理解(NLU)：** 将自然语言提供的输入映射到一些有用的表示形式是NLU的艺术。\n2. **Natural Language Generation (NLG): **Process\n   of producing meaningful phrases and sentences in form of natural\n   language from some internal representations. This includes: test\n   planning, sentence planning and text realization.\n   **自然语言生成(NLG)：** 从某些内部表示形式以自然语言形式生成有意义的短语和句子的过程。 这包括：测试计划，句子计划和文本实现。\n\n#### NLP中使用的术语 (Terminologies used in NLP)\n\n**Phonology: **Study of organising sounds.\n\n**语音学：** 组织声音的研究。\n\n**Morphology:** Study of construction of words from primitive meaningful unit.\n\n**形态学：** 从原始有意义单位研究单词的构造。\n\n**Syntax:** Refers to arranging words to make sentences and determine the structural role of words in sentences.\n\n**语法：** 指安排单词构成句子并确定单词在句子中的结构作用。\n\n**Semantics:** Deals with how to combine the words to make meaningful sentence.\n\n**语义：** 处理如何组合单词以构成有意义的句子。\n\n**Pragmatics:** Refers to using and understanding sentences in different situations.\n\n**语用学：** 指在不同情况下使用和理解句子。\n\n**Discourse:** How effectively preceeding sentence can affect interpretation of next sentence?\n\n**语篇：** 在前句子如何有效地影响下一个句子的解释？\n\n**Steps of NLP**\n\n**NLP的步骤**\n\n![Steps of NLP](https://img-blog.csdnimg.cn/img_convert/b99d4f717e58fd06a272cb919e612cd5.png)\n\n### [什么是深度学习？](https://www.thecrazyprogrammer.com/2017/12/introduction-to-deep-learning.html) ([What is Deep Learning?](https://www.thecrazyprogrammer.com/2017/12/introduction-to-deep-learning.html))\n\nWe are pretty sure that the term Deep Learning must be haunting  you\nguys since you see it in the very first image attached. Do not worry,\nwe are always here for you. In short Deep Learning is a part or subset\nof Machine Learning as inferred from the very first image from this blog\npost. Deep Learning came into existence only with the notion to\nfacilitate the machines to move forward to achieve their goal to be able\nto think and act rationally or humanly i.e. help computers to achieve\nthe motive of AI with the help of Machine Learning itself.\n\n我们非常确定，因为您在所附的第一张图片中看到了“深度学习”这个词，所以一定会困扰你们。 不用担心，我们一直在这里为您服务。\n简而言之，深度学习是机器学习的一部分或子集，从本博客文章的第一张图片可以推断出。\n深度学习仅以一种概念来存在，即促进机器前进以实现其能够理性或人类思考和行动的目标，即借助机器学习本身来帮助计算机实现AI的动机。\n\nDear readers, that is all for today. We wish you guys enjoyed\nlearning with us. You can post any queries or doubts related to\nartificial intelligence in the comment section.\n\n亲爱的读者，今天就这些。 我们希望你们喜欢与我们一起学习。 您可以在评论部分中发布与人工智能有关的任何疑问或疑问。\n\n', '1413705681544794113', '2', '21', '2021-12-13 21:52:55', null, '2021-12-13');
INSERT INTO `bms_post` VALUES ('1413859145432236033', '谷歌弃用 APK 格式！替代品 AAB 有何优势？', 'Android 用户想必对 APK 并不陌生。APK 是 Android Package 的缩写，即Android 安装包，基于 ZIP 压缩包格式，通过把 Android SDK 编译工程打包成一个 Android 系统支持的安装程序文件，几乎所有 Android 应用程序都以这种格式发布。\n\n但自下个月起，APK 格式要被谷歌弃用了。\n\n近日，谷歌宣布：自 2021 年 8 月起，Google Play 将要求开发者以 Android App Bundle （以下简称 AAB）格式发布新应用，该格式将取代 APK 作为标准发布格式。\n\n为何要从 APK 转变为 AAB？\n\n一直以来，Android 首选的应用程序包就是 APK，而一个 APK 中往往包含应用代码、图片、音频和开发者生成的应用签名密钥等大量资源。\n\n不仅如此，由于 Android 设备规格各异，开发人员还需根据设备的不同屏幕密度（320dpi、480dpi 等）、处理器（ARM、ARM64、x86）、用户所在的不同地区，在 Google Play 中构建和上传多个 APK，以此才能在用户点击“安装”时，在其设备上安装最适配的 APK。\n\n但在这种情况下，应用开发者便承受太多：不仅要开发应用，还要管理许多 APK 以支持大量设备。因此为了省时省力，大多数开发者通常都会选择构建一个通用 APK，即包含语言包、代码等在内的所有资源。不论用户身处何处、使用何种规格的设备，只需下载这个通用 APK 即可。\n\n说到这里，你或许发现了问题所在：包含所有资源的通用 APK 太大了。用户分明只需其中与自己设备相适配的资源，却要把整个 APK 都下载下来，不仅延长了安装时间，也占用了更多的带宽。\n\n为了解决这个问题，谷歌在 2018 年 Google I/O 大会上推出了 AAB 格式，希望以此减少开发者的负担，同时也有助于减少应用大小、安装时间和带宽消耗，提高用户体验。\n\n简单来说，AAB 格式其实并不是一个全新的应用安装包，你可以将它当做一个容器，里面包含着一个基本 APK 和多个用于特定配置的 APK。\n\n而谷歌在这之中则充当“筛选”的角色：一旦开发者选择使用 AAB 格式发布应用，谷歌就会根据用户的设备配置从中生成优化后的 APK 提供给用户。对用户而言，这样的 APK 体积小、安装快，对开发者来说也省事：不必再为各种设备管理一大堆 APK。\n\n因此，总体来看，谷歌要求下个月以 AAB 格式发布新应用的决定主要面向开发者，对用户而言影响不是太大，因为最终在设备上安装 Android 应用的打包格式还是 APK。\n\nAAB 的优势\n\n相较于 APK，AAB 自然有其独一无二的优点。\n\n首先便是上文所提到的应用体积缩小。据谷歌官方介绍，使用 AAB 生成优化的 APK 体积平均会比一般的 APK 小 15%，而这一数据会根据应用大小有较大起伏。例如 Airbnb 在从 APK 切换到 AAB 格式后应用大小减少了 22%，而 Netflix 更是减少了 57%。\n\n其次，AAB 的 Play Feature Delivery 功能可自定义将哪些功能模块交付给哪个设备，支持安装时交付、按条件交付和按需交付等三种模式。这也就是将应用的功能拆分开来，以此大幅缩短用户下载应用的时间，其中没用的功能用户可以不下载或等到以后需要时再下载。\n\n还有一个 Play Asset Delivery 功能，以动态方式交付大型资源可以减少用户等待时间，同时缩减交付成本。即使用 Play Asset Delivery 的游戏可通过纹理压缩格式作为交付条件，以便用户只获取适合其设备的资源，避免浪费空间或带宽。\n\n对于 AAB 的担忧\n\n虽然从结果看来，以 AAB 格式分发新应用对开发者和用户都有益处，但还是有部分人对此有些担忧。\n\n有人担心从 APK 变为 AAB 格式会太复杂。但谷歌表示：“对于大多数应用而言，构建 AAB 文件来替代 APK 文件仅需要少量工作。”它指出 App Bundle 是一种受主流构建工具支持的开源格式，因此在 Play Core 原生 SDK、Play Core Java SDK 和 Play Core Kotlin SDK 的助力下，无论用户偏好哪种编码环境，都可以轻松开始使用可选的高级 App Bundle 功能。此外，AAB 的要求仅适用于新应用，现有应用及面向特定 Google Play 用户的私人应用目前无需遵从此要求。\n\n有人对与谷歌共享私人签名密钥表示担忧（签名密钥是验证 APK 完整性的重要信息，谷歌从 ABB 中生成优化的 APK，因此签名密钥也将包含在 ABB 中），对此谷歌表示，所有“签名密钥都将存储在谷歌用来存储自己的密钥的同一基础设施上” ，因此开发者的私人签名密钥都会受到严密的安全保护。\n\n还有人担心因为 AAB 不能在 Google Play 以外的地方下载，会对如亚马逊应用商店等第三方应用商店造成很大影响。但据了解谷歌已经开发了一个名为 bundletool 的开源工具，允许开发人员从 AAB 包中创建 APK，因此想在第三方商店中发布 Android 应用程序的开发人员可以手动导出其应用的 APK 版本。\n\n那么对于谷歌的这一决定，你有什么看法吗？\n\n', '1413705681544794113', '2', '14', '2021-12-13 21:54:23', null, '2021-12-13');
INSERT INTO `bms_post` VALUES ('1413859730160156674', '在校大学生如何用编程赚钱？| 我的大学赚钱之路', '很多同学问我，大学生靠编程赚钱，只有靠外包一条路吗？\n\n我在读大学时，也是像你一样遍地找外包，想以项目练练手的同时赚点钱。\n\n可有的在我把项目做完，却一直拖着不给钱。也有还没开始做，就先让交保证金。\n\n钱没赚着，反被坑了两千块\n\n大学时代，我开过淘宝，做过项目，最后终于开窍，挣了近十万。\n\n这篇文章详细讲解了通过编程确定能挣钱的几个方向，这些都是我上学时确定挣过钱的，跟着学，你也可以。\n\n仔细看，如果你跟着去做了，挣不到钱的话，尽管来骂我！\n\n如果你通过这篇文章挣超过到了十万（如果真的用心做，十万其实不难的），记得回来还愿哦！\n\n这里全都教给大家\n\n文字很长，内容很多，原创不易，给个赞吧，小伙伴们！\n\n目录：（括号内是我当时挣到的钱，时间久远，记不太清，大概是这些）\n\n```\n做外包\n自己组团队 （一月三千）\n跟第三方合作\n计算机二级辅导 （收入三万）\n去找实习 （一月2500）\n如何做毕设 （收入四万）\n社会险恶，谨防被骗\n搞清楚自己要什么？\n```\n\n一、做外包\n\n我把这个列在第一位。因为这应该是所有人上来就想到的策略。通过百度搜索，大家可以搜得到很多外包平台。\n\n但这是我最不建议的！我就是这么被坑的！\n\n大家也可以注册试试，但极大的可能性，根本不会有单分配给你。\n\n当你在上面游荡几天，就会有网站运营来找你，让你充值，充值以后，推荐给你单子。\n\n有个网站，我充值了，推过来的单子，可我根本做不了。最后，钱没赚到，钱没了\n\n这里不能明说，说了就会被投诉名誉侵权，大家自己想，09年的事，到现在还活着的是哪个？\n\n如果有小伙们通过这条路赚到钱的，可以留言说说方法，反正，我感觉不太靠谱。\n\n下面我整理了国内外能找到的的19个外包平台，如果你有兴趣（不死心……），你可以试试\n\n搜了快一天才找了这么多，大家点个赞可好~~~\n\n```\n程序员客栈官网：https://www.proginn.com/\n码市官方网站：https://codemart.com/\n猪八戒官网：https://luoyang.zbj.com/\n开源众包官网：https://zb.oschina.net/\n智城外包网官方网站：http://www.taskcity.com/\n实现网官方网站：https://shixian.com/\n猿急送官方网站：https://www.yuanjisong.com/\n人人开发官方网站：http://rrkf.com/\n开发邦官方网站：https://www.kaifabang.com/\n电鸭社区官方网站：https://eleduck.com/\n快码官方网站：https://kuaimacode.com/\n英选官方网站：https://www.yingxuan.io/\nUpwork官方网站：https://www.upwork.com/\nFreelancer官方网站：https://www.freelance.com/\nDribbble官方网站：https://dribbble.com/jobs\nRemoteok官方网站：https://remoteok.io/\nToptal官方网站：https://www.toptal.com/\nAngelList官方网站：https://angel.co/remote\nTopcoder官方网站：https://www.topcoder.com\n```\n\n二、自己组团队\n\n外包平台不靠谱，那就自己干！\n\n我当时就是这么想的！\n\n所以，我开了淘宝店，帮人做网站。\n\n网上很多的网站模板。而很多公司做网站只是为了个门面，只是让别人知道，我们也有网站而已。\n\n所以，他们的要求一般很低。把模板给他们看看，可以的话，谈价格、布到服务器上、网站帮他们填充资料，就可以了。\n\n另外，如果你想长期把控他们的命脉，让他们每年都交钱。\n\n可以用你自己的阿里云账号给他们买空间/域名，每年收维护费\n\n这种活，我做了一年，一般一个网站收500/800的，很容易成交。每个月挣几千块，也够花了。\n\n后来，因为我改做其它的了，这个活就没再做了，不过到现在也是一个很好的方向，有兴趣的可以试试。\n三、计算机二级辅导\n\n每年学校里都会有很多非计算机的同学，想要报考计算机二级。考C语言、Java的尤其多。\n\n做为计算机的学生，这个机会，当然可以把握住啊。\n\n找几个志同道合的同学，大家一块到各个大学贴广告，发传单，找一些代理。\n\n现在市面上的培训，都是几千上万的。咱们就走低价，一个科目一千不多吧。\n\n周末组织大家到学校的教室里上课。\n\n这个活我也干过，不过我是当老师，招生的事是其它同学做的，最后我们分成。\n\n一个班五十人，都是能坐满的，我一天上三个班，上午场、下午场、晚上场\n\n一个班三小时，连上两天\n\n也就是那时候年轻，要是现在，早倒台了……\n\n最后结账时，一个班给我一万，总共分了我三万块。\n\n因为组织的同学是不透明的，也不是AA制的分钱，我也不知道他最终挣了多少钱，不过那年他买车了。我拿了三万块也挺开心的。\n\n这个活太累了，后面他们再开，我就没再参与了。\n\n有钱了嘛，交了个女朋友，嘿嘿\n\n四、跟第三方合作\n\n如果你本身找不到活，可以考虑跟有渠道的师兄师姐合作。\n\n现在很多同学都是有门路的，也有些同学在大学时代都有自己的工作室了。\n\n如果你身边有这样的学长，可以向他们靠靠近乎，参与他们当中，也是非常不错的。\n\n前段时间，有小伙伴跟我反馈说，自己兼职被骗了。\n\n因为我做公众号一年多了，而且我也有一些做接单的朋友，他们有时候单太多，做不完。\n\n所以，我就组了个群，让他们做不完的单，分给我们。\n\n做为组织者，我只是拉群，大家自行对接，我不会挣大家一分钱，刚组了一个多月，大家伙也接了几个单，我也比较有成就感。\n\n如果你身边有这样信得过的人，也是可以加入他们的。\n\n五、做毕设\n\n这个活，我也做过一段时间，因为我一般都是接的师兄师姐的毕设，钱少事多，来回改。而且毕设有严重的季节性，每年的12月到来年的3月份是高峰期。\n\n太过耗费时间，以至于这几个月除了做毕设，不会有任何的活动。\n\n读研以后，把更多的精力都放在学习上，就没在做了。\n\n我一直没觉得毕设的需求有多大，因为我一直认为绝大部分同学上大学应该都会好好学的，本科毕业设计本身不难，应该不会有多少人有这个需求。\n\n直到，有个同学问我做不做毕业设计，他毕业设计交了钱，人家给了源码不再管了。\n\n然后跟我说 ，他们班一半以上的毕业设计都是买的\n\n我感觉我现在还在拼命的打工，主要原因就是当年没一直干毕业设计……\n\n现在我也没时间弄了，这里教给大家怎么搞。\n\n1、找/买毕设\n\n我们绝大部分同学刚开始做是没有毕设的，怎么办？\n\n在网上去搜，都能找得到。\n\n缺点是，网上的资源有些是别人钓鱼用的，无论你怎么搭，总是有一两个模块总是跑不起来。\n\n不用怀疑，这是因为他们源码里这个模块的文件给删了。如果你仔细找找，其中应该还有个word文档，告诉你加某个QQ获取完整源码……\n\n不过搜确实是一个不要钱的路，也总能找到完整的源码\n\n另一条路，是收毕业设计。\n\n你准备个500块钱。向快要毕业的师兄师姐示个好，让他们把他们的毕业设计卖给你。反正他们已经毕业了，留着也用不着。\n\n如果他们的源码和论文也是买的话，给他50块钱，他们会非常乐意。甚至请杯奶茶，都能搞定。。。我当年给别人做的毕设原文件就是这么来的\n\n等你去收毕业设计以后就会发现，现在的毕业设计分为三类：网站、小程序、Android应用\n\n当然也有大数据、物联网类的毕设，这类太难了……专业搞毕业设计的他们一般都不做……当然，如果你刚好会，那可以做的\n\n第一次做，建议你以网站为主。因为小程序、Android应用很少能够直接拿来用的，每年的毕设要求都不同，是需要手动敲代码的。\n\n而网站就非常简单了，每年大部分都是某某信息管理系统、宠物领养系统、等等，就这么些玩意。\n\n我把我断断续续收集的两百套毕设工程源文件送给大家，可以去领。\n\n琢磨透，就能开始赚钱了。\n\n无论自己用还是代做毕设，又或者做为项目经验写进简历都是不错的选择。\n\n200套毕设源文件分享\n\n2、接单\n\n每年的12月份开始，是代做毕业设计的热门时间。\n\n做为新手，你完全可以先从本校学长开始，利用学长的资源，让他们在各个宿舍帮你发传单。一圈传单下来，至少接到十个单。\n\n要价不要太高，但也不要太低，一般500-1000为宜。\n\n大家一定要注意的是，尽快结单比一个单吃个饱更重要！\n\n所以，我们尽量只接那些你已经有源码和毕设的，随便改吧改吧就能交货的单。\n\n对于那些需要自己写代码实现的，尽量不要接，性价比太低。\n\n一星期搞不完一个单，还挣个毛线啊…………\n\n在熟练了以后，可以扩展到整个大学城，在其它大学招代理，跟他说怎么报价，成一个单给他分成。\n\n学生的圈子就那么大，而且呈现高聚集性。\n\n只要你一个单做的好，而且性价比高，等着吧，很可能他们班的单子都是你的！！！\n\n六、找实习\n\n去实习要交钱的，都是骗子！！！骗子！！！！骗子！！！！\n\n无论校招还是社招，实习经历都非常重要。实习过程中，能接触到项目的话，那实打实的项目经验就出来了。对于没有实习过的同学而言，那绝对是碾压性的优势。\n\n而且，实习一般一天至少200是有的。\n\n找个编程的实习其实并不容易，但实习确实是编程变现的一条路。\n1、找实习，无外乎三个途径：\n\n1)、实习平台、公众号\n\n一些找工作、找实习平台，可以直接去搜岗位，平台有很多，比如实习僧、应届生求职网、Boss直聘、刺猬实习、拉勾网、智联招聘、前程无忧等\n\n2）、企业官网/招聘专网\n\n各个大公司都有自己的官网，当有实习生岗位开放时，在官网上就会有对应入口。\n\n(注：如果你拿到的是这本书的电子版，这里的超链接应该是不可点击的，可以找到开篇底部列出的github地址，找到这本书的开源版本，里面都是可点击的。而且随着我阅历的增加，github上应该会更新其它文章，电子书很难及时触达你，感谢你的支持)\n\n比如：阿里巴巴集团招聘\n\n比如：腾讯集团\n\n比如：百度招聘\n\n下面列出了常见的互联网公司招聘地址，自己去看吧。\n\n百度招聘 / 加入字节跳动-招聘 / 京东招聘-首页 / 小米招聘 /华为/ 拼多多社会招聘 /VIVO/ OPPO/网易社会招聘 / 360招聘官网 / 新浪招聘 / 小红书招聘 /知乎- 社会招聘 / 携程旅行网-招聘中心 / 陌陌招聘 / 爱奇艺招聘-热门职位 / 58同城招聘 / 汽车之家招聘 / 虎牙直播 - 社会招聘 / 加入我们 - 斗鱼 / 欢聚时代招聘官网 / 人才招聘-51job / 猎豹移动网申系统--首页 / 搜狗招聘 / bilibili招聘 / 搜狐招聘官网/ 脉脉-成就职业梦想 / 滴滴招聘 / 快手招聘 / 美团点评招聘官网 / 中国平安-招聘官网 / 苏宁招聘官网 / 分众传媒招聘 / 好未来招聘 / 同程艺龙招聘系统 / 神州优车招聘系统 / 三七互娱招聘_三七互娱 / 用户网络招聘 / 众安保险公司招聘信息 / 巨人网络招聘官网 / 社会招聘网宿科技-全球领先的互联网基础服务平台 / 迅雷社会招聘 /贝壳找房校园招聘官网招聘系统 / 房天下招聘--你会爱上fang.com / 猎聘_2019秋季校园招聘信息 / 勇者招募计划-有胆你就来-咪咕文化 / 社会招聘_美图公司招聘官网 / 科大讯飞 | iFLYTEK - 用人工智能建设美好世界 / 南京途牛科技有限公司网申系统 / 美柚 | 女生助手 - 加入我们 / 丁香园最新招聘职位_丁香人才网 Careers at Microsoft | Microsoft jobs / 招贤纳才 - Apple (中国) /Careers Center | Samsung Singapore / Visa就职机会：Visa全球职位 / 台灣積體電路製造股份有限公司 / Jobs at Intel / Cisco Careers | Join the #WeAreCisco Tribe / IBM 如何成就你的事业巅峰 - 中国 / Qualcomm招聘_高通中国招聘 | Qualcomm / Working at Dell Careers / Sony China Career Portal / 海康威视招聘 / DJI大疆招聘 / 中兴通讯全球招聘门户 / Vivo招聘 / OPPO招聘官网 / 珠海格力电器股份有限公司招聘系统\n\n3)靠内推\n\n如果你有一些朋友、师兄、师姐已经就业到理想公司，可以与他们联系，如果他们公司有实习岗位的话，可以让他协助你走内部推荐流程。很多公司，内推同学是免简历筛选和笔试的，可以直接进面试。当然，也有些公司是无论是否内推，流程都一致。\n2、为什么我找不到实习？\n\n在找工作/找实习前，把你想找的工作的对应内容，先搞搞会，起码要入了门。啥都不会的小白，找不到实习是很正常的。\n\n我写了一篇文章：《对计算机专业来说学历真的重要吗？》火了以后，经常问我，我根据你的建议，到大三了去找实习，但根本找不着呀？怎么办？\n\n这里告诉大家实习为什么找不着：\n\n```\n首先，就单位而言，实习生留下来的概率极低，一般实习完就完了，培养你？图啥呢？\n其次，如果来的实习生啥都不会，得人教，得人带，干的活还问题多，与其招个实习生做业务，不如招个实习生打杂。\n最后，学生都想做业务，不想打杂，一听过去干的活是打杂的都不愿去。\n```\n\n所以，找不到实习的根本原因在于，你还是啥都不会！！！！\n\n就计算机专业而言，你要去找个敲代码的实习工作，首先，你做过项目吗？给你个需求，你能自己完成吗？\n\n更多的同学，是想借着实习学一把，从零基础入个门。就这样的，能找得到实习？工作单位好不容易把你培养会了，入了门了，毕业了，走了，人家图啥呢。\n\n所以，找工作/找实习前，先把自己技术练练好，入了门，能给人家直接干活，这样，人家才会要你！！！\n\n我精心整理了计算机各个方向的从入门、进阶、实战的视频课程和电子书，都是技术学习路上必备的经验，跟着视频学习是进步最快的，而且所有课程都有源码，直接跟着去学！！！\n\n资源没任何套路，跟着学去吧，记得帮我点赞就好\n\n入门、进阶、实战教程分享\n七、社会险恶，谨防被骗\n\n在某个回答的下方，有个这条回答\n\n试问，如果是你，你会去吗？\n\n招大学生合伙人的？？？？\n\n你怎么看？\n\n说到底，只不过想白嫖罢了，不想给钱，空手套白狼。\n\n创业，最重要的是什么？股权！为了控制股权，我当时创业的时候学了几个月的合伙人相关的知识，请教了不知道多少投资人。虽然最后，我们没干成，但从此可以看出，股权分配是创业中的重中之重。\n\n为了做一个项目，把股权拱手分配给一个大学生？\n\n咱们还在大学，说实话，即便学的再好，又能好到哪里去？\n\n不用我说，自己肯定是知道自己几斤几两的。\n\n所以，跟你讲股权，不讲钱的，都是骗子！！！！\n\n八、搞清楚自己要什么\n\n注意审题！大学生如何靠编程挣钱！\n\n如果重点在挣钱上，那完全没必要非要靠编程，挣钱的方法有很多。\n\n容易点的做家教、发传单、肯德基、送外卖等等，一些苦力活，都可以挣钱\n\n我曾经分享过一个小伙伴通过翻译网站赚钱的经历，有英语功底的可以去看\n\n《今年大三，兼职年入六万，方法路径分享》\n\n另外，知乎好物带货，也是一个不错的选择。我有朋友，有比较好的带货经验和文字功底，做了三个月，已经能月入过五千了。\n\n如果你的重点是放在编程上，只是想顺带挣点钱，那上面的这些方法足够你用了。\n\n', '1413706512109260801', '3', '20', '2021-12-13 21:56:42', null, '2021-12-13');
INSERT INTO `bms_post` VALUES ('1414171656744366082', 'vuex中mapGetters的使用及简单实现原理', '一.项目中的mapGetters\n在Vue项目的开发过程中必然会使用到vuex，对vue项目公用数据进行管理，从而解决组件之间数据相互通信的问题，如果不使用vuex，那么一些非父子组件之间的数据通信将会变得极为繁琐。\n\n1.这里首先说下项目中mapGetters的使用\n1\n先看下store部分目录结构\n\nindex.js文件\n\nimport Vue from \'vue\'\nimport Vuex from \'vuex\'\nimport book from \'./mudules/book\'\nimport getters from \'./getters\'\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\nmodules: {\nbook\n},\ngetters\n})\n\nbook.js文件\n\nconst book = {\nstate: {\nnumber: 1\n},\nmutations: {\nSET_NUMBER: (state, number) => {\nstate.number = number\n}\n},\nactions: {\nsetNumber: ({commit, state}, number) => {\n// console.log(state.number, number)\nreturn commit(\'SET_NUMBER\', number)\n}\n}\n}\n\nexport default book\ngetters文件\n\nconst getters = {\nnumber: state => state.book.number\n}\n\nexport default getters\n在vue组件中\n\nimport { mapGetters } from \'vuex\'\nexport default {\ncomputed: {\n...mapGetters([\'number\']),\n}，\nmounted () {\nthis.$store.dispatch(\'setNumber\',10).then(() => {\nconsole.log(this.number)\n})\n}\n}\n通过引入mapGetters 我们就可以轻松的取到vuex中存储的数据，从代码中可以看出，getters就类似于vue组件中的computed（计算属性），在组件中引入mapGetters就是将vuex中的数据映射到组件的计算属性当中，在组件不多，组件的数据通信不是很多的时候这样写看似将简单的东西复杂化了，但是在稍复杂点的项目中这样会极大的减少工作量，及组件之间数据传递的复杂程度。\n\n2.mapGetters简单实现原理\n在上面的代码中可能很多人在项目中用到过，但是对于其原理可能不是很理解。\n可能有一部人对于在组件计算属性中…mapGetters([‘number’]),不是很理解，下面就简单写一个方法实现类似的功能。\n\n在组件中\n\n```\nimport { mapGetters } from \'vuex\'export default {computed: {...mapGetters([\'number\']),//...fn([\'a\', \'b\', \'c\'])      //需要实现这样一个方法传入一个数组},methods: {menuClick (key) {if (key === 0) {this.$router.push(\'/ebook\')}else if (key === 1) {this.$router.push(\'/datachart\')}else{return}}},mounted () {this.$store.dispatch(\'setNumber\',10).then(() => {console.log(this.number)})// console.log(this.a,this.b,this.c)  // 在组件中可以直接通过this取到相应的值}\n```\n\n}\n我们在计算属性中添加\n…fn([‘a’, ‘b’])\n\n要求在组件中可以直接通过\nthis.a 和this.b 取到相应的值\n\nconst getters = {\na: () => 1,\nb: () => 2,\nc: () => 3\n}\nfunction fn (keys) {\nconst data = {}\nkeys.forEach(key => {\nif (getters.hasOwnProperty(key)) {\ndata[key] = getters[key]\n}\n});\nreturn data\n}\n\nimport { mapGetters } from \'vuex\'\nexport default {\ncomputed: {\n...mapGetters([\'number\']),\n...fn([\'a\', \'b\', \'c\'])\n},\nmounted () {\nthis.$store.dispatch(\'setNumber\',10).then(() => {\nconsole.log(this.number)\n})\nconsole.log(this.a,this.b,this.c)\n}\n}\n打印结果为1，2，3\n方法getters就类似于vuex中getters，\n方法fn与vuex中的mapGetters有着相似的功能，其实在vuex的底层中也是使用这样类似的原理，这样看上去是不是简单很多。\n\n注：（...）是es6新增语法展开运算符，大体有两个主要功能，收集参数与将数组表达式或者string在语法层面\n展开。这里不做过多介绍\n\n', '1413705681544794113', '1', '14', '2021-12-13 18:36:11', null, '2021-12-13');
INSERT INTO `bms_post` VALUES ('1414413526369320962', 'ai人工智能让女神_让女孩进入人工智能管道', 'ai人工智能让女神\n\n```\n##  缩小女孩的想象力差距 (Closing the Imagination Gap for Girls)\n\n\n The term artificial intelligence (AI) was coined 64 years ago at\n```\n\na scholarly conference. The AI field hasn’t remained the theoretical\nprovince of computer scientists and mathematicians; it now is a\npervasive part of everyday life. With a technology this powerful, it is\ncritical to include the perspectives of all women, including those from\nunderrepresented communities.\n\n```\n人工智能(AI)一词是64年前的一次学术会议上提出的。 人工智能领域还没有一直是计算机科学家和数学家的理论领域。 现在，它已成为日常生活的一部分。 借助如此强大的技术，至关重要的是要包括所有妇女的观点，包括来自代表性不足社区的妇女的观点。 \n\n\n AI applications — based on algorithms — are found in robotics,\n```\n\nmachine learning, natural language processing, machine vision, speech\nrecognition and more. These applications are found in homes, vehicles\nand myriad other aspects of daily life. Examples include facial\nrecognition; robots helping older people live more independently at\nhome; autonomous vehicles; smart watches; and drone safety systems.\n\n```\n基于算法的AI应用程序存在于机器人技术，机器学习，自然语言处理，机器视觉，语音识别等领域。 这些应用存在于房屋，车辆和日常生活的其他方面。 例子包括面部识别； 帮助老年人在家中独立生活的机器人； 自动驾驶汽车； 智能手表 和无人机安全系统。 \n\n\n AI applications must be able to reach conclusions and offer\n```\n\ninformation. Some require the capacity to sense emotions in order to\nrelate to people.\n\n```\nAI应用程序必须能够得出结论并提供信息。 有些人需要具有感知情感的能力才能与人交往。 \n\n\n Today, women are making their way into AI and leading the way\n```\n\nfor more girls to enter AI careers. They’re helping this burgeoning\nindustry progress and innovate in ways that otherwise might not be\npossible. In essence, adding women to the teams creating components of\nAI fundamentally changes the suitability and functionality of a product\nor service by eliminating biases and better reflecting the needs of a\nwider group of users.\n\n```\n如今，女性正在进入AI领域，并引导更多女孩进入AI职业。 他们正在帮助新兴的行业进步并以其他方式无法实现的方式进行创新。 本质上，通过消除偏见并更好地反映更广泛的用户需求，将女性加入创建AI组件的团队可以从根本上改变产品或服务的适用性和功能。 \n\n\n Taniya Mishra is director of Artificial Intelligence Research\n```\n\nand lead speech scientist at Affectiva, which originated at MIT. The\ncompany’s technology calibrates people’s speech patterns to recognize\nemotions.\n\n```\nTaniya Mishra是MIT的人工智能研究总监和Affectiva的首席语音科学家。 该公司的技术可以校准人们的语音模式以识别情绪。 \n\n\n Mishra offers some concrete examples of machine learning algorithms.\n\n\n  Mishra提供了一些机器学习算法的具体示例。 \n\n\n >\n```\n\n> ```\n> “Algorithms are a set of rules — logic — or a set of\n> ```\n> \n> instructions that you can give to a machine in order to get it to\n> accomplish a goal — to make it behave like a human being,” Mishra says.\n> “It could be any goal. It could be lifting a block from one place to\n> another. It could be understanding human emotion. All of these could be\n> the goals for designing a machine learning algorithm.”\n> \n> ```\n> “算法是一组规则-逻辑-或您可以赋予机器以使其达到目标的一组指令-使机器表现得像人一样，”米什拉说。 “这可能是任何目标。 可能是将一个方块从一个地方搬到另一个地方。 可能是了解人类的情感。 所有这些可能是设计机器学习算法的目标。” \n> \n> \n>   “The basic algorithm recipe tells the computer when to do ‘x,’\n> ```\n> \n> then when to do ‘y’ and then ‘z.’ For this process to work right, the\n> programmer must give the right instructions. For it to be inclusive, the\n> programmer must think of the entire humanity of users,” Mishra notes.\n> \n> ```\n> “基本算法配方告诉计算机何时执行\'x\'，然后何时执行\'y\'，然后执行\'z\'。 为了使此过程正常进行，程序员必须给出正确的说明。 为了使其具有包容性，程序员必须考虑用户的整个人性。” Mishra指出。\n> ```\n\n```\n##  **实地不平等** ( **Inequities in the Field** )\n\n\n When it comes to diversity, AI benefits from including women and\n```\n\nother underrepresented people. These voices must be included when\nwriting instructions or algorithms to power machine learning or other\nelements of AI. The data gathered to support AI must also come from\ndiverse groups of people, if the resulting algorithm is going to fully\nmeet its potential.\n\n```\n在多样性方面，人工智能可以从包括妇女和其他代表性不足的人中受益。 在编写指令或算法以增强机器学习或AI的其他元素时，必须包含这些声音。 如果最终的算法要完全满足其潜力，则为支持AI而收集的数据也必须来自不同的人群。 \n\n\n For example, a small homogenous group designing a facial\n```\n\nrecognition program for a large heterogeneous group will miss the target\nif data about a variety of faces from the larger group is not\nrepresented. In other words, the algorithm is only as bias-free as the\nsources of data and the data sets.\n\n```\n例如，如果未表示有关来自较大组的各种面部的数据，则为大型异构组设计面部识别程序的小型同质组将错过目标。 换句话说，该算法仅与数据源和数据集一样无偏差。 \n\n\n To be effective, creators of AI-related applications need to be as diverse as the people using them.\n\n\n  为了发挥作用，与AI相关的应用程序的创建者必须与使用它们的人一样多样化。 \n\n\n Eighteen-year-old Betelhem Dessie is founder and chief executive\n```\n\nofficer of iCog-Anyone Can Code in Ethiopia. She also co-founded Solve\nIT, which provides technical resources to develop local solutions for\ncommunity problems.\n\n```\n十八岁的Betelhem Dessie是埃塞俄比亚iCog-Anyone Can Code的创始人兼首席执行官。 她还与他人共同创立了Solve IT，该公司提供技术资源来开发针对社区问题的本地解决方案。 \n\n\n >\n```\n\n> ```\n> “As different AI tools were being developed, I observed a lack\n> ```\n> \n> of contributions from people of color and women,” Dessie notes. “The\n> solution, I thought, was having early childhood tech education — but\n> also inspiring girls who are already in the workforce to pursue these\n> types of career paths. The most rewarding part of my work is inspiring\n> others — particularly women and girls — to pursue careers in\n> technology.”\n> \n> ```\n> Dessie指出：“随着正在开发不同的AI工具，我发现有色人种和女性缺乏贡献。” “我认为解决方案是接受早期儿童技术教育，同时也激励已经在职场中寻求这种职业道路的女孩。 我工作中最有意义的部分是激励其他人，尤其是妇女和女孩，从事技术职业。”\n> ```\n\n```\nBut gender and diversity issues remain.\n\n\n  但是性别和多样性问题仍然存在。 \n\n\n A 2019 article written by Kari Paul for The Guardian states “the\n```\n\nlack of diversity in the AI field has reached ‘a moment of reckoning,’\naccording to findings by a New York University research center. The\nsurvey of more than 150 studies and reports, published by AI Now\nInstitute, found that ‘diversity disaster’ has contributed to flawed\nsystems that perpetuate gender and racial biases,” Paul writes.\n\n```\n纽约大学研究中心的调查结果显示，卡里·保罗(Kari\n```\n\nPaul)在2019年为《卫报》撰写的一篇文章指出，“人工智能领域缺乏多样性已经到了一个“时刻”。 由AI Now\nInstitute发表的对150多项研究和报告的调查发现，“多样性灾难”助长了存在缺陷的系统，使性别和种族偏见长期存在。\n\n```\n##  **有什么解决方案？** ( **What Are the Solutions?** )\n\n\n One remedy is educating girls — including girls of color —\n```\n\nsooner and more widely about the field and making appropriate\neducational opportunities and career guidance accessible to them early\non.\n\n```\n一种补救措施是对女孩(包括有色女孩)进行早期和广泛的有关领域的教育，并尽早为她们提供适当的教育机会和职业指导。 \n\n\n Mastery of complex subjects is required, so girls must continue\n```\n\nbuilding on their basic math and science education, and intensify their\nfocus as early as seventh grade. High school and certainly college may\nbe too late to capture their interest so they can acquire the needed\nfoundation.\n\n```\n必须精通复杂的科目，因此女孩必须继续建立基础数学和科学教育，并从七年级开始加强学习重点。 高中，当然还有大学，可能为时已晚，无法引起他们的兴趣，因此他们可以获得所需的基础。 \n\n\n Girls interested in AI will need to write code, algorithms and\n```\n\nsource data sets. Beyond that, they will need to understand and\neliminate bias in data sets, as well as in applications designed to\nserve humanity.\n\n```\n对AI感兴趣的女孩将需要编写代码，算法和源数据集。 除此之外，他们还需要理解并消除数据集以及为人类服务的应用程序中的偏见。 \n\n\n Along with a rigorous early academic foundation, girls must\n```\n\ndevelop social and emotional learning skills to help fuel their careers.\nThese skills will prove beneficial whether they are leading a team or a\ncompany or programming soft skills into a robot.\n\n```\n除了严格的早期学术基础之外，女孩还必须发展社交和情感学习技能，以助其事业发展​​。 无论是带领团队或公司，还是将软技能编程为机器人，这些技能都将证明是有益的。 \n\n\n A proven method for inspiring girls is to bring female role\n```\n\nmodels working in AI into your classroom. Give girls a chance to ask\nthese experts questions about their careers and personal stories. One\nway to start your search for experts is to inquire at universities and\nbusinesses from your local community; network with those professionals\nto build your sources.\n\n```\n激励女孩的一种行之有效的方法是将在AI中工作的女性榜样带入课堂。 让女孩有机会向这些专家询问有关其职业和个人故事的问题。 开始寻找专家的一种方法是向当地社区的大学和企业打听； 与这些专业人员建立联系以建立您的资源。 \n\n\n Girls’ visions for the future are boosted when they’re\n```\n\nintroduced to female role models who demonstrate rewarding careers in\nthe AI field and show that girls can excel in this arena.\n\n```\n将女性的榜样介绍给女性榜样，可以提高女孩对未来的看法，这些榜样在AI领域表现出可喜的职业，并表明女孩可以在这个领域脱颖而出。 \n\n\n As women enter the profession and assume leadership roles,\n```\n\nsociety is seeing the advantages of perspectives they bring to AI\nsystems.\n\n```\n随着女性进入该行业并担任领导角色，社会正在看到她们为AI系统带来的观点的优势。 \n\n\n For example, Mishra builds new systems that enhance people’s\n```\n\nlives and give them a positive experience of interacting with\ntechnology. “AI is ingrained into every aspect of our lives now and will\nbe even more so in the future,” says Mishra. Her advice to girls is to\n“dream big: ambition is attractive and inspires those around you.”\n\n```\n例如，米什拉(Mishra)建立了新的系统来改善人们的生活，并为他们提供与技术互动的积极体验。 米什拉说：“人工智能已经根深蒂固，现在已经渗透到我们生活的方方面面，将来会更加如此。” 她对女孩的建议是“大胆梦想：雄心勃勃，会激发周围的人。” \n *About the author –– Linda Calhoun is the founder and executive producer of *[*Career Girls*](https://www.careergirls.org/)*. Career Girls is a nonprofit organization dedicated to closing the imagination gap for girls around the world.*\n\n\n  *作者简介– Linda Calhoun是《* [*职业女孩》*](https://www.careergirls.org/) *的创始人兼执行制片人* *。* *职业女孩组织是一个非盈利性组织，致力于消除世界各地女孩的想象力鸿沟。*\n```\n\n', '1413706063062880257', '0', '14', '2021-12-14 10:37:17', null, '2021-12-14');
INSERT INTO `bms_post` VALUES ('1414427942484520961', '如何成为一名AI人工智能算法工程师2？', '经常有朋友私信问，如何学python呀，如何敲代码呀，如何进入AI行业呀？\n\n正好回头看看自己这一年走过的路，进行一次经验总结。\n\n来看看你距离成为一名AI工程师还有多远吧~\n\n:star:具体内容：\n\n我是因为什么开始接触敲代码\n\n人工智能/机器学习/深度学习\n\n自学如何寻找学习资料\n\n如何选择编程语言/框架\n\n校招/社招/实习/面试经验\n\n一碗鸡汤\n\n:star:声明：\n\n本篇内容均属于个人观点，建议采纳对自己有用的经验，如有疏漏，欢迎指正，共同进步！\n\n2017年5月开始第一份实习 / 2017年7月开始学敲代码 / 2017年11月硕士毕业\n\n擅长的编程语言：R / Python\n\n不花钱报班，全靠自学，最初是因为穷，后来发现“开源”的世界真是太美好了！\n\n![如何成为一名AI人工智能算法工程师？](http://p1.pstatp.com/large/pgc-image/bad5aae56c2647478fc6826ca201001e)\n\n**我是因为什么开始接触敲代码？**\n\n**我的第一个模型是什么**\n\n由于本科是数学，研究生是量化分析，第一份实习是一家金融科技公司，开始接触所谓的“Fintech”\n\n第一个任务就是做客户的信用评分卡模型，目的给每个用户打一个信用分数，类似支付宝的芝麻信用分。这是银行标配的一个模型，最常见最传统的算法用的就是 **逻辑回归** 。\n\n在课堂上使用的工具是SAS，SPSS，属于有操作界面的，菜单非常齐全，只需要鼠标点一点就能建模，很好上手。但是SAS这些要付钱的，年费还是相当的贵，所以深圳大部分公司进行数据分析和建模工作都选择开源免费的R语言或者Python。这就体现了掌握一门编程语言的重要性。\n\n虽然说是建模任务，但是前三个月跟建模基本都扯不上边。都在做数据清洗，表格整理（摊手），都在library各种包，用的最多的可能是data.table和dplyr。没办法，很多模型都有包可以直接调用，是最简单的环节了。其实一开始，我一直在犯很低级的错误，各种报错，没有library啦，标点符号没打对啦，各种很low的错误犯了一次又一次，而且连报错的内容都不会看，不知道怎么去改正。如果你也像我一样， **真的请不要灰心** ，我就是这样走过来的。对着错误一个个去解决就好了~\n\n当时什么都不知道的时候，觉得真难呀，每个环节都有那么多细节要照顾，要学的那么多，做完一个还有一个，还要理解业务含义。但是当完整的做一遍之后再回头，就会觉得，其实，也没那么难嘛~\n\n![如何成为一名AI人工智能算法工程师？](http://p1.pstatp.com/large/pgc-image/ee5c26c7d4bc42a89799b989ebed1f59)\n\n**敲代码容易吗？**\n\n因为我不是计算机专业的，所以基本上属于没怎么敲过代码的那种。\n\n后来发现程序员也有好多种类的，前端后端等，因此敲的代码种类也很多，才会有几十种的编程语言，下图是一些这几年的主流语言。\n\n![如何成为一名AI人工智能算法工程师？](http://p3.pstatp.com/large/pgc-image/2ec0142b49a54ca6ba533253865617c4)\n\n实习时我一直被队友嫌弃很蠢，而且一开始敲的东西怎么也运行不通，运行出来的都是鬼结果。有n次想放弃的念头，“我干嘛一定要敲这玩意儿？”，但也有n+1次想坚持的理由，因为我真的喜欢我正在做的事。为什么用“坚持”，因为真的不容易。不难，但真的需要有耐心。\n\n一开始我的状态就是一行行代码的运行，一个个命令的熟悉，反复看，反复运行。\n\n* **从敲出第一行代码到敲出第一个完整的模型花了3个月**\n* 学习XGBoost，光是理论学了3个月，因为前期铺垫要学的还有adaboost/gbdt和各种机器学习的知识模块\n* **从R切换到python花了1个月**\n* 从机器学习(Machine Learning)切换到自动机器学习(Auto Machine Learning)花了2个月\n* **从NLP零基础到搭建一个智能问答机器人花了1个月**\n\n从一年前的“什么是过拟合，什么是交叉检验，损失函数有哪些”到后来参加全球人工智能峰会时都能听懂的七七八八，会觉得，努力没有白费呀！\n\n![如何成为一名AI人工智能算法工程师？](http://p1.pstatp.com/large/pgc-image/08da5606681149658ee82b1124824bfa)\n\n可以看出，经过前面的积累，后面会学的越来越快。\n\n慢慢的就从一开始的那种“唉，怎么又报错啊，好挫败”的心态变成现在的“啊？没error？感觉不对啊，再查验一遍吧”这种抖M倾向的人。代码虐我千百遍，我已经被磨的没有了脾气。\n\n已经有几个朋友说想转行了，我何曾没想过，只是不知不觉中坚持了下来而已。因为热爱，越虐越停不下来\n\n**小结**\n\n**设定一个非常清晰的目标**\n\n为什么第一个写：“我是因为什么开始敲代码的”，因为动机真的非常重要！\n\n所以，很多人在问我“如何学python？”这种问题时，我的第一回答都是“你学python用来干嘛？”\n\n在学校也敲打过python，做个爬虫demo什么的，因为目的性不强没多久就放一边了。清晰的目标就比如说你要做NLP，你要知道NLP的应用有智能问答，机器翻译，搜索引擎等等。然后如果你要做智能问答你要知道现在最发达的技术是深度学习，使用的算法有RNN/LSTM/Seq2Seq/等等一系列。而我的清晰目标是在实习的时候给我的任务。当任务很明确的时候，所需要的语言就明确了，所要学习的算法也就明确了，很多东西就顺理成章了不用一头乱撞了。\n\n**从金融到科技**\n\nAI的应用范围很广，每一个研究方向都是无穷尽的。由于金融公司很少与图像处理，NLP等技术会有交集，而我强大的好奇心让我决定去纯粹的科技公司一探究竟。目前已投身于智能家居，目标是Javis\n\n**人工智能/机器学习/深度学习**\n\n我经常在公交的广告牌上看见这些词，好像哪家公司没有这个技术就落后了似的。更多的还有强化学习，迁移学习，增量学习等各种学习。\n\n**这些词儿之间到底什么关系**\n\n机器学习是人工智能的一种，深度学习是机器学习的一种。 **学AI先学机器学习** 。\n\n![如何成为一名AI人工智能算法工程师？](http://p3.pstatp.com/large/pgc-image/b5199c1f23a4448d9fcf15c0b1315c34)\n\n**计算机的“算法” 与 数学的“算法” 的区别**\n\n理论知识对于AI算法工程师极其重要。敲代码只是思路的一个实现过程。这里的“算法”和计算机CS的“算法”还不太一样，AI算法是偏数学推导的，所以数学底子还是需要点的，学的越深，要求越高。面试的时候，很少让手写代码，90%都是在问模型抠算法细节。\n\n在学校我是一个不爱记笔记的人，甚至是一个不爱上课的人。但是自从入了机器学习的坑后，笔记写的飞起~\n\n![如何成为一名AI人工智能算法工程师？](http://p1.pstatp.com/large/pgc-image/2f6d1cb7366845f08c0583975642fb7a)\n\n![如何成为一名AI人工智能算法工程师？](http://p1.pstatp.com/large/pgc-image/84132e9a823144d8a2f8c5ad343cb780)\n\n**机器学习的框架**\n\n按照数据集有没有Y值可以将机器学习分为监督学习、半监督学习和无监督学习。监督学习是分类算法，无监督学习是聚类算法。\n\n![如何成为一名AI人工智能算法工程师？](http://p3.pstatp.com/large/pgc-image/eb84d6c703b84ebf9e5f9918df22e3a5)\n\n机器学习的通用流程和相关技术如下图：\n\n![如何成为一名AI人工智能算法工程师？](http://p1.pstatp.com/large/pgc-image/af68c897a46942e2992ff7cca9c039bd)\n\nML这棵树还可以有更多的分支。先有个整体感受，再一个一个的解决掉。这里的知识点也是面试最爱问的几个，是重点呀！面试过的同学应该都不陌生了。\n\n**机器学习如何入门**\n\n机器学习之大，初学者都无从下手。说白了，机器学习就是各种模型做预测，那么就需要有数据，要想有好的效果，就要把原始的脏数据洗干净了才能用。数据内隐藏的信息有时候是肉眼不可见的，那么就需要一些相关技巧来把有用信息挖出来。所有绞尽脑汁使用的技巧，都是为了能预测的更准确。但是谁也没办法做到百分百的命中。\n\n这里简单介绍下机器学习的三大块：传统的机器学习ML、图像处理CV、自然语言处理NLP\n\n再推荐一个入门神器：\n\n**Kaggle（www.kaggle.com）**\n\n这是一个世界级的最权威的机器学习比赛，已被谷歌收购。上面的赛题不仅很有代表性，还有很多免费的优秀的数据集供你使用，要知道收集数据是机器学习的第一大难题，它就帮你解决了。入门不用立马参加比赛，把数据下载下来，尽情折腾就好了，要是没有思路，去网上搜别人的解题笔记和代码借鉴一下也很美好~因为这是大家都争相打榜的比赛，所以你并不孤单。\n\n**ML入门该参加的赛题（Titanic）**\n\n![如何成为一名AI人工智能算法工程师？](http://p3.pstatp.com/large/pgc-image/e5054824be994ab7b0c5c343ac929459)\n\n**图像入门该参加的赛题（数字识别）**\n\n![如何成为一名AI人工智能算法工程师？](http://p3.pstatp.com/large/pgc-image/5e74208b2b26426fba4a1ee2ca31cd07)\n\n**NLP入门该参加的赛题（情感分析、quora问句语义匹配）**\n\n![如何成为一名AI人工智能算法工程师？](http://p3.pstatp.com/large/pgc-image/e03f7500fbb2447c817570d473675876)\n\n![如何成为一名AI人工智能算法工程师？](http://p3.pstatp.com/large/pgc-image/fb9bc920a6314b5ebd01e9b8c953507c)\n\n等做完第一个titanic的比赛应该就有点感觉了。上面4个比赛我都做过，觉得很经典，很适合入门。\n\n**深度学习的入门算法有哪些**\n\n如今的样本输入可以是文字，可以是图像，可以是数字。\n\n深度学习是跟着图像处理火起来的。甚至现在这个概念都火过了“机器学习”。\n\n深度学习的算法主要都是神经网络系列。入门推荐CNN(卷积神经网络)的一系列：\n\nLeNet5\n\nAlexNet\n\nVGG\n\nGoogleNet\n\nResNet\n\n**自学如何寻找学习资料？**\n\n**开源的世界，美好的世界:heart:**\n\n“开源”，我的爱！代码届里开源的中心思想就是，share and free\n\n对于机器学习，网上的社区氛围特别好，分享的很多很全面，而且MLer都非常乐于助人。\n\n介绍几个我经常逛的社区，论坛，和网页：\n\n**kaggle （www.kaggle.com）**\n\n全球最权威的机器学习比赛，已被谷歌收购。赛题覆盖传统机器学习、nlp、图像处理等，而且都是很实际的问题，来自各行各业。kaggle是数一数二完善的ML社区了，赛题开放的数据集就很有用，非常适合新手练手。对优秀的kaggler也提供工作机会。\n\n**github（www.github.com）**\n\n全球最大同性交友网站，适合搜项目，开源大社区，大家一起看星星，看issue~\n\n**StackOverFlow（www.stackoverflow.com）**\n\n代码报错找它，代码不会敲找它！所有与代码相关的坑，基本都有人踩过啦\n\n**csdn（www.csdn.net）**\n\n最接地气的博客聚集地，最常看的网页之一，一般用来搜索细节知识点或者代码报错时\n\n**sklearn（scikit-learn.org/stable）**\n\n专业做机器学习100年！各算法各技巧的例子code应有尽有\n\n**medium（medium.com）**\n\n创办人是Twitter的创始人，推崇优质内容，国内很多AI公众大号的搬运都来自于这里，medium里每个作者都有自己独特的见解，值得学习和开拓眼界，需要科学上网\n\n**towards data science（towardsdatascience.com）**\n\n与medium很像，需要科学上网\n\n**google AI blog（ai.googleblog.com）**\n\n谷歌的AI团队维护的博客，每天至少更新一篇技术博客。刚在上海开的谷歌开发者大会宣布将会免费开放机器学习课程，值得关注一下，毕竟是AI巨头\n\n**各种大神的技术博客/个人网站**\n\n有很多的网站，会不定期的更新在我的个人博客里\n\n**有口碑的AI公开课平台**\n\n首先说明我没有上课，也没有报班，属于个人学习习惯问题。但考虑到学习差异性，所以还是总结了口碑排名靠前的课程系列。前提，需要有一定数学基础，没有的可以顺便补一补。\n\n**coursera（www.coursera.org/browse）**\n\n**吴恩达(Andrew Ng)机器学习**\n\n**deeplearning.ai（www.deeplearning.ai）**\n\n**fast.ai（www.fast.ai）**\n\n专注于深度学习。Fast.ai的创始人就蛮有意思的，是横扫kaggle图像处理的高手，不摆架子，也不故弄玄虚。中心思想就是深度学习很简单，不要怕。fast.ai有博客和社区。Jeremy和Rachel鼓励撰写博客，构建项目，在会议中进行讨论等活动，以实力来代替传统证书的证明作用。\n\n**udacity（in.udacity.com）**\n\n有中文版，课程覆盖编程基础，机器学习，深度学习等。\n\n**网易云课堂**\n\n**碎片时间**\n\n科技圈也是有潮流要赶的，等你入坑就知道。\n\n追最新的论文，最新的算法，最新的比赛，以及AI圈的网红是哪些~有条件的开个twitter，平时娱乐看看机器学习板块还是蛮有意思的，有很多自嘲的漫画~\n\n推荐几个我超爱看的AI主题美剧\n\n**硅谷** （强推！简直是我日常生活，太有共鸣了~下饭剧）\n\n**西部世界** （看的时候不要学我一直在思考如何实现这个那个技术）\n\n**实用的小技巧**\n\n浏览器首推 chrome\n\n当阅读英文网页呼吸困难时，右击选择“翻成中文（简体）”\n\n考过雅思和GMAT，曾经我也是一个热爱英文的孩子，如今跪倒在海量技术文档和文献里苟活\n\n搜索问题一定用google，如果没解决是你的问题不是google的锅\n\nbaidu？？？ummm......别为难我......很少用\n\n学会提问很重要，搜索格式推荐\n\n语言+问题，例如：python how to convert a list to a dataframe\n\n直接复制错误信息，例如：ValueError: No variables to save...\n\n请把所有的问题往上抛，网上查比问人快！总是问别人会引起关系破裂的~\n\n学会顺藤摸瓜\n\n当你读到一个非常不错的技术文档时，看完别急着关掉。这可能是一个个人网站，去观察菜单栏里有没有【About】选项。或者这也可能是一个优秀的社区，看看有没有【Home】选项，去看看po的其它的文章。\n\n很多优秀网站都是英文，科学上网必不可少\n\n学习费用不来自课程，可能来自于硬件要求，学生党要利用好学校资源\n\n**小结**\n\n虽然说了那么多，但还是要说 **请放弃海量资料！用多少，找多少就好了！（别把这句话当耳旁风** ）\n\n**资料不在量多而在于内容是有质量保证的** 。很多课程或者公众号只管塞知识，你有疑问它也解答不了的时候，这样出来的效果不好，就像一个模型 **只管训练，却不验证，就是耍流氓** 。\n\n**如何选择编程语言/框架**\n\n**首选英语！！！（咳咳，我认真的）**\n\n说到底，语言只是工具，不去盲目的追求任何一种技术。根据任务来选择语言，不一样的程序员选择不一样的编程语言。很多人最后不是把重点放在能力而是炫工具，那就有点走偏了。\n\n据观察，在机器学习组里R和Python是使用率最高的两门语言，一般你哪个用的顺就用哪个，只要能达到效果就行，除非强制规定。\n\n我使用之后的感受是，**人生苦短，我用python**\n\n**用python建个模型到底多难？**\n\n算法任务大致分为两种，一种是普通算法工程师做的“调包、调参”，另一种是高级算法工程师做的，可以自己创建一个算法或者能灵活修改别人的算法。\n\n先说说建个模到底有多简单吧。\n\n有优秀的算法封装框架\n\ntensorflow / caffe / keras /...\n\nAuto ML 是不可阻挡的一个方向\n\nAuto ML(auto machine\nlearning)，自动机器学习。就是你只管丢进去数据，坐等跑出结果来就行了。前一阵子谷歌的CloudML炒的很火，愿景是让每个人都能建模，但毕竟这种服务是要钱的。所以我研究了下开源的auto\nsklearn框架的代码，发现了什么呢？建模到底有多简单呢？就，简单到4行代码就可能打败10年工作经验的建模师。\n\n再说回来，如果你自己根本不知道自己在做什么，**只能跑出来一个你不能负责的结果，就是很糟糕**的，那还不是一个合格的算法工程师。**你的模型必须像你亲生的那样。但是，只要你想，绝对能做到的！**\n\n**学习python电脑上要装哪些东西**\n\nAnaconda\n\n对，就是这么简单粗暴，装这个就ok了\n\n学python的应该都会面临到底是python2还是python3的抉择吧。语言版本和环境真的很让人头疼，但是Anaconda惊艳到我了，就是可以自定义python环境，你可以左手py2右手py3\n\n**推荐几个python的IDE**\n\nSpyder\n\nAnaconda自带的ide。界面排版与Rstudio和Matlab很相似。输入什么就输出什么结果，适合分析工作，我写小功能的时候很喜欢用。\n\nJupyter Notebook\n\nAnaconda自带的ide，属于web界面的。当你程序跑在虚拟机，想调代码的时候适合用。\n\nPyCharm\n\n对于写项目的，或者代码走读的比较友好。当你需要写好多python文件互相import时，特别好用。\n\n**我的笔记本配置**\n\n（不考虑经济约束的请忽略这条）\n\n牌子+型号：ThinkPad X1 Carbon\n\n推荐配置：i7+16G内存+256G(或更多)硬盘\n\n系统推荐：Linux，因为开源，有空可以玩玩\n\n:zap:**校招/社招/实习/面试经验**\n\n如何安排校招\n\n大厂的开放时间会比较早，密切关注网申时间节点：\n\n2019届的秋招：2019年7月 - 2019年11月\n\n2020届的春招：2020年2月 - 2020年4月\n\n2020届的暑期实习：2020年3月 - 2020年5月\n\n2020届的秋招：2020年7月 - 2020年11月\n\n（以此类推）\n\n手撕代码能力\n\n建议提早半年开始准备。我的代码也是从实习开始敲起，敲了半年才觉得下手如有神哈哈。不要做没实际意义的课后题，也不要照着书本例题敲，敲完你就忘了，书本这些都是已经排除万难的东西，得不到什么成长。\n\n入门修炼：全国大学生数学建模竞赛、全美大学生数学建模竞赛、kaggle、天池…\n\n项目经历/实习经历\n\n如果明确自己的职业方向为人工智能/数据挖掘类的，请不要浪费时间去申请其他与技术无关的实习。端茶送水，外卖跑腿，打印纸并不能帮你。当时由于身边同学都断断续续出去实习，面前有一份大厂行政的实习，我…竟然犹豫了一下，好在也还是拒绝了。\n\n尽量选择大厂的技术实习，毕竟以后想进去会更难。但是不要因为一个月拿3000块就只干3000块的活。把整个项目跟下来，了解框架的架构，优化的方向，多去尝试，就算加班（加班在深圳很正常）也是你赚到，思考如何简化重复性工作，去尝试了解自己部门和其他部门的工作内容与方向，了解的越多你对自己想做的事情了解的也越多。我实习做的评分卡模型，除了传统逻辑回归，也尝试新的XGB等等，而且虽然别人也在做，但是私下自己会把整个模型写一遍，包含数据清洗和模型调优等，这样对业务的了解也更透彻，面试起来所有的细节都是亲手做过的，也就比较顺了。\n\n如果没有实习在手，世界给我们数据挖掘选手的大门还是敞开着的。kaggle上有专门给数据挖掘入门者的练习场。相关的比赛还有很多，包括腾讯、阿里等大厂也时不时会发布算法大赛，目测这样的算法大赛只会越来越多，你坚持做完一个项目，你在平台上还可以得到相关名次，名次越靠前越有利哈哈哈这是废话。\n\nBAT常见的面试题（不分先后）\n\n自我介绍/项目介绍\n\n类别不均衡如何处理\n\n数据标准化有哪些方法/正则化如何实现/onehot原理\n\n为什么XGB比GBDT好\n\n数据清洗的方法有哪些/数据清洗步骤\n\n缺失值填充方式有哪些\n\n变量筛选有哪些方法\n\n信息增益的计算公式\n\n样本量很少情况下如何建模\n\n交叉检验的实现\n\n决策树如何剪枝\n\nWOE/IV值计算公式\n\n分箱有哪些方法/分箱原理是什么\n\n手推SVM：目标函数，计算逻辑，公式都写出来，平面与非平面\n\n核函数有哪些\n\nXGB原理介绍/参数介绍/决策树原理介绍/决策树的优点\n\nLinux/C/Java熟悉程度\n\n过拟合如何解决\n\n平时通过什么渠道学习机器学习（好问题值得好好准备）\n\n决策树先剪枝还是后剪枝好\n\n损失函数有哪些\n\n偏向做数据挖掘还是算法研究（好问题）\n\nbagging与boosting的区别\n\n模型评估指标有哪些\n\n解释模型复杂度/模型复杂度与什么有关\n\n说出一个聚类算法\n\nROC计算逻辑\n\n如何判断一个模型中的变量太多\n\n决策树与其他模型的损失函数、复杂度的比较\n\n决策树能否有非数值型变量\n\n决策树与神经网络的区别与优缺点对比\n\n数据结构有哪些\n\nmodel ensembling的方法有哪些\n\n小结\n\n问题是散的，知识是有关联的，学习的时候要从大框架学到小细节。\n\n没事多逛逛招聘网站看看招聘需求，了解市场的需求到底是什么样的。时代变化很快，捕捉信息的能力要锻炼出来。你可以关注的点有：职业名/职业方向/需要会什么编程语言/需要会什么算法/薪资/...\n\n每个面试的结尾，面试官会问你有没有什么想问的，请注意这个问题也很关键。\n\n比如：这个小组目前在做什么项目/实现项目主要用什么语言和算法/…\n\n尽量不要问加不加班，有没有加班费之类的，别问我为什么这么说（摊手）\n\n在面试中遇到不理解的，比如C++语法不懂，可以问这个C++具体在项目中实现什么功能。 **如果你提出好问题，能再次引起面试官对你的兴趣** ，那就能增加面试成功率。\n\n应届生就好好准备校招，别懒，别怕输，别怕被拒，从哪里跌倒从哪里起来。社招不是你能招呼的，会更挫败，因为你什么也没做过。\n\n虽然是做技术的，但是日常social一下还是收益很大的。实习的时候，也要与周围同事和平相处，尤其是老大哥们，也许哪天他就帮你内推大厂去了。内推你能知道意想不到的信息，面试官，岗位需求，最近在做什么项目之类的。\n\n**挑选给你机会的公司，不要浪费自己的时间** 。不要每家都去，去之前了解这家公司与你的 **匹配度** 。\n\n尤其社招，你一改动简历就很多人给你打电话，你要有策略的去进行面试，把握总结每个机会。像我就是东一榔头西一榔头的，好多都是止步于第一面，就没回信儿了，因为每次面完没有好好反思总结，等下次再遇到这问题还是抓瞎，十分消耗自己的时间和信心。\n\n**一碗鸡汤**\n\n**一切才刚刚开始，别着急**\n\nAI才刚刚起步，为什么呢？因为上数学课的时候，课本上都是柯西，牛顿，高斯等等，感觉他们活在遥远的时代，很有陌生感。但是现在，我每天用的模型是比我没大几岁的陈天奇创造出来的，我甚至follow他的社交账号，他就鲜活在我的世界里，这种感觉，很奇妙。每次查论文查文献的时候，看2017年出来的都觉得晚了，懊悔自己怎么学的这么慢，看2018年2月出来的才心里有点安慰。这个证明，你在时代发展的浪潮上，也是一切刚刚起步的证明。机遇与挑战并肩出现的时候，是你离创造历史最近的时候。而所谓的风口所谓的浪尖都不重要， **重要的是，因为你喜欢** 。\n\n**找一件可以坚持的事，不要停止去寻找的脚步**\n\n当人做喜欢的事情时，会发光呀！\n\n当你因为真的热爱某件事，而不断接近它的时候，你的灵魂像是被上帝指点了迷津，受到了指示，受到了召唤。你会很自然的知道该做什么，你想做什么，好像生而为了这件事而来。你有时候自己都想不明白为什么做这件事。看过月亮与六便士的应该懂这种使命感~\n\n![如何成为一名AI人工智能算法工程师？](http://p1.pstatp.com/large/pgc-image/893ca2b92fdf4bed9d4fa606f1a7e879)\n\n我不是属于聪明的那类人，我是属于比较倔的那种。就是只要我认定的，我认定到底。天知道我有多少次怀疑过自己，有多少次想放弃，但我还是选择咬牙向前，选择相信自己。坚持的意义就在这里。\n\n', '1414426801273122818', '1', '11', '2021-12-14 11:34:34', null, '2021-12-14');
INSERT INTO `bms_post` VALUES ('1414919568994676737', '如何运行SpringBoot项目', '最近在Ecplise上面写了一个简单的Spring Boot的测试项目，Spring Boot里面是有主函数的：\n\n我们知道的是在Ecplise上面找到这个主函数然后run as->java Application 就可以了\n\n但是总不能一直不脱离Ecplise，总要出来自己单练的\n\n第一步:我就新建的一个文件夹boottest，然后右键导出整个工程：\n\n导出的是jar包，然后我们看网上介绍的SpringBoot启动的方法，就兴致勃勃的去启动SpringBoot\n\n第二步:将导出的jar包解压到我刚才创建的文件夹：\n\n现在我们的项目就在这个地方，是时候启动这个项目了\n\n如何启动：\n\n肯定是用命令行了cmd\n\n第三步：进入自己创建的文件夹，然后执行mvn install\n\n然后到从文件夹里面可以看到你的target里面打开有一个jar，执行这个jar\n\n这样项目就可以正常的启动了\n\n....\n\n然后我们输入地址可以正常的访问了\n\n其实在启动的过程中也不是一帆风顺的，期间在执行最后一步：java -jar  MySpringBoot-0.0.1-SNAPSHOT.jar的时候遇到的问题是：\nSpring Boot:jar中没有主清单属性\n\n如何解决的呢:\n\nhttps://blog.csdn.net/u010429286/article/details/79085212\n\n这篇博客给出了很好的解释\n\n下面时候我的pom.xml 文件可以做一个简单的参考\n\n```\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n	xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n	<modelVersion>4.0.0</modelVersion>\n	<groupId>com.wdg.boot</groupId>\n	<artifactId>MySpringBoot</artifactId>\n	<version>0.0.1-SNAPSHOT</version>\n	<dependencies>\n		<dependency>\n			<groupId>org.springframework.boot</groupId>\n			<artifactId>spring-boot-starter-web</artifactId>\n			<version>2.0.3.RELEASE</version>\n		</dependency>\n		<dependency>\n			<groupId>org.springframework.boot</groupId>\n			<artifactId>spring-boot</artifactId>\n			<version>2.0.3.RELEASE</version>\n		</dependency>\n		<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-thymeleaf -->\n		<dependency>\n			<groupId>org.springframework.boot</groupId>\n			<artifactId>spring-boot-starter-thymeleaf</artifactId>\n			<version>2.0.3.RELEASE</version>\n		</dependency>\n	</dependencies>\n	<build>\n		<plugins>\n			<plugin>\n				<groupId>org.springframework.boot</groupId>\n				<artifactId>spring-boot-maven-plugin</artifactId>\n				<version>2.0.3.RELEASE</version>\n				<executions>\n					<execution>\n						<goals>\n							<goal>repackage</goal>\n						</goals>\n					</execution>\n				</executions>\n			</plugin>\n		</plugins>\n	</build>\n	\n \n	\n</project>\n```\n\n', '1413704941749260289', '1', '9', '2021-12-15 20:08:07', null, '2021-12-15');
INSERT INTO `bms_post` VALUES ('1474263491274661890', '全网最细大数据初识Hadoop', '一、大数据\n\n随着近来计算机技术和互联网的发展，大数据 这个名词越来越多地进入到我们的视野中，大数据的快速发展也无时刻影响着我们的生活。\n1、大数据的定义\n\n大数据从字面来理解就是 大量的数据。日常生活离不开数据，可以说每时每刻都在产生着数据。例如，一分钟可以做些什么事呢？在日常生活中，一分钟可能连一页书都看不完。但是一分钟内产生的数据却是庞大的。据统计，在一分钟内，YouTube 用户上传 300 小时的新视频，电子邮件用户发送 2.4 亿条信息，Google 收到超过 278 万个搜索查询，Facebook 用户点赞 4166 667 次，消费者在网购上花费 272070 美元，Twitter 用户发布 347222 条推文，Instagram 用户每分钟发布 123060 张照片，Netflix 用户观看 77160 个小时的视频，微信红包的收发 1527777 个。\n\n这些数据还在不停地增长，那么大数据究竟是什么？国际顶级权威咨询机构麦肯锡 说：“大数据指的是所涉及的数据集规模已经超过了传统数据库软件获取、存储、管理和分析的能力。这是一个被故意设计成的具有主观性的定义，并且是一个关于多大的数据集才能被认为是大数据的可变定义，即并不定义大于一个特定数字的 TB 才叫大数据。因为随着技术的不断发展，符合大数据标志的数据集容量也会增长；并且定义随不同行业也有变化，这也依赖于在一个特定行业通常使用何种软件和数据集有多大。因此，大数据在今天不同行业中的范围可以从几十 TB 到几 PB”。\n\n从上面的定义中可以看出：\n\n```\n多大的数据才算大数据，这并没有一个明确的界定，且不同行业有不同的标准。\n大数据不仅仅只是大，它还包含了数据集规模已经超过了传统数据库软件获取、存储、分析和管理能力这一层意思。\n大数据不一定永远是大数据，大数据的标准是可变的，在 20 年前 1GB 的数据也可以叫大数据。可见，随着计算机硬件技术的发展，符合大数据标志的数据集容量也会增长。\n```\n\n现在所说的大数据实际上更多是从应用的层面，比如某公司搜集、整理了大量的用户行为信息，然后通过数据分析手段对这些信息进行分析从而得出对公司有利用价值的结果。比如，头条、热搜的产生，就是建立在对海量用户的阅读信息的搜集、分析之上。这就是大数据在现实中的具体体现。\n2、大数据的特点\n\nIBM 提出大数据具有 5V 特点，分别为：Volume(大量)、Velocity(高速)、Variety(多样)、Value(低价值密度)、Veracity(真实性)，下面具体说明此 5V 特点。\n\n```\nVolume：巨大的数据量，采集、存储和计算的量都非常大。大数据的起始计量单位至少是 PB(1000TB)、EB(100万TB)或ZB(10亿TB)。\n\n8 bit = 1 Byte 一字节\n1024 B = 1 KB （KiloByte） 千字节\n1024 KB = 1 MB （MegaByte） 兆字节\n1024 MB = 1 GB （GigaByte） 吉字节\n1024 GB = 1 TB （TeraByte） 太字节\n1024 TB = 1 PB （PetaByte） 拍字节\n1024 PB = 1 EB （ExaByte） 艾字节\n1024 EB = 1 ZB （ZetaByte） 泽字节\n1024 ZB = 1 YB （YottaByte） 尧字节\n1024 YB = 1BB（Brontobyte）珀字节\n1024 BB = 1 NB （NonaByte） 诺字节\n1024 NB = 1 DB （DoggaByte）刀字节\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n\nVelocity：因为要保证数据的时效性，数据增长速度和处理速度必须要迅速。比如搜索引擎要求几分钟前的新闻都能够被用户查询到，个性化推荐算法尽可能要求实时完成推荐。这是大数据区别于传统数据挖掘的显著特征。\nVariety：种类和来源多样化。包括结构化、半结构化和非结构化数据，具体表现为网络日志、音频、视频、图片、地理位置信息等，多类型的数据对数据的处理能力提出了更高的要求。\nValue：数据价值密度相对较低。随着互联网以及物联网的广泛应用，信息感知无处不在，信息海量，但价值密度较低。那么如何结合业务逻辑并通过强大的机器算法来挖掘数据价值，是大数据时代最需要解决的问题。\nVeracity：数据的准确性和可信赖度，即为数据的质量。\n```\n\n3、大数据行业应用\n\n通过上面的介绍，读者或许并不能直观地理解何为大数据，下面通过几个大数据的应用案例来更形象地了解大数据。在日常生活中，最常见的大数据应用的例子就是手机中各种社交、娱乐、购物类的 App。例如听歌类 App 有 每日推荐 版块，此版块中的歌曲就是根据用户平时听歌类型或者同一歌手演唱的歌曲而来的；使用淘宝 App，浏览商品后，主页显示或者推送的都是类似商品，如下图所示，类似的 App 有很多，可见大数据已经广泛融入了我们的日常生活中。\n在这里插入图片描述\n除了手机 App，大数据的应用已经渗透到各行各业中。\n\n(1) 医疗大数据。除了较早前就开始利用大数据的互联网公司，医疗行业是让大数据分析最先发扬光大的传统行业之一。Seton Healthcare 是采用 IBM 最新沃森技术医疗保健内容分析预测的首个客户。该技术允许企业找到大量病人相关的临床医疗信息，通过大数据处理，更好地分析病人的信息。在加拿大多伦多的一家医院，针对早产婴儿，每秒钟有超过 3000 次的数据读取。通过这些数据分析，医院能够提前知道哪些早产儿出现问题并且有针对性地采取措施，避免早产婴儿夭折。同时大数据让更多的创业者更方便地开发产品，比如通过社交网络来收集数据的健康类 App。也许未来数年后，它们搜集的数据能让医生给你的诊断变得更为精确，比方说不是通用的 成人每日三次，一次一片，而是检测到你的血液中药剂已经代谢完成会自动提醒你再次服药，等等。\n\n(2) 金融大数据。大数据在金融行业应用范围较广，典型的案例有花旗银行利用 IBM 沃森电脑为财富管理客户推荐产品；美国银行利用客户点击数据集为客户提供特色服务，如设定竞争的信用额度；招商银行利用客户刷卡、存取款、电子银行转账、微信评论等行为数据进行分析，每周给客户发送针对性广告信息，里面有顾客可能感兴趣的产品和优惠信息。大数据在金融行业的应用可以总结为以下五个方面：\n\n```\n精准营销：依据客户消费习惯、地理位置、消费时间进行推荐。\n风险管控：依据客户消费和现金流提供信用评级或融资支持，利用客户社交行为记录实施信用卡反欺诈。\n决策支持：利用决策树技术进抵押贷款管理，利用数据分析报告实施产业信贷风险控制。\n效率提升：利用金融行业全局数据了解业务运营薄弱点，利用大数据技术加快内部数据处理速度。\n产品设计：利用大数据计算技术为财富客户推荐产品，利用客户行为数据设计满足客户需求的金融产品。\n```\n\n(3) 交通大数据。目前，交通的大数据应用主要在两个方面，一方面可以利用大数据传感器数据来了解车辆通行密度，合理进行道路规划包括单行线路规划；另一方面可以利用大数据来实现即时信号灯调度，提高已有线路运行能力。科学的安排信号灯是一个复杂的系统工程，必须利用大数据计算平台才能计算出一个较为合理的方案。科学的信号灯安排将会提高 30％ 左右已有道路的通行能力。在美国，政府依据某一路段的交通事故信息来增设信号灯，使交通事故率降低了 50% 以上。依靠大数据将会提高航班管理的效率，航空公司利用大数据可以提高上座率，降低运行成本。铁路利用大数据可以有效安排客运和货运列车，提高效率、降低成本。\n\n(4) 教育大数据。在课堂上，数据不仅可以帮助改善教育教学，在重大教育决策制定和教育改革方面，大数据更有用武之地。美国利用数据来诊断处在辍学危险期的学生、探索教育开支与学生学习成绩提升的关系、探索学生缺课与成绩的关系。比如美国某州公立中小学的数据分析显示，在语文成绩上，教师高考分数和学生成绩呈现显著的正相关。也就是说，教师的高考成绩与他们现在所教语文课上的学生学习成绩有很明显的关系；教师的高考成绩越好，学生的语文成绩也越好。这个关系让我们进一步探讨其背后真正的原因。其实，教师高考成绩高低在某种程度上是教师的某个特点在起作用，而正是这个特点对教好学生起着至关重要的作用，因此教师的高考分数可以作为挑选教师的一个指标。如果有了充分的数据，便可以发掘更多的教师特征和学生成绩之间的关系，从而为挑选教师提供更好的参考。\n\n大数据还可以帮助家长和教师甄别出孩子的学习差距，提供有效的学习方法。比如，美国的麦格劳·希尔教育出版集团就开发出了一种预测评估工具，帮助学生评估他们已有的知识和达标测验所需程度的差距，进而指出学生有待提高的地方。评估工具可以让教师跟踪学生学习情况，从而找到学生的学习特点和方法。有些学生适合按部就班，有些则更适合图式信息和整合信息的非线性学习。这些都可以通过大数据搜集和分析很快识别出来，从而为教育教学提供坚实的依据。\n\n(5) 商业大数据。全球零售业的巨头沃尔玛也通过大数据获益。公司在对消费者购物行为进行分析时发现，男性顾客在购买婴儿尿片时，常常会顺便搭配几瓶啤酒来犒劳自己，于是推出了将啤酒和尿布捆绑销售的促销手段。如今，这一 啤酒＋尿布 的数据分析成果也成了大数据技术应用的经典案例。\n\n大家可以百度一下 买披萨的故事，深入了解大数据。\n\n基于大数据应用的行业实例数不胜数，并且都为各个行业带来了可观的效益，甚至改善了人们的生活水平。随着大数据的应用越来越广泛，应用的行业也越来越多，我们每日都可以看到大数据的一些新颖的应用，从而帮助人们从中获取到真正有用的价值。\n4、Hadoop 与大数据\n\n大数据目前分为四大块：大数据技术、大数据工程、大数据科学和大数据应用。其中云计算是属于大数据技术的范畴，是一种通过 Internet 以服务的方式提供动态可伸缩的虚拟化的资源的计算模式。它利用由大量计算节点构成的可动态调整的虚拟化计算资源，通过并行化和分布式计算技术，实现业务质量的可控的大数据处理的计算技术。\n\n那么这种计算模式如何实现呢，Hadoop 的来临解决了这个问题。作为云计算技术中的佼佼者，Hadoop 以其低成本和高效率的特性赢得了市场的认可，下图显示了云计算、大数据和 Hadoop 的关系。\n在这里插入图片描述\nHadoop 是用一种可靠、高效、可扩展的方式存储、管理大数据。Hadoop 及其生态圈为管理、挖掘大数据提供了一套成熟可靠的解决方案。从功能上说，Hadooop 可以称作一个 大数据管理和分析平台。\n\nHadoop 是一个开源的大数据分析软件，或者说编程模式。它是通过分布式的方式处理大数据的，因为开源的原因现在很多企业都在运用 hadoop 的技术来解决一些大数据的问题，在数据仓库方面 hadoop 是非常强大的。但在数据集市以及实时的分析展现层面上，hadoop 也有着明显的不足。\n5、其他大数据处理平台\n\n大数据技术正渗透到各行各业。作为数据分布式处理系统的典型代表，Hadoop 已成为该领域的主要核心。但 Hadoop 并不等于大数据，它只是一个成功的分布式系统，用于处理离线数据。大数据领域中还有许多其他类型的处理系统。除了 Hadoop 之外，Storm 和 Apache Spark 也是优秀的大数据处理平台，下面分别介绍。\n\n(1) Storm。在介绍 Storm 之前，首先介绍一下什么是流式数据。在现实生活中，很多数据都属于流式数据，即计算的输入并不是一个文件，而是源源不断的数据流，如网上实时交易所产生的数据。用户需要对这些数据进行分析，否则数据的价值会随着时间的流逝而消失。Storm 是一个成熟的分布式流计算平台，擅长流处理或者复杂事件处理。Storm 有以下几个关键特性：\n\n```\n使用场景广泛。\n具备良好的伸缩性。\n保证数据无丢失。\n异常健壮。\n具备良好的容错性。\n支持多语言编程。\n```\n\n需要注意的是，Storm 采用的计算模型不是 MapReduce，同时 MapReduce 也已经被证明不适合做流处理。另外，Storm 运行在 YARN 之上，从这个角度来说，它属于 Hadoop 组件。\n\n(2) Apache Spark。Apache Spark 是一个基于内存计算的开源的集群计算系统，目的是让数据分析更加快速。Spark 非常小巧玲珑，由加州伯克利大学 AMP 实验室的 Matei 为主的小团队所开发。使用的语言是 Scala，项目核心部分的代码只有 63 个 Scala 文件，非常短小精悍。\n\nSpark是一种与 Hadoop 相似的开源集群计算环境，但是两者之间还存在一些不同之处，这些不同之处使 Spark 在负载方面表现得更加优越，换句话说，Spark 启用了内存分布数据集，除了能够提供交互式查询外，它还可以优化迭代工作负载。\n\nSpark 还引进了名为弹性分布式数据集(RDD)的抽象。RDD 是分布在一组节点中的只读对象集合。这些集合是弹性的，如果数据集一部分丢失，则可以对它们进行重建。RDD 的计算速度在特定场景下大幅度领先 MapReduce。Spark 的主要优势包括以下几个方面：\n\n```\n提供了一套支持 DAG 的分布式并行计算的编程框架，减少多次计算之间中间结果写到 HDFS 的开销。\n提供 Cache 极致来支持需要反复迭代计算或者多次数据共享，减少数据读取的 I/O 开销。\n使用多线程池模型来减少任务启动开销，减少 Shuffle 过程中不必要的 Sort 操作以及减少磁盘 I/O 操作。\n广泛的数据集操作类型。\n```\n\n目前 Spark 的发展势头十分迅猛，围绕 Spark 的生态圈已初具规模，如下图所示：\n在这里插入图片描述\n其中 Spark SQL 为支持 SQL 的结构化查询工具，Spark Streaming 为 Spark 的流计算框架，MLlib 集成了主流机器学习算法，GraphX 则是 Spark 的图计算框架。\n\nSpark 具有很强的适应性，能够读取 HDFS、S3、HBase 等为持久层读写原生数据，能够以 Mesos、YARN 和自身携带的 Standalone 作为资源管理器调度 job，来完成 Spark 应用程序的计算。\n\n与 Hadoop 类似，Spark 支持单节点集群或多节点集群。对于多节点操作，Spark 依赖于 Mesos 集群管理器。Mesos 为分布式应用程序的资源共享和隔离提供了一个有效平台。该设置允许 Spark 与 Hadoop 共存于节点的一个共享池中。\n\n官方资料介绍 Spark 可以将 Hadoop 集群中的应用在内存中的运行速度提升 100 倍，甚至能够将应用在磁盘上的运行速度提升 10 倍。\n6、大数据人才\n\n大数据行业越来越受欢迎，同时对大数据人才的能力和要求也日益增加，大数据都有哪些岗位？学习大数据需要具备哪些能力？下面一一为大家介绍。大数据从业者的岗位包括以下方面：\n\n```\n首席数据官。首席数据官（Chief Data Officer，简称 CDO）和数据科学家（或称数据分析师）是企业所需的大数据人才的典型代表。CDO 主要是负责根据企业的业务需求、选择数据库以及数据抽取、转换和分析等工具，进行相关的数据挖掘、数据处理和分析，并且根据数据分析的结果战略性地对企业未来的业务发展和运营提供相应的建议和意见。通过 CDO 加强数据管控，可提高对业务风险的控制水平，是企业应对经济、金融危机的重要措施。\n\n一位合格的 CDO 须具备五种能力：统计学、数学的能力；洞悉网络产业和发展趋势的能力；IT 设备和技术选型的能力；商业运营的能力；管理和沟通的能力。他们不仅要关注系统架构中所承载的内容，更要担任企业决策和数据分析汇整的枢纽；要熟悉面向服务的架构（SOA）、商业智能（BI）、大规模数据集成系统、数据存储交换机制，以及数据库、可扩展标记语言（XML）、电子数据交换（EDI）等系统架构；要深入了解企业的业务状况和所处的产业背景，清楚地了解组织的数据源、大小和结构等，才可将数据资料与业务状态联合起来分析，并提出相对应的市场和产品策略。\n\n数据科学家(数据分析师)。数据科学家是指能采用科学方法、运用数据挖掘工具对复杂多量的数字、符号、文字、网址、音频或视频等信息进行数字化重现与认识，并能寻找新的数据洞察的工程师或专家。一个优秀的数据科学家需要具备的素质有：数据采集、数学算法、数学软件、数据分析、预测分析、市场应用、决策分析等。\n\n数据科学家应当能够熟练使用统计工具。为了提高工作效率，数据科学家要熟练使用一种或多种分析工具。Excel 是当前最为流行的小规模数据处理工具，SAS 工具也在广泛应用。而以 Hadoop 为代表的数据管理工具，也越来越广泛地应用于数据业务中。\n\n大数据开发工程师。大数据开发工程师应具备：良好的数学背景、很强的计算机编程能力，除此之外，还应具有特定应用领域或行业的知识。大数据开发工程师这个角色很重要的一点是，不能脱离市场，因为大数据只有和特定领域的应用结合起来才能产生价值。不能只懂数据，还要有商业头脑，不论对零售、医药、游戏还是旅游等行业，都能对其中某些领域有良好的裂解，最好与企业的业务方向一致。\n\n对于一名优秀的大数据开发工程师，除了上面列出三点能力要求外，还有一个非常重要的要求，即必须深入理解大数据系统架构，各个组件的基本原理，实现机制甚至其中涉及的算法等。只有这样，他们才能构建一个强大且稳定的分布式集群系统，并充分利用其分布式存储和并行计算能力来处理大数据。\n\n对大多数企业来说，因为 Hadoop 开源且高效，所以形成了以 Hadoop 为核心的大数据生态系统。那么大数据开发工程师，就必须深入理解以 Hadoop 为核心的大数据生态系统的系统构架，原理及开发应用，并具有充分的优化经验，才能利用 Hadoop 处理大规模数据，甚至在 Hadoop 平台上开发特定应用的新组件。当然，大数据开发工程师还需要具有大数据采集、大数据预处理、大数据存储与管理、分析挖掘与展现应用等大数据相关技术。\n\n大数据运维工程师。企业除了大数据分析人才、开发人才外，还需要有数据采集、管理、运维方面的人才。由于大数据系统是一个非常复杂的系统，大数据运维工程师应掌握非常多的内容：熟悉 Java、Python、Shell 等语言；熟悉 Hadoop 工作原理，对 HDFS、MapReduce 运行过程有深入理解，有 MapReduce 开发经验，熟悉数据仓库体系构架，熟悉数据建模；熟悉至少一种数据库，如 MySQL、Oracle、SQL Server，熟练使用 SQL 语言，懂 SQL 调优；熟悉大数据生态圈及其他技术，如 HBase、Storm、Spark、Impala 等技术。\n```\n\n二、什么是 Hadoop\n1、Hadoop 简介\n\nHadoop 是 Apache 软件基金会 旗下的一个 开源分布式计算平台。以分布式文件系统 HDFS(Hadoop Distributed File System) 和 MapReduce(Google MapReduce 的开源实现) 为核心的 Hadoop，为用户提供了系统底层透明的分布式基础构架。\n\nHDFS 的高容错性、高伸缩性、高性能等优点允许用户将 Hadoop 部署在廉价的硬件上，形成分布式系统，它负责数据的分布式存储和备份，文件写入后只能读取，不能修改；MapReduce 分布式编程模型允许用户在不了解分布式系统底层细节的情况下开发并行应用程序，包括 Map(映射)和 Reduce(规约)两个过程。\n\n用户可以利用 Hadoop 轻松地组织计算机资源，从而搭建自己的分布式计算平台，并且可以充分利用集群的计算和存储能力，完成海量数据的处理。\n\n简而言之，Hadoop 是适合大数据的分布式存储和计算的平台。狭义上来说，hadoop 就是单独指代 hadoop 这个软件；广义上来说，hadoop 指代大数据的一个生态圈，包括很多其他的软件。从上面的 Hadoop 介绍可以总结出 Hadoop 具有如下几个概念。\n\n```\nHadoop 是一个框架。\nHadoop 适合处理大规模数据。\nHadoop 被部署在一个集群上。\n```\n\n2、Hadoop 的发展历史\n\nHadoop 的发展距今不足 20 年，不能算是一个有丰厚底蕴或是新兴的技术，但是为大数据做出的贡献是巨大的。下面介绍 Hadoop 的发展历史。\n\n（1）Hadoop 的起源\n\nHadoop 最早起源于 Lucene 的子项目 Nutch。Nutch 的设计目标是构建一个大型的全网搜索引擎，包括网页抓取、索引、查询等功能，但随着抓取网页数量的增加，遇到了严重的可扩展性问题——如何解决数十亿网页的存储和索引问题。2003年、2004年谷歌发表的三篇论文为该问题提供了可行的解决方案：\n\n1、分布式文件系统(GFS)，可用于处理海量网页的存储。\n2、分布式计算框架(MapReduce)，可用于处理海量网页的索引计算问题。\n3、分布式数据存储系统(BigTable)，用来处理海量的数据的一种非关系型的数据库。\n\n谷歌虽然没有将其核心技术开源，但是这三篇论文已经向开源社区的 大牛们 指明了方向，一位大牛：Doug Cutting，使用 Java 语言对 Google 的云计算核心技术(主要是 GFS 和 MapReduce )做了开源的实现，使 Nutch 性能飙升。随后 Yahoo 招聘 Doug Cutting 继续完善 Hadoop 项目。2005年，Hadoop 作为 Lucene 的子项目 Nutch 的一部分正式引入 Apache 基金会。2006年2月被分离出来，成为一套完整独立的软件，起名为 Hadoop。到2008年1月，Hadoop 成为 Apache 顶级项目(同年，cloudera 公司成立，全球知名企业级数据管理和数据分析平台提供商)，迎来了它的快速发展期。\n\nHadoop 的成长过程为：Lucene ⇒ Nutch ⇒ Hadoop\nHadoop的核心组件的演变关系：\nGFS–>HDFS\nGoogle MapReduce–>Hadoop MapReduce\nBigTable–>HBase\n\n（2）Hadoop的发展历程。Hadoop 的发展历程如下图所示：\n在这里插入图片描述\n接下来看一下 Hadoop 的发行版，什么叫发行版呢？举一个大家接触比较多的例子，目前手机操作系统有两大阵营，一个是苹果的 IOS，还有一个是谷歌的 Android。IOS 是闭源的，也就不存在多个发行版了，如果你基于 IOS 改造一下，弄一个新的手机系统出来，会被苹果告破产的。所以 IOS 是没有其它发行版的，只有官方这一个版本。\n\nAndroid 是开源的，所以基于这个系统，很多手机厂商都会对它进行封装改造，因为这些手机厂商会感觉原生的 Android 系统的界面看起来比较 low，或者某一些功能不太适合中国人的使用习惯，所以他们就会进行改造，例如国内的魅族、小米、锤子这些手机厂商都基于 Android 打造了自己的手机操作系统，那这些就是 Android 系统的一些发行版。\n\n那针对 Hadoop 也是一样的，目前 Hadoop 已经演变为大数据的代名词，形成了一套完善的大数据生态系统，并且 Hadoop 是 Apache 开源的，它的开源协议决定了任何人都可以对其进行修改，并作为开源或者商业版进行发布/销售。\n\n所以目前 Hadoop 发行版非常的多，有华为发行版、Intel 发行版、Cloudera 发行版 CDH、Hortonworks 发行版 HDP，这些发行版都是基于 Apache Hadoop 衍生出来的。在这里我们挑几个重点的分析一下：\n\n首先是官方原生版本：Apache Hadoop。Apache 是一个 IT 领域的公益组织，类似于红十字会，Apache 这个组织里面的软件都是开源的，大家可以随便使用，随便修改，后续博主博文中的学习笔记 99% 的大数据技术框架都是 Apache 开源的，所以在这里我们会学习原生的 Hadoop，只要掌握了原生 Hadoop 使用，后期想要操作其它发行版的 Hadoop 也是很简单的，其它发行版都是会兼容原生 Hadoop 的，这一点读者不用担心。 原生 Hadoop 的缺点是没有技术支持，遇到问题需要自己解决，或者通过官网的社区提问，但是回复一般比较慢，也不保证能解决问题， 还有一点就是原生 Hadoop 搭建集群的时候比较麻烦，需要修改很多配置文件，如果集群机器过多的话，针对运维人员的压力是比较大的，这块等后面读者自己在搭建集群的时候大家就可以感受到了。\n\n那接着往下面看 Cloudera Hadoop(CDH)。注意了，CDH 是一个商业版本，它对官方版本做了一些优化，提供收费技术支持，提供界面操作，方便集群运维管理 CDH 目前在企业中使用的还是比较多的，虽然 CDH 是收费的，但是 CDH 中的一些基本功能是不收费的，可以一直使用，高级功能是需要收费才能使用的，如果不想付费，也能凑合着使用。\n\n还有一个比较常用的是 HortonWorks(HDP)。它呢，是开源的，也提供的有界面操作，方便运维管理，一般互联网公司偏向于使用这个。注意了，再爆一个料，最新消息，目前 HDP 已经被 CDH 收购，都是属于一个公司的产品，后期 HDP 是否会合并到 CDH 中，还不得而知，具体还要看这个公司的运营策略了。\n\n最终的建议：建议在实际工作中搭建大数据平台时选择 CDH 或者 HDP，方便运维管理，要不然，管理上千台机器的原生 Hadoop 集群，运维同学是会哭的。注意了，学习过程中我们使用原生 Hadoop，在最后博主会说一下 CDH 和 HDP 的使用。\n\n目前 Hadoop 经历了三个大的版本\n在这里插入图片描述\n从 1.x 到 2.x 再到 3.x。每一个大版本的升级都带来了一些质的提升，下面我们先从架构层面分析一下这三大版本的变更：\n在这里插入图片描述\n从 Hadoop1.x 升级到 Hadoop2.x，架构发生了比较大的变化，这里面的 HDFS 是分布式存储，MapRecue 是分布式计算，咱们前面说了 Hadoop 解决了分布式存储和分布式计算的问题，对应的就是这两个模块。在 Hadoop2.x 的架构中，多了一个模块 YARN，这个是一个负责资源管理的模块，那在 Hadoop1.x 中就不需要进行资源管理吗？也是需要的，只不过是在 Hadoop1.x 中，分布式计算和资源管理都是 MapReduce 负责的，从 Hadoop2.x 开始把资源管理单独拆分出来了，拆分出来的好处就是，YARN 变成了一个公共的资源管理平台，在它上面不仅仅可以跑 MapReduce 程序，还可以跑很多其他的程序，只要你的程序满足 YARN 的规则即可。Hadoop 的这一步棋走的是最好的，这样自己摇身一变就变成了一个公共的平台，由于它起步早，占有的市场份额也多，后期其它新兴起的计算框架一般都会支持在 YARN 上面运行，这样 Hadoop 就保证了自己的地位。后面学习笔记中的Spark、Flink 等计算框架都是支持在 YARN 上面执行的，并且在实际工作中也都是在 YARN 上面执行。Hadoop3.x 的架构并没有发生什么变化，但是它在其他细节方面做了很多优化。在这里我挑几个常见点说一下：\n\n```\n最低 Java 版本要求从 Java7 变为 Java8\n在 Hadoop 3.x 中，HDFS 支持纠删码，纠删码是一种比副本存储更节省存储空间的数据持久化存储方法，使用这种方法，相同容错的情况下可以比之前节省一半的存储空间。详细介绍在这里： https://hadoop.apache.org/docs/r3.0.0/hadoop-project-dist/hadoop-hdfs/HDFSErasureCoding.html\nHadoop 2.x 中的 HDFS 最多支持两个 NameNode，一主一备，而 Hadoop3.x 中的 HDFS 支持多个 NameNode，一主多备，详细介绍在这里： https://hadoop.apache.org/docs/r3.0.0/hadoop-project-dist/hadoop-hdfs/HDFSErasureCoding.html\nMapReduce 任务级本地优化，MapReduce 添加了映射输出收集器的本地化实现的支持。对于密集型的洗牌操作(shuffle-intensive)jobs，可以带来 30% 的性能提升，详细介绍在这里： https://issues.apache.org/jira/browse/MAPREDUCE-2841\n修改了多重服务的默认端口，Hadoop 2.x 中一些服务的端口和 Hadoop3 中是不一样的\n```\n\n总结： Hadoop 3.x 和 2.x 之间的主要区别在于新版本提供了更好的优化和可用性。详细的优化点也可以参考官网内容： https://hadoop.apache.org/docs/r3.0.0/index.html\n\n（3）Hadoop 的名字起源。Hadoop 名字不是一个缩写的单词，而是一个人为造出来的词。是以 Hadoop 之父 Doug Cutting 儿子的毛绒玩具象命名的。所以 Hadoop 的标志为一头小象，如下图所示：\n在这里插入图片描述\n所以我们需要不断努力地学习，等以后我们也达到这种高度的时候，在实现一个框架的时候用自己的名字来命名那就很炫酷了。\n3、Hadoop 的特点\n\nHadoop 是一个能够让用户轻松架构和使用的分布式计算平台。用户可以轻松地在 Hadoop 上开发和运行处理海量数据的应用程序。它主要有以下几个优点：\n\n```\n高可靠性。数据存储不仅有多个备份，而且集群设置在不同机器上，可以防止一个节点宕机而造成的机器损坏。\n高扩展性。Hadoop 是在可用的计算机集群间分配数据并完成计算任务。为集群添加新的节点并不复杂，所以集群可以很容易进行节点的扩展，扩大集群。\n高效性。Hadoop 能够在节点之间动态地移动数据，在数据所在节点进行并发处理，并保证各个节点的动态平衡，因此处理速度非常快。\n高容错性。Hadoop 的分布式文件系统 HDFS 在存储文件时会在多个节点或多台机器上存储文件的备份副本，当读取该文档出错或某一台机器宕机了，系统会调用其他节点上的备份文件，保存程序顺利运行。如果启动的任务失败，Hadoop 会重新运行该任务或启用其他任务来完成这个任务没有完成的部分。\n低成本。Hadoop 是开源的，不需要支付任何费用即可下载安装使用，节省了购买软件的成本。此外，Hadoop 依赖于社区服务，因此它的成本比较低，任何人都可以使用。\n可构建在廉价机器上。Hadoop 对机器的配置要求不高，大部分普通商用服务器就可以满足要求。\n```\n\n三、Hadoop 核心\n\n在上面介绍过，以 Hadoop 为中心形成了一个生态圈，如下图所示：\n在这里插入图片描述\n1、分布式文件系统——HDFS\n\n1、HDFS 架构及简介\n\nHDFS(Hadoop Distributed File System)是 Hadoop 项目的核心子项目，主要负责集群数据的存储与读取，HDFS 是一个主/从(Master/Slave) 体系结构的分布式文件系统。HDFS 支持传统的层次型文件组织结构，用户或者应用程序可以创建目录，然后将文件保存在这些目录中。文件系统名字空间的层次结构和大多数现有的文件系统类似，可以通过文件路径对文件执行创建、读取、更新和删除操作。但是由于分布式存储的性质，它又和传统的文件系统有明显的区别。HDFS 的基本架构如下图所示：\n在这里插入图片描述\nHDFS 文件系统主要包括一个 NameNode、一个 Secondary NameNode 和多个 DataNode，其中 NameNode、Secondary NameNode 运行在 Master 节点，DataNode 运行在 Slave 节点上。下面分别介绍。\n\n```\n元数据。元数据不是具体的文件内容，它有三类重要信息：第一类是文件和目录自身的属性信息，例如文件名、目录名、父目录信息、文件大小、创建时间和修改时间等；第二类记录文件内容存储的相关信息，例如文件分块情况、副本个数、每个副本所在的DataNode信息等；第三类用来记录HDFS中所有DataNode的信息，用于DataNode管理。\nNameNode。NameNode 用于存储元数据以及处理客户端发出的请求。在 NameNode 中存放元数据的文件是 fsimage 文件。在系统运行期间，所有对元数据的操作都保存在内存中，并被持久化到另一个文件 edits 中。当 NameNode 启动的时候，fsimage 会被加载到内存，然后对内存里的数据执行 edits 所记录的操作，以确保内存所保留的数据处于最新的状态。fsimage与edits数据保存的过程如下图所示：\n在这里插入图片描述\nSecondary NameNode。Secondary NameNode 用于备份 NameNode 的数据，周期性将 edits 文件合并到 fsimage 文件并在本地备份，将新的 fsimage 文件存储到 NameNode，取代原来的 fsimage，删除 edits 文件，创建一个新的 edits 继续存储文件修改状态。Secondary NameNode 的工作过程如下图所示：\n在这里插入图片描述\nDataNode。DataNode 是真正存储数据的地方。在 DataNode 中，文件以数据块的形式进行存储。当文件传到 HDFS 端时以 128MB 的数据块将文件进行切割，将每个数据块存到不同的或相同的 DataNode 并且备份副本，一般默认 3 个，NameNode 会负责记录文件的分块信息，确保在读取该文件时可以找到并整合所有块。\n数据块。文件在上传到 HDFS 时根据系统默认文件块大小把文件分成一个个数据块，Hadoop 2.x 开始默认 128MB 为一个数据块，比如要存储大小为 129MB 的文件时，则被分成两个数据块来存储。数据块会被存储到各个节点，每个数据块都会备份副本。\n```\n\n2、HDFS分布式原理\n\n分布式系统会划分成多个子系统或模块，各自运行在不同的机器上，子系统或模块之间通过网络通信进行协作，实现最终的整体功能。利用多个节点共同协作完成一项或多项具体业务功能的系统就是分布式系统。\n\n那什么是分布式文件系统呢？分布式文件系统是分布式系统的一个子集，其解决的问题就是数据存储。也就是说，分布式文件系统是横跨在多台计算机上的存储系统，存储在分布式文件系统上的数据自动分布在不同的节点上。\n\n而 HDFS 作为一个分布式文件系统，主要体现在以下三个方面。\n\nHDFS 并不是单机文件系统，它是分布在多个集群节点上的文件系统。节点之间通过网络通信进行协作，提供多个节点的文件信息，让每个用户都可以看到文件系统的文件，让多机器上的多用户分享文件和存储空间。\n\n文件存储时被分布在多个节点上，需注意数据存储不是以文件为单位进行存储的，而是将一个文件分成一个或多个数据块存储。而数据块在存储时并不是都存储在一个节点上，而是被分布存储在各个节点中，并且数据块会在其他节点存储副本。\n\n数据从多个节点读取。读取一个文件时，从多个节点中找到该文件的数据块，分布读取所有数据块，直到最后一个数据块读取完毕。\n\n3、HDFS特点\n\n首先介绍 HDFS 的优点。\n\n```\n高容错性。HDFS上传的数据自动保存多个副本，可以通过增加副本的数据来增加它的容错性。如果某一个副本丢失，HDFS 会复制其他机器上的副本，而我们不必关注它的实现。\n适合大数据的处理。HDFS 能够处理 GB、TB 甚至 PB 级别的数据，规模达百万，数量非常大。(1PB=1024TB、1TB=1014GB)\n流式数据访问。HDFS 以流式数据访问模式来存储超大文件，一次写入，多次读取，即文件一旦写入，则不能修改，只能增加。这样可以保持数据的一致性。\n```\n\n除此之外，HDFS 有以下的缺点。\n\n```\n不适合低延迟数据访问。如果要处理一些用户要求时间比较短的低延迟应用请求，则 HDFS 不适合，因为 HDFS 是为了处理大型数据集分析任务而设计的，目的是为达到高的数据吞吐量，但这是以高延迟作为代价来换取的。\n无法高效存储大量小文件。因为 NameNode 会把文件系统的元数据放置在内存中，所以文件系统所能容纳的文件数目是由 NameNode 的内存大小来决定的，即每存入一个文件都会在 NameNode 中写入文件信息。如果写入大多小文件的话，NameNode 内存会被占满而无法写入文件信息。而与多个小文件大小相同的单一文件只会写入一次文件信息到内存中，所以更适合大文件存储。\n不支持多用户写入及任意修改文件。在 HDFS 的一个文件中只有一个写入者，而且写操作只能在文件末尾完成，即只能执行追加操作。目前 HDFS 还不支持多个用户对同一文件的写操作，以及在文件任意位置进行修改。\n```\n\n2、分布式计算框架——MapReduce\n\n（1）MapReduce 简介\n\nMapReduce 是 Hadoop 核心计算框架，适用于大规模数据集(大于1TB)并行运算的编程模型，包括 Map(映射)和 Reduce(规约) 两部分。\n\n当启动一个 MapReduce 任务时，Map 端会读取 HDFS 上的数据，将数据映射成所需要的键值对类型并传到 Reduce 端。Reduce 端接收 Map 端传过来的键值对类型的数据，根据不同键进行分组，对每一组键相同的数据进行处理，得到新的键值对并输出到 HDFS，这就是 MapReduce 的核心思想。\n\n（2）MapReduce工作原理\n\nMapReduce 作业执行流程如下图所示：\n在这里插入图片描述\n一个完整的 MapReduce 过程包含数据的输入与分片、Map 阶段数据处理、Reduce 阶段数据处理、数据输出等阶段，下面分别介绍。\n\n```\n读取输入数据。MapReduce 过程中的数据是从 HDFS 分布式文件系统中读取的。文件在上传到 HDFS 时，一般按照 128MB 分成了几个数据块，所以在运行 MapReduce 程序时，每个数据块都会生成一个 Map，但是也可以通过重新设置文件分片大小调整 Map 的个数，在运行 MapReduce 时会根据所设置的分片大小对文件重新分割(Split)，一个分片大小的数据块就会对应一个Map。\n\nMap 阶段。程序有一个或多个 Map，由默认存储或分片个数决定。针对 Map 阶段，数据以键值对的形式读入，键的值一般为每行首字符与文件最初始位置的偏移量，即中间所隔字符个数，值为这一行的数据记录。根据需求对键值对进行处理，映射成新的键值对，将新的键值对传到 Reduce 端。\n\nShuffle/Sort 阶段：此阶段是指从 Map 输出开始，传送 Map 输出到 Reduce 作为输入的过程。该过程会将同一个 Map 中输出的键相同的数据先进行一步整合，减少传输的数据量，并且在整合后将数据按照键排序。\n\nReduce 阶段：Reduce 任务也可以有多个，按照 Map 阶段设置的数据分区确定，一个分区数据被一个 Reduce 处理。针对每一个 Reduce 任务，Reduce 会接收到不同 Map 任务传来的数据，并且每个 Map 传来的数据都是有序的。一个 Reduce 任务中的每一次处理都是针对所有键相同的数据，对数据进行规约，以新的键值对输出到 HDFS。\n```\n\n根据上述内容分析，MapReduce 的本质可以用一张图完整地表现出来，如下图所示：\n在这里插入图片描述\nMapReduce 的本质就是把一组键值对 <K1,V1> 经过 Map 阶段映射成新的键值对 <K2,V2>，接着经过 Shuffle/Sort 阶段进行排序和 洗牌，把键值对排序，同时把相同的键值整合，最后经过 Reduce 阶段，把整合后的键值对组进行逻辑处理，输出新的键值对 <K3,V3>。\n3、集群资源管理器——YARN\n\n（1）YARN 简介\n\nHadoop 的 MapReduce 架构称为 YARN(Yet Another Resource Negotiator，另一种资源协调者)，是效率更高的资源管理核心。\n\n（2）YARN 的基本构架\n\nYARN 主要包含三大模块：Resource Manager（RM）、Node Manager（NM）、Application Master（AM）。其中，Resource Manager 负责所有资源的监控、分配和管理；Application Master 负责每一个具体应用程序的调度和协调；Node Manager 负责每一个节点的维护。对于所有的 applications，RM 拥有绝对的控制权和对资源的分配权。而每个 AM 则会和 RM 协商资源，同时和 Node Manager 通信来执行和监控 task。YARN 的框架图如下图所示：\n在这里插入图片描述\n从上图中可以看出：\n\n```\n在 Client 客户端，用户会向 Resource Manager 请求执行运算(或执行任务)。\n在 NameNode 会有 Resource Manager 统筹管理运算的请求。\n在其他的 DataNode 会有 Node Manager 负责运行，以及监督每一个任务(task)，并且向 Resource Manager 汇报状态。\n```\n\n四、Hadoop 常用组件\n\n除了上面介绍的 Hadoop 三大核心组件之外，Hadoop 生态圈中还有许多组件，这些组件各有特点，共同为 Hadoop 的相关工程服务。由于大部分组建的 LOGO 选用了动物图形，因此 Hadoop 的生态系统就像是一群动物在狂欢，如下图所示：\n在这里插入图片描述\n下面介绍 Hadoop 的常用组件，为了方便理解以下按照功能进行了分类，并且把较为流行的排在了前面介绍，如下表所示：\n在这里插入图片描述\n五、Hadoop 在国内外的应用情况\n\nHadoop 是一个开源的高效云计算基础架构平台，其不仅仅在云计算领域用途广泛，还可以支撑搜索引擎服务，作为搜索引擎底层的基础架构系统，同时在海量数据处理、数据挖掘、机器学习、科学计算等领域都越来越受到青睐。\n\n在国外，Hadoop 的应用十分广泛，例如 Yahoo、Facebook、Adobe、IBM等等。例如，Yahoo 是 Hadoop 的最大支持者。Yahoo 的 Hadoop 应用主要包括：广告分析系统、用户行为分析、Web 搜索、反垃圾邮件系统等。Facebook 使用 Hadoop 存储内部日志与多维数据，并以此作为报告、分析和机器学习的数据源。Adobe 主要使用 Hadoop 及 HBase，用于支撑社会服务计算，以及结构化的数据存储和处理。\n\n而国内，互联网公司是 Hadoop 在国内的主要使用力量，有以下公司：阿里巴巴、百度、腾讯、网易、金山、华为、中国移动等。阿里巴巴、腾讯都是国内最先使用 Hadoop 的公司。\n\n中科研究所举办过几次 Hadoop 技术大会，加速了 Hadoop 在国内的发展。\n\n', '1474262823382081537', '0', '22', '2021-12-24 14:19:41', null, '2021-12-24');
INSERT INTO `bms_post` VALUES ('1476371999474343938', 'Python自定义命令行参数', 'Python自定义命令行参数:-1: \n\n使用到的方法为 argparse.ArgumentParser() ，此模块有中文文档，建议链接 到官方中文文档中查看。\nargparse.ArgumentParser()\n\n此模块可以让人轻松编写用户友好的命令行接口。程序定义它需要的参数，然后 argparse 将弄清如何从 sys.argv 解析出那些参数。 argparse 模块还会自动生成帮助和使用手册「常见的-h」，并在用户给程序传入无效参数时报出错误信息。\n使用流程\n1、创建一个解析器：\n\n第一步：创建一个 ArgumentParser 对象：\n\nparser = argparse.ArgumentParser(description=\'Process some integers.\')\n\n```\n1\n```\n\nArgumentParser 对象包含将命令行解析成 Python 数据类型所需的全部信息。\n备注：想知道具体信息可点击类，查看其中的源码\n2、添加参数：\n\nArgumentParser 对象添加参数的方法为：add_argument()\n\nparser.add_argument(\'integers\', metavar=\'N\', type=int, nargs=\'+\',\nhelp=\'an integer for the accumulator\')\nparser.add_argument(\'--sum\', dest=\'accumulate\', action=\'store_const\',\nconst=sum, default=max,\nhelp=\'sum the integers (default: find the max)\')\n\n```\n1\n2\n3\n4\n5\n```\n\n调用 parse_args() 将返回一个具有integers和 accumulate 属性的对象，integers 属性将是一个包含一个或多个整数的列表。而accumulate属性，当传递的参数为–sum时，则是求和「sum() 函数」，当不传参时，默认求最大值「max()函数」\n3、解析参数：\n\nArgumentParser 对象通过 parse_args() 方法解析参数，它将检查命令行，把每个参数转换为适当的类型然后调用相应的操作。\nparser.parse_args([’–sum’, ‘7’, ‘-1’, ‘42’])\n返回为：Namespace(accumulate=, integers=[7, -1, 42])\n上面是官网的例子，其实简而言之就四个步骤：\n\n1、导入模块\n\nimport argparse\n\n```\n1\n```\n\n2、创建对象\n\nparser = argparse.ArgumentParser(description=\'描述\',  usage = \"传参提示\")\n\n```\n1\n```\n\n3、添加对象属性\n\nparser.add_argument()\n\n```\n1\n```\n\n4、解析参数\n\nparser.parse_args()   或者  parser.parse_known_args()\n下面的内容会讲到这两者的区别\n\n```\n1\n2\n```\n\n至于具体的参数怎么使用，建议参考官网，本人还未参透所有参数，(。・＿・。)ﾉI’m sorry~，不过已够工作使用，待日后慢慢补充。\n工作中的使用：\n\n先上代码，下面有具体的代码解析，研究透这些，就够日常基本使用了\n\nimport argparse\n\nparser = argparse.ArgumentParser()\n\ndef arg_parser():\nparser = argparse.ArgumentParser(\nusage=\"usage: %(prog)s [参数名] [参数值]\"\n)\nparser.add_argument(\n\"--welcome\", help=\"是否展示欢迎词\", action=\'store_true\'\n)\nparser.add_argument(\n\"--login\", help=\"是否登录\", action=\'store_true\', default=True\n)\nparser.add_argument(\n\"--login_token\", help=\"登录参数\", default=None, type=str\n)\n\n```\nmodel_name = parser.add_argument_group(\"Model\", \"使用什么模型处理数据？\")\nmodel_name.add_argument(\n    \"--knn\", help=\"使用KNN方法\",\n    type=str, default=None\n)\nmodel_name.add_argument(\n    \"--tree\", help=\"使用决策树方法\",\n    type=str, default=None\n)\nreturn parser\n```\n\ndef argument_parser() -> argparse.ArgumentParser:\n\"\"\"\nConstruct an return an `argparse.ArgumentParser` instance\n\"\"\"\nreturn arg_parser()\n\nif __name__ == \'__main__\':\nparser = argument_parser()\noptions, argv_rest = parser.parse_known_args()\nif options.knn is not None:\nargv_rest = [\"-knn\", options.knn] + argv_rest\n\n```\nif options.login_token is not None:\n    print(\'login_token参数为：\', options.login_token)\n\noptions = options\narguments = argv_rest\nprint(\'options为：\', options, \'\\n\', \"arguments为：\", arguments)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n```\n\n第7行：定义parser，参数中的usage是介绍使用参数的格式，用于用户在运行 -h 时展示提示信息。如下图所示：\n在这里插入图片描述\n第10、14行：给parser添加属性，重点介绍 action 这个参数\n\n相同点：\n\n```\n第10行和第14行均是action = ‘store_true’，此参数用于布尔类型的参数\n```\n\n区别：\n\n```\n第10行中，当命令行中触发welcome参数时，返回为True，没有触发的时候返回False。\n  第14行中，当命令行中触发login参数时，返回为True，没有触发的时候取默认值返回仍为True。也就是说，传不传login参数，返回的都是True，这就是default参数的作用。\n```\n\naction其他参数请参考： https://blog.csdn.net/tsinghuahui/article/details/89279152\n\n第16行：\n\n```\n新增login_token参数，传入登录参数token，限制token类型为str，默认为None\n```\n\n提醒一句，这个type不要和action结合使用，action返回的只有布尔类型，注意参数名字大小写是不同的。\n\n第20行:\nadd_argument_group(title=None, description=None)方法：\n官方解释：\n\n```\nadd_argument_group() 方法返回一个具有 add_argument() 方法的参数分组对象，这与常规的ArgumentParser一样。当一个参数被加入分组时，解析器会将它视为一个正常的参数，但是会在不同的帮助消息分组中显示该参数。\nadd_argument_group()方法接受 title 和 description 参数，它们可被用来定制显示内容\n```\n\n是不是有点迷糊， 其实就是自定义一个参数分组，如下图所示：\n在这里插入图片描述\n\n第41行：\nparser.parse_known_args() 和 parser.parse_args() 的区别\noptions用来接收命令行中已定义了参数的信息\nargv_rest 接收在命令中未被定义的信息\n\n```\n作用：有时一个脚本可能只解析部分命令行参数，而将其余的参数继续传递给另一个脚本或程序，它的作用方式很类似 parse_args() 但区别在于当存在额外参数时它不会产生错误，额外的参数被argv_rest给接收了。\n\n使用：好比在PyQt中，像定义style这种，就可将参数赋给argv_rest，然后让系统「QApplication」去处理此参数\n```\n\n第42行：\n\n```\n假如当命令行中的参数中有knn这个参数，而这个参数我想交给系统去处理，所以我就把它添加到argv_rest之中，将这种参数，统一交给系统处理\n```\n\n第45行：\n\n```\n传入的参数中存在login_token，对login_token进行单独处理。\n```\n\n以上，是我的粗略了解，有问题的大家评论区留言，知无不言，言无不尽。感觉不错的话，别忘了点赞收藏哦！\n\n', '1413704941749260289', '0', '3', '2021-12-30 09:58:09', null, '2021-12-30');

-- ----------------------------
-- Table structure for bms_post_tag
-- ----------------------------
DROP TABLE IF EXISTS `bms_post_tag`;
CREATE TABLE `bms_post_tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `tag_id` varchar(20) NOT NULL COMMENT '标签ID',
  `topic_id` varchar(20) NOT NULL COMMENT '话题ID',
  PRIMARY KEY (`id`) USING BTREE,
  KEY `tag_id` (`tag_id`) USING BTREE,
  KEY `topic_id` (`topic_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=91 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='话题-标签 中间表';

-- ----------------------------
-- Records of bms_post_tag
-- ----------------------------
INSERT INTO `bms_post_tag` VALUES ('54', '1413714194224439298', '1413714194199273473');
INSERT INTO `bms_post_tag` VALUES ('55', '1413714809650470915', '1413714809650470914');
INSERT INTO `bms_post_tag` VALUES ('56', '1413716616757960706', '1413716616690851841');
INSERT INTO `bms_post_tag` VALUES ('57', '1413716616757960707', '1413716616690851841');
INSERT INTO `bms_post_tag` VALUES ('58', '1413716616757960708', '1413716616690851841');
INSERT INTO `bms_post_tag` VALUES ('59', '1413714809650470915', '1413716940361097218');
INSERT INTO `bms_post_tag` VALUES ('60', '1413717374899380225', '1413717374832271361');
INSERT INTO `bms_post_tag` VALUES ('61', '1413714194224439298', '1413718857074139138');
INSERT INTO `bms_post_tag` VALUES ('62', '1413714809650470915', '1413721826163220482');
INSERT INTO `bms_post_tag` VALUES ('63', '1413721826230329346', '1413721826163220482');
INSERT INTO `bms_post_tag` VALUES ('64', '1413722409557352451', '1413722409557352450');
INSERT INTO `bms_post_tag` VALUES ('65', '1413722409557352452', '1413722409557352450');
INSERT INTO `bms_post_tag` VALUES ('66', '1413727184374009857', '1413727184311095298');
INSERT INTO `bms_post_tag` VALUES ('67', '1413727184374009858', '1413727184311095298');
INSERT INTO `bms_post_tag` VALUES ('69', '1413855800340578306', '1413855800340578305');
INSERT INTO `bms_post_tag` VALUES ('70', '1413857479840563203', '1413857479840563202');
INSERT INTO `bms_post_tag` VALUES ('71', '1413857479840563204', '1413857479840563202');
INSERT INTO `bms_post_tag` VALUES ('72', '1413857938856804354', '1413857938856804353');
INSERT INTO `bms_post_tag` VALUES ('73', '1413857479840563203', '1413857938856804353');
INSERT INTO `bms_post_tag` VALUES ('74', '1413857938923913217', '1413857938856804353');
INSERT INTO `bms_post_tag` VALUES ('75', '1413857479840563203', '1413858778560659458');
INSERT INTO `bms_post_tag` VALUES ('76', '1413858778560659459', '1413858778560659458');
INSERT INTO `bms_post_tag` VALUES ('77', '1413857938856804354', '1413858778560659458');
INSERT INTO `bms_post_tag` VALUES ('78', '1413859145432236034', '1413859145432236033');
INSERT INTO `bms_post_tag` VALUES ('79', '1413859730160156675', '1413859730160156674');
INSERT INTO `bms_post_tag` VALUES ('80', '1414171656744366083', '1414171656744366082');
INSERT INTO `bms_post_tag` VALUES ('81', '1413855800340578306', '1414179936627617794');
INSERT INTO `bms_post_tag` VALUES ('82', '1413857479840563203', '1414413526369320962');
INSERT INTO `bms_post_tag` VALUES ('83', '1413857938856804354', '1414427942484520961');
INSERT INTO `bms_post_tag` VALUES ('84', '1413857479840563203', '1414427942484520961');
INSERT INTO `bms_post_tag` VALUES ('86', '1413727184374009857', '1414919568994676737');
INSERT INTO `bms_post_tag` VALUES ('87', '1415151814557089794', '1415151814523535362');
INSERT INTO `bms_post_tag` VALUES ('88', '1474263491337576449', '1474263491274661890');
INSERT INTO `bms_post_tag` VALUES ('89', '1474263491337576450', '1474263491274661890');
INSERT INTO `bms_post_tag` VALUES ('90', '1413714194224439298', '1476371999474343938');

-- ----------------------------
-- Table structure for bms_promotion
-- ----------------------------
DROP TABLE IF EXISTS `bms_promotion`;
CREATE TABLE `bms_promotion` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `title` varchar(255) DEFAULT NULL COMMENT '广告标题',
  `link` varchar(255) DEFAULT NULL COMMENT '广告链接',
  `description` varchar(255) DEFAULT NULL COMMENT '说明',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC COMMENT='广告推广表';

-- ----------------------------
-- Records of bms_promotion
-- ----------------------------
INSERT INTO `bms_promotion` VALUES ('1', '开发者头条', 'https://www.joyk.com/', '开发者头条');
INSERT INTO `bms_promotion` VALUES ('2', '并发编程网', 'https://ifeve.com/', '并发编程网');
INSERT INTO `bms_promotion` VALUES ('3', '掘金', 'https://juejin.cn/', '掘金');

-- ----------------------------
-- Table structure for bms_tag
-- ----------------------------
DROP TABLE IF EXISTS `bms_tag`;
CREATE TABLE `bms_tag` (
  `id` varchar(20) NOT NULL COMMENT '标签ID',
  `name` varchar(255) NOT NULL DEFAULT '' COMMENT '标签',
  `topic_count` int(11) NOT NULL DEFAULT '0' COMMENT '关联话题',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE KEY `name` (`name`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='标签表';

-- ----------------------------
-- Records of bms_tag
-- ----------------------------
INSERT INTO `bms_tag` VALUES ('1413714194224439298', 'python', '3');
INSERT INTO `bms_tag` VALUES ('1413714809650470915', 'java', '3');
INSERT INTO `bms_tag` VALUES ('1413716616757960706', 'html5', '1');
INSERT INTO `bms_tag` VALUES ('1413716616757960707', 'web', '1');
INSERT INTO `bms_tag` VALUES ('1413716616757960708', 'Android', '1');
INSERT INTO `bms_tag` VALUES ('1413717374899380225', 'mysql', '1');
INSERT INTO `bms_tag` VALUES ('1413721826230329346', 'offer', '1');
INSERT INTO `bms_tag` VALUES ('1413722409557352451', 'c++', '1');
INSERT INTO `bms_tag` VALUES ('1413722409557352452', 'map', '1');
INSERT INTO `bms_tag` VALUES ('1413727184374009857', 'springboot', '2');
INSERT INTO `bms_tag` VALUES ('1413727184374009858', 'springmvc', '1');
INSERT INTO `bms_tag` VALUES ('1413855800340578306', 'Vue', '2');
INSERT INTO `bms_tag` VALUES ('1413857479840563203', '人工智能', '5');
INSERT INTO `bms_tag` VALUES ('1413857479840563204', 'CV视觉', '1');
INSERT INTO `bms_tag` VALUES ('1413857938856804354', 'AI', '3');
INSERT INTO `bms_tag` VALUES ('1413857938923913217', '算法', '1');
INSERT INTO `bms_tag` VALUES ('1413858778560659459', '深度学习', '1');
INSERT INTO `bms_tag` VALUES ('1413859145432236034', 'AAB', '1');
INSERT INTO `bms_tag` VALUES ('1413859730160156675', '赚钱', '1');
INSERT INTO `bms_tag` VALUES ('1414171656744366083', 'vuex', '1');
INSERT INTO `bms_tag` VALUES ('1415151814557089794', 'b站', '0');
INSERT INTO `bms_tag` VALUES ('1415480511625502721', 'gnn', '0');
INSERT INTO `bms_tag` VALUES ('1474263491337576449', '大数据', '1');
INSERT INTO `bms_tag` VALUES ('1474263491337576450', 'hadoop', '1');

-- ----------------------------
-- Table structure for bms_tip
-- ----------------------------
DROP TABLE IF EXISTS `bms_tip`;
CREATE TABLE `bms_tip` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键',
  `content` varchar(1000) NOT NULL DEFAULT '' COMMENT '内容',
  `author` varchar(50) DEFAULT '' COMMENT '作者',
  `type` tinyint(4) NOT NULL COMMENT '1：使用，0：过期',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='每日赠言';

-- ----------------------------
-- Records of bms_tip
-- ----------------------------
INSERT INTO `bms_tip` VALUES ('1', '多锉出快锯，多做长知识。', '佚名', '1');
INSERT INTO `bms_tip` VALUES ('2', '未来总留着什么给对它抱有信心的人。', '佚名', '1');
INSERT INTO `bms_tip` VALUES ('3', '一个人的智慧不够用，两个人的智慧用不完。', '谚语', '1');
INSERT INTO `bms_tip` VALUES ('4', '十个指头按不住十个跳蚤', '傣族', '1');
INSERT INTO `bms_tip` VALUES ('5', '言不信者，行不果。', '墨子', '1');
INSERT INTO `bms_tip` VALUES ('6', '攀援而登，箕踞而遨，则几数州之土壤，皆在衽席之下。', '柳宗元', '1');
INSERT INTO `bms_tip` VALUES ('7', '美德大都包含在良好的习惯之内。', '帕利克', '1');
INSERT INTO `bms_tip` VALUES ('8', '人有不及，可以情恕。', '《晋书》', '1');
INSERT INTO `bms_tip` VALUES ('10', '真正的朋友应该说真话，不管那话多么尖锐。', '奥斯特洛夫斯基', '1');
INSERT INTO `bms_tip` VALUES ('12', '看人下菜碟', '民谚', '1');
INSERT INTO `bms_tip` VALUES ('13', '如果不是怕别人反感，女人决不会保持完整的严肃。', '拉罗什福科', '1');
INSERT INTO `bms_tip` VALUES ('14', '爱是春暖花开时对你满满的笑意', '佚名', '1');
INSERT INTO `bms_tip` VALUES ('15', '希望是坚韧的拐杖，忍耐是旅行袋，携带它们，人可以登上永恒之旅。', '罗素', '1');
INSERT INTO `bms_tip` VALUES ('19', '我们现在必须完全保持党的纪律，否则一切都会陷入污泥中。', '马克思', '1');
INSERT INTO `bms_tip` VALUES ('20', '在科学上没有平坦的大道，只有不畏劳苦沿着陡峭山路攀登的人，才有希望达到光辉的顶点。', '马克思', '1');
INSERT INTO `bms_tip` VALUES ('21', '懒惰的马嫌路远', '蒙古', '1');
INSERT INTO `bms_tip` VALUES ('22', '别忘记热水是由冷水烧成的', '非洲', '1');
INSERT INTO `bms_tip` VALUES ('23', '天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。', '孟子', '1');

-- ----------------------------
-- Table structure for ums_admin
-- ----------------------------
DROP TABLE IF EXISTS `ums_admin`;
CREATE TABLE `ums_admin` (
  `id` varchar(20) NOT NULL,
  `username` varchar(15) DEFAULT NULL,
  `password` varchar(100) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of ums_admin
-- ----------------------------
INSERT INTO `ums_admin` VALUES ('1', 'admin', 'c773861c8117a0c9ebd6566a8a25bf39', '2021-12-15 21:18:36');

-- ----------------------------
-- Table structure for ums_user
-- ----------------------------
DROP TABLE IF EXISTS `ums_user`;
CREATE TABLE `ums_user` (
  `id` varchar(20) NOT NULL COMMENT '用户ID',
  `username` varchar(15) NOT NULL DEFAULT '' COMMENT '用户名',
  `alias` varchar(255) DEFAULT NULL COMMENT '用户昵称',
  `password` varchar(100) DEFAULT '' COMMENT '密码',
  `avatar` varchar(1000) DEFAULT NULL COMMENT '头像',
  `email` varchar(255) DEFAULT NULL COMMENT '邮箱',
  `mobile` varchar(255) DEFAULT NULL COMMENT '手机',
  `score` int(11) NOT NULL DEFAULT '0' COMMENT '积分',
  `topiccount` int(11) DEFAULT NULL,
  `followercount` int(11) DEFAULT NULL,
  `job` varchar(255) DEFAULT NULL COMMENT '个人简介',
  `create_time` datetime NOT NULL COMMENT '加入时间',
  `modify_time` datetime DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE KEY `user_name` (`username`) USING BTREE,
  KEY `user_email` (`email`) USING BTREE,
  KEY `user_create_time` (`create_time`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='用户表';

-- ----------------------------
-- Records of ums_user
-- ----------------------------
INSERT INTO `ums_user` VALUES ('1413704941749260289', '小小黑', '小小黑', '96e79218965eb72c92a549dd5a330112', '@/assets/image/default.jpeg', '1875789333@qq.com', '9636532366', '7', '5', '1', '开心，乐观，向上，为成为一个好的程序猿而努力', '2021-12-13 11:41:38', null);
INSERT INTO `ums_user` VALUES ('1413705681544794113', '孔小成', '孔小成', 'f379eaf3c831b04de153469d1bec345e', '@/assets/image/default.jpeg', '1900713746@qq.com', '1859655984', '7', '5', '3', '一个阳光帅气的小男孩！', '2021-12-13 11:44:34', null);
INSERT INTO `ums_user` VALUES ('1413706063062880257', '渣渣辉', '渣渣辉', '52c69e3a57331081823331c4e69d3f2e', '@/assets/image/default.jpeg', '1974685@qq.com', null, '3', '3', '2', '未知', '2021-12-13 11:46:05', null);
INSERT INTO `ums_user` VALUES ('1413706236086308865', '李小磊', '李小磊', '5b1b68a9abf4d2cd155c81a9225fd158', '@/assets/image/default.jpeg', '9457467@163.com', null, '2', '2', '1', '未知', '2021-12-14 11:46:46', null);
INSERT INTO `ums_user` VALUES ('1413706512109260801', '蔡小亮', '蔡小亮', '21218cca77804d2ba1922c33e0151105', '@/assets/image/default.jpeg', '8596963@163.com', null, '2', '2', '1', '未知', '2021-12-14 11:47:52', null);
INSERT INTO `ums_user` VALUES ('1413706636436819970', '夏小提', '夏小提', '1a100d2c0dab19c4430e7d73762b3423', '@/assets/image/default.jpeg', '693524@qq.com', null, '2', '2', '1', '未知', '2021-12-14 11:48:22', null);
INSERT INTO `ums_user` VALUES ('1414426801273122818', '邓小文', '邓小文', 'e3ceb5881a0a1fdaad01296d7554868d', '@/assets/image/default.jpeg', '12566555@163.com', '1651656565', '1', '1', '1', '一只快乐的小文子！！！', '2021-12-15 11:30:02', null);
INSERT INTO `ums_user` VALUES ('1415479744214671362', '小红', '小红', '283f42764da6dba2522412916b031080', '@/assets/image/default.jpeg', 'dfdf@qq.com', null, '1', '0', '0', 'fsjdkfkjds', '2021-12-15 09:14:04', null);
INSERT INTO `ums_user` VALUES ('1474262823382081537', '迪小丽', '迪小丽', '96e79218965eb72c92a549dd5a330112', '@/assets/image/default.jpeg', '1907137461@qq.com', null, '1', '1', '1', '未知', '2021-12-24 14:17:02', null);
